diff -ruN mspdebug-0.22/drivers/device.h mspdebug-0.22-new/drivers/device.h
--- mspdebug-0.22/drivers/device.h	2013-07-17 20:23:16.000000000 -0400
+++ mspdebug-0.22-new/drivers/device.h	2014-03-03 17:34:57.000000000 -0500
@@ -110,6 +110,14 @@
 
 	/* Wait a little while for the CPU to change state */
 	device_status_t (*poll)(device_t dev);
+
+	/* Perform search of interrupt interleavings */
+	int (*search)(device_t dev_base, address_t num_instr, int is_reg, 
+					address_t reg_mem, address_t reg_val);
+
+	/* Execute interrupt handler and display state changes it induces */
+	int (*intsc)(device_t dev_base, address_t vector_addr, 
+					address_t sfr_addr, address_t sfr_mask, address_t num_iter);
 };
 
 struct device {
@@ -168,6 +176,10 @@
 	device_default->type->ctl(device_default, op)
 #define device_poll() \
 	device_default->type->poll(device_default)
+#define device_search(num_instr, is_reg, reg_mem, val) \
+	device_default->type->search(device_default, num_instr, is_reg, reg_mem, val)
+#define device_intsc(vector_addr, sfr_addr, sfr_mask, num_iter) \
+	device_default->type->intsc(device_default, vector_addr, sfr_addr, sfr_mask, num_iter);
 
 int device_erase(device_erase_type_t et, address_t addr);
 
diff -ruN mspdebug-0.22/drivers/sim.c mspdebug-0.22-new/drivers/sim.c
--- mspdebug-0.22/drivers/sim.c	2013-07-17 20:23:16.000000000 -0400
+++ mspdebug-0.22-new/drivers/sim.c	2014-03-05 00:51:19.176125000 -0500
@@ -16,6 +16,14 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
+/* Extended by Samuel Tan <samueltan@gmail.com> in January 2014 to include 
+ * "search" and "intsc" static analysis tools for interrupt-oriented 
+ * programming research
+ */
+
+#include <sys/queue.h>
+#include <inttypes.h>
+#include <math.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
@@ -27,10 +35,13 @@
 #include "sim.h"
 #include "simio_cpu.h"
 #include "ctrlc.h"
+#include "output_util.h"
 
-#define MEM_SIZE	65536
+#define MEM_SIZE		65536
 #define MEM_IO_END      0x200
 
+// ===================================
+
 struct sim_device {
 	struct device           base;
 
@@ -43,6 +54,149 @@
 	int			watchpoint_hit;
 };
 
+// ===================================
+// Interrupt search data structures,
+// prototpyes and defines
+// ===================================
+
+static int sim_search(device_t dev_base, address_t n, 
+						int is_reg, address_t reg_mem, address_t reg_val);
+
+/* Special Function Registers (SFRs) */
+#define IE1_ADDR	0x0000 	/* Interrupt enable 1 register */
+#define WDTCTL_ADDR	0x0120	/* Watchdog timer + control register */
+#define IFG1_ADDR	0x0002	/* Interrupt Flag register 1 */
+#define FCTL3_ADDR	0x012c	/* Flash memory control register 3 */
+
+/* Interrupt enable bit/flag masks */
+#define OFIE_MASK		((uint8_t)1 << 1)
+#define	ACCVIE_MASK		((uint8_t)1 << 5)
+#define NMIIE_MASK		((uint8_t)1 << 4)
+#define WDTNMI_MASK		((uint8_t)1 << 5)  /* Selects function of RST/NMI pin */
+#define GIE_MASK		((uint16_t)1 << 3)
+#define NMIIFG_MASK		((uint8_t)1 << 4)
+#define OFIFG_MASK		((uint8_t)1 << 1)
+#define ACCVIFG_MASK	((uint8_t)1 << 2)
+
+/* Interrupt types */
+typedef enum { // TODO: Map these to actual reset vector entries
+	INTERRUPT_NONE,
+	INTERRUPT_RST, 		/* RST */
+	INTERRUPT_NMI,		/* NMI */
+	INTERRUPT_ACCV,		/* Flash Access Violation */
+	INTERRUPT_OF,		/* Oscilalator Fault */
+	INTERRUPT_MASK,		/* All maskable interrupts */
+	INTERRUPT_TOTAL_NUM
+} interrupt_t;
+
+#define NO_INSTR 0
+#define NO_IRQ -1
+#define HI_MASK_INTERRUPT_IRQ 29 	/* Highest byte offset of maskable 
+									   interrupts in interrupt vector */
+
+/* Node in the search tree */
+typedef struct search_node {
+	interrupt_t type;
+	uint16_t instr_addr; /* used only if this is not an interrupt */
+	int irq;
+	int depth;
+	struct search_node *parent;
+	struct search_node *l_child;
+	struct search_node *sibling;
+	struct sim_device *saved_state;
+} search_node;
+
+search_node *create_node(interrupt_t type, uint16_t instr_addr, int irq, 
+							int depth)
+{
+	search_node *node = malloc(sizeof(search_node));
+	memset(node, '\0', sizeof(search_node));
+	node->type = type;
+	node->instr_addr = instr_addr;
+	node->irq = irq;
+	node->depth = depth;
+	node->saved_state = malloc(sizeof(struct sim_device));
+	memset(node->saved_state, '\0', sizeof(struct sim_device));
+	return node;
+}
+
+void add_child(search_node *parent_node, search_node *new_node)
+{
+	if ( (parent_node == NULL) || (new_node == NULL) )
+		return;
+	new_node->parent = parent_node;
+	search_node *curr_node;
+	
+	// No children
+	if (parent_node->l_child == NULL) {
+		parent_node->l_child = new_node;
+	} else {
+		curr_node = parent_node->l_child;
+		while (curr_node->sibling != NULL)
+			curr_node = curr_node->sibling;
+		curr_node->sibling = new_node;
+	}
+}
+
+void delete_subtree(search_node *node)
+{
+	search_node *curr = node->l_child;
+	search_node *temp;
+	while (curr)
+	{
+		temp = curr;
+		curr = curr->sibling;
+		delete_subtree(temp);
+	}
+	free(node->saved_state);
+	free(node);
+}
+
+void delete_prev_sib_subtree(search_node *node)
+{
+	// Root has no siblings
+	if (!node->parent) {
+		printc_err("#DEBUG delete_prev_sib_subtree: root has no siblings\n");
+		return;
+	}
+	// Node has no previous siblings
+	else if (node->parent->l_child == node) {
+		return;
+	}
+
+	// Find previous sibling
+	search_node *curr = node->parent->l_child;
+	while(curr->sibling != node) {
+		curr = curr->sibling;
+	}
+
+	delete_subtree(curr);
+}
+
+/* Stack used for depth-first traversal */
+SLIST_HEAD(tailhead, entry) head;
+
+struct entry {
+  search_node *node;
+  SLIST_ENTRY(entry) entries;
+};
+
+void push( struct search_node *node ) {
+	struct entry *e = malloc(sizeof(struct entry));
+	memset(e, '\0', sizeof(struct entry));
+	e->node = node;
+	SLIST_INSERT_HEAD(&head, e, entries);
+}
+
+struct search_node *pop () {
+	struct search_node *ret = SLIST_FIRST(&head)->node;
+	struct entry *e = SLIST_FIRST(&head);
+	SLIST_REMOVE_HEAD(&head, entries);
+	free(e);
+	return ret;
+}
+
+
 #define MEM_GETB(dev, offset) ((dev)->memory[offset])
 #define MEM_SETB(dev, offset, value) ((dev)->memory[offset] = (value))
 #define MEM_GETW(dev, offset)					\
@@ -440,7 +594,9 @@
 	default:
 		printc_err("sim: unknown single-operand opcode: 0x%04x "
 			"(PC = 0x%04x)\n", opcode, dev->current_insn);
-		return -1;
+		// return -1;
+		return 1; // NOP the unrecognized instruction
+		/* TODO: support MSP430X instructions */
 	}
 
 	if (opcode != MSP430_OP_PUSH && opcode != MSP430_OP_CALL &&
@@ -502,11 +658,68 @@
 	return 2;
 }
 
+/* Added by Samuel Tan */
+/* Find the address of the next instruction that will
+ * result from a jump
+ */
+uint16_t instr_after_jmp(struct sim_device *dev, uint16_t ins)
+{
+	uint16_t opcode = ins & 0xfc00;
+	uint16_t pc_offset = (ins & 0x03ff) << 1;
+	uint16_t curr_pc = dev->regs[MSP430_REG_PC];
+	uint16_t sr = dev->regs[MSP430_REG_SR];
+
+	if (pc_offset & 0x0400)
+		pc_offset |= 0xff800;
+
+	switch (opcode) {
+	case MSP430_OP_JNZ:
+		sr = !(sr & MSP430_SR_Z);
+		break;
+
+	case MSP430_OP_JZ:
+		sr &= MSP430_SR_Z;
+		break;
+
+	case MSP430_OP_JNC:
+		sr = !(sr & MSP430_SR_C);
+		break;
+
+	case MSP430_OP_JC:
+		sr &= MSP430_SR_C;
+		break;
+
+	case MSP430_OP_JN:
+		sr &= MSP430_SR_N;
+		break;
+
+	case MSP430_OP_JGE:
+		sr = ((sr & MSP430_SR_N) ? 1 : 0) ==
+			((sr & MSP430_SR_V) ? 1 : 0);
+		break;
+
+	case MSP430_OP_JL:
+		sr = ((sr & MSP430_SR_N) ? 1 : 0) !=
+			((sr & MSP430_SR_V) ? 1 : 0);
+		break;
+
+	case MSP430_OP_JMP:
+		sr = 1;
+		break;
+	}
+
+	if (sr)
+		curr_pc += pc_offset;
+
+	return curr_pc;
+}
+
 /* Fetch and execute one instruction. Return the number of CPU cycles
  * it would have taken, or -1 if an error occurs.
  */
 static int step_cpu(struct sim_device *dev)
 {
+	// printc("step_cpu: Address before: %" PRIu16 "\n", dev->regs[MSP430_REG_PC]);
 	uint16_t ins;
 	int ret;
 
@@ -527,6 +740,7 @@
 	if (ret < 0)
 		dev->regs[MSP430_REG_PC] = dev->current_insn;
 
+	// printc("step_cpu: Address after: %" PRIu16 "\n", dev->regs[MSP430_REG_PC]);
 	return ret;
 }
 
@@ -574,7 +788,6 @@
 		if (count < 0)
 			return -1;
 	}
-
 	simio_step(status, count);
 	return 0;
 }
@@ -677,6 +890,7 @@
 	return 0;
 }
 
+/* Function that processes user input in debugger */
 static int sim_ctl(device_t dev_base, device_ctl_t op)
 {
 	struct sim_device *dev = (struct sim_device *)dev_base;
@@ -794,6 +1008,546 @@
 	return (device_t)dev;
 }
 
+/*
+ * Triggers an interrupt addressed by irq
+ *
+ * Arguments
+ * 	irq:	word offset into interrupt vector table, which
+ *			begins at 0xFFC0
+ */
+void trigger_interrupt(struct sim_device *dev, int irq)
+{
+	// Push PC
+	dev->regs[MSP430_REG_SP] -= 2;
+	MEM_SETW(dev, dev->regs[MSP430_REG_SP],
+		 dev->regs[MSP430_REG_PC]);
+
+	// Push SR
+	dev->regs[MSP430_REG_SP] -= 2;
+	MEM_SETW(dev, dev->regs[MSP430_REG_SP],
+		 dev->regs[MSP430_REG_SR]);
+
+	// Disable interrupts and turn off CPU
+	dev->regs[MSP430_REG_SR] &=
+		~(MSP430_SR_GIE | MSP430_SR_CPUOFF);
+
+	// Go to interrupt handler
+	dev->regs[MSP430_REG_PC] = MEM_GETW(dev, 0xffc0 + irq * 2);
+
+	simio_ack_interrupt(irq);
+}
+
+/*
+ * Triggers an interrupt addressed by irq and sets
+ * appropriate interrupt flags associated with that interrupt
+ *
+ * Arguments
+ * 	irq:	word offset into interrupt vector table, which
+ *			begins at 0xFFC0
+ *	type:	interrupt type, which determines the flags to be set
+ */
+void trigger_interrupt_set_flags(struct sim_device *dev, int irq, interrupt_t type)
+{
+	uint8_t ifg1;
+	uint16_t fctl3;
+
+	// Read SFRs for interrupt flags
+	ifg1 = MEM_GETB(dev, IFG1_ADDR);
+	fctl3 = MEM_GETW(dev, FCTL3_ADDR);
+	
+	// Set interrupt flag(s)
+	switch (type) 
+	{
+		case INTERRUPT_RST:
+		{
+			// TODO: Implement setting of reset flags
+			break;
+		}	
+		case INTERRUPT_NMI:
+		{
+			ifg1 |= NMIIFG_MASK;
+			MEM_SETB(dev, IFG1_ADDR, ifg1);
+			break;
+		}
+		case INTERRUPT_ACCV:
+		{
+			fctl3 |= ACCVIFG_MASK;
+			MEM_SETW(dev, FCTL3_ADDR, fctl3);
+			break;
+		}	
+		case INTERRUPT_OF:
+		{
+			ifg1 |= OFIFG_MASK;
+			MEM_SETB(dev, IFG1_ADDR, ifg1);
+			break;
+		}	
+		case INTERRUPT_MASK:
+		{
+			// TODO: implement device specific maskable interrupt flags
+			// switch(irq) {}
+			break;
+		}
+		case INTERRUPT_NONE:
+		default:
+			printc_err("Error: trying to trigger invalid interrupt type\n");
+			return;
+			break;
+	}
+
+	trigger_interrupt(dev, irq);
+}
+
+/*
+ * Returns address of next instruction
+ *
+ * Arguments
+ * 	dev:	the simulation device to get the next instruction of	
+ */
+address_t get_next_instr(struct sim_device *dev)
+{
+	uint8_t code[16];
+	int len = sizeof(code);
+	address_t next_instr;
+	uint16_t ins = MEM_GETW(dev, dev->current_insn);
+
+	/* Conditional branch */
+	if ( 	(((ins & 0xf000) < 0x4000) && ((ins & 0xf000) >= 0x2000)) &&
+		 	(instr_after_jmp(dev, ins) != dev->regs[MSP430_REG_PC]) ) 
+	{
+		next_instr = instr_after_jmp(dev, ins) + 2; 
+	}
+	/* Non conditional instruction */
+	else
+	{
+		/* Find next instruction address */
+		if (len > 0x10000 - dev->regs[MSP430_REG_PC])
+			len = 0x10000 - dev->regs[MSP430_REG_PC];
+		if (device_readmem(dev->regs[MSP430_REG_PC], code, len) < 0)
+			return 0;
+
+		next_instr = next_instr_addr(dev->regs[MSP430_REG_PC], code, len);	
+	}
+
+	return next_instr;
+}
+
+/*
+ * Given a node in the CPU state space search tree (described in sim_search),
+ * creates a child node that represents the next instruction or interrupt
+ * to be executed. 
+ *
+ * Arguments
+ * 	dev:	the simulation device 
+ *	parent:	the node to add the child to
+ *	type:	type of the interrupt that the child will represent
+ */
+void create_child_node(struct sim_device *dev, search_node *parent, 
+								interrupt_t type)
+{
+	int i;
+	uint8_t ie1[1];
+	uint8_t wdtctl[2];
+	int ie1_len = sizeof(ie1);
+	int wdtctl_len = sizeof(wdtctl);
+	search_node *new_node;
+
+	// Read SFRs for interrupt flags
+	if (device_readmem(IE1_ADDR, ie1, ie1_len) < 0)
+			printc("Error: cannot read IE1");
+	if (device_readmem(WDTCTL_ADDR, wdtctl, wdtctl_len) < 0)
+			printc("Error: cannot read WDTCTL");
+
+	switch (type)
+	{
+		case INTERRUPT_NONE:
+		{
+			new_node = create_node(type, dev->regs[MSP430_REG_PC], 
+				NO_IRQ, parent->depth + 1);
+			add_child(parent, new_node);
+			push(new_node);	
+			break;
+		}
+		case INTERRUPT_RST:
+		{
+			if ( !(wdtctl[0] & WDTNMI_MASK ) )
+			{
+				new_node = create_node(type, NO_INSTR, 31, parent->depth + 1);
+				add_child(parent, new_node);
+				push(new_node);
+			}
+			break;
+		}
+		case INTERRUPT_NMI:
+		{
+			// NMI Interrupt
+			if ( (ie1[0] & NMIIE_MASK) && (wdtctl[0] & WDTNMI_MASK ) )
+			{
+				new_node = create_node(type, NO_INSTR, 30, parent->depth + 1);
+				add_child(parent, new_node);
+				push(new_node);
+			}
+			break;
+		}
+		case INTERRUPT_ACCV:
+		{
+			if ( (ie1[0] & ACCVIE_MASK) )
+			{
+				new_node = create_node(type, NO_INSTR, 30, parent->depth + 1);
+				add_child(parent, new_node);
+				push(new_node);
+			}
+			break;
+		}
+		case INTERRUPT_OF:
+		{
+			if ( (ie1[0] & OFIE_MASK) )
+			{
+				new_node = create_node(type, NO_INSTR, 30, parent->depth + 1);
+				add_child(parent, new_node);
+				push(new_node);
+			}
+			break;
+		}
+		case INTERRUPT_MASK:
+		{
+			/* TODO: check individual interrupt enable bits */
+			if ((dev->regs[MSP430_REG_SR] & GIE_MASK))
+			{
+				for (i = 0; i <= HI_MASK_INTERRUPT_IRQ; ++i)
+				{
+					new_node = create_node(type, NO_INSTR, i, 
+						parent->depth + 1);
+					add_child(parent, new_node);
+					push(new_node);
+				}
+			}
+			break;
+		}
+		default:
+			printc_err("error: invalid interrupt!\n");
+			break;
+	}
+}
+
+
+/*
+ * Given a register value pair (R, V), performs a search of the space of
+ * possible CPU states, executing all possible sequences of timed interrupts
+ * up to n steps into the program (where n is provided by the user). For each 
+ * of these CPU states the simulator reaches, if register R contains the value 
+ * V, the function terminates and reports that this CPU state is reachable. 
+ * Otherwise, the search continues until all possible interleavings of up to n 
+ * steps into the program are searched, and reports that such a state cannot be 
+ * found.
+ * 
+ * Tree representation of program/interrupt execution
+ * ---------------------------------------------------
+ * The possible execution paths of the program are modeled as a tree, where
+ * each node represents either the execution of an entire interrupt handler
+ * from start to end (i.e. atomically), or the execution of an instruction
+ * outside of an interrupt handler routine. The root of this tree will represent
+ * the first instruction in the reset handler. Each node has (k+1) children, 
+ * where k is the number of interrupts that can be triggered given the CPU state 
+ * reached by the path from the root to the current node, and the additional 1
+ * is for executing the next non-interrupt handler instruction in sequence (i.e.
+ * not triggering an interrupt at the current instruction). A depth-first search
+ * is performed on this tree (with the corresponding instructions executed in
+ * the simulated MSP430 device) up till depth n (where n is provided by the
+ * user).
+ *
+ * (Note: in the actual implementation, in order to allow an interrupt to be 
+ * executed before the first instruction, the root is a dummy which has a child
+ * representing the first instruction, and other children representing 
+ * interrupts that can be triggered before the first instruction is executed).
+ *
+ * Assumptions
+ * ------------
+ * This search of the state of possible CPU states assumes the following:
+ * 	1) Up to one interrupt can be executed between any two instructions
+ * 	2) Interrupt handlers are executed atomically and cannot be nested
+ *
+ * Limitations
+ * ------------
+ * Memory usage and execution time grow at even moderate sizes of n (~30)
+ * due to the exponential growth of the tree. In its current form, cannot
+ * practically be used to analyze full MSP430 programs/firmware.
+ *
+ * Future improvements
+ * --------------------
+ * These features should be implemented to further improve this CPU state space
+ * search function:
+ *	- Heuristic function to prune subtrees during search and thus increase speed
+ *	- Support for executing multiple interrupts between two instructions
+ *	- Support for nesting interrupts
+ *	- Compacting of search_nodes to reduce memory usage
+ *
+ * Arguments
+ * 	dev:		 the simulation device
+ *	n:			 max depth of tree to search till
+ *	is_reg:		 flag indicating if param reg_mem is a register
+ * 	reg_mem:	 address of register or memory (i.e. "R" in above description)
+ *	reg_mem_val: desired value in reg_mem (i.e. "V" in above description)
+ */
+static int sim_search(device_t dev_base, address_t n, 
+						int is_reg, address_t reg_mem, address_t reg_mem_val)
+{
+	struct sim_device *dev = (struct sim_device *)dev_base;
+	int i;
+	int depth_of_last_node;
+	int max_depth = n;
+	search_node *curr_node;
+	search_node *new_node;
+	search_node *root;
+	struct msp430_instruction insn;
+	uint8_t code[16];
+	uint8_t memval[2];
+	uint16_t memval_uint16;
+	int code_len = sizeof(code);
+	int memval_len = sizeof(memval);
+	int score = 10;	/* TODO: replace this hardcoded value with heuristic */
+	int threshold = 1; /* TODO: replace this with an appropriate threshold */
+
+	/* Perform reset before searching so we start at first instruction
+	   in the reset handler */	
+	do_reset(dev);
+
+	SLIST_INIT(&head);
+
+	/* Create dummy root */
+	root = create_node(INTERRUPT_NONE, NO_INSTR, NO_IRQ, 0);
+	push(root);
+	memcpy(root->saved_state, dev, sizeof(struct sim_device));
+	
+	/* Populate it with children */
+	for (i = 0; i < INTERRUPT_TOTAL_NUM; ++i) {
+		create_child_node(dev, root, i);
+	}
+	depth_of_last_node = 0;
+	curr_node = root;
+
+	while (!SLIST_EMPTY(&head) && (curr_node != NULL))
+	{
+		curr_node = pop();
+
+		// Delete subtrees traversed by DFS after they have
+		// been visited
+		if (curr_node->depth < depth_of_last_node)
+			delete_prev_sib_subtree(curr_node);
+
+		depth_of_last_node = curr_node->depth;
+		
+		// Ignore dummy root node
+		if ((curr_node->type == INTERRUPT_NONE) && 
+			(curr_node->instr_addr == NO_INSTR)) {
+			continue;
+		}
+
+		/* Load parent's state before executing this node */
+		memcpy(dev, curr_node->parent->saved_state, sizeof(struct sim_device));
+
+		/* Execute instruction */
+		if ( curr_node->type == INTERRUPT_NONE ) {
+			step_system(dev);
+		}
+		/* Execute interrupt */
+		else
+		{
+			trigger_interrupt_set_flags(dev, curr_node->irq, curr_node->type);
+			memset(&insn, '\0', sizeof(struct msp430_instruction));
+
+			// RST handler is skipped since it never returns
+			if ( curr_node->type != INTERRUPT_RST )
+			{
+				while ( !( ( insn.op == MSP430_OP_RETI ) 
+					|| ( dev->regs[MSP430_REG_PC] == 0xffff ) ) )  
+				{
+					if (code_len > 0x10000 - dev->regs[MSP430_REG_PC])
+						code_len = 0x10000 - dev->regs[MSP430_REG_PC];
+					if (device_readmem(dev->regs[MSP430_REG_PC], 
+							code, code_len) < 0)
+						printc("Error: cannot read instruction");
+					if (dis_decode(code, dev->regs[MSP430_REG_PC], 
+							code_len, &insn) < 0)
+						printc("Error: cannot decode instruction");
+					step_system(dev);
+				}	
+			}
+		}
+
+		/* Save device state after execution of the instruction/interrupt
+		   handler represented by curr_node */
+		memcpy(curr_node->saved_state, dev, sizeof(struct sim_device));
+
+
+		/* Check for matching state */
+		if (is_reg)
+		{
+			if (dev->regs[reg_mem] == reg_mem_val) 
+			{
+				printc("Found a match!\n");
+				/* TODO: return a representation of path from root 
+					to this node */
+				return 0;
+			}
+		}
+		else
+		{
+			if (device_readmem(reg_mem, memval, memval_len) < 0)
+				printc("Error: cannot read %04x\n", reg_mem);
+			printc( "%02x %02x\n", memval[0], memval[1]);
+			memcpy(&memval_uint16, memval, 2);
+			if ( memval_uint16 == reg_mem_val )
+			{
+				printc("Found a match!\n");
+				return 0;
+			}
+		}
+		
+		/* TODO: Implement heuristic function and execute score = heuristic() */
+
+		/* Stop exploring subtree if we hit the max depth or heuristic tells us 
+		   to prune this subtree */
+		if ( (score < threshold) || (curr_node->depth >= max_depth) || 
+			(dev->regs[MSP430_REG_PC] == 0xffff) ) 
+		{
+			/* NOP */
+		}
+		/* Continue exploring this branch */
+		else
+		{
+			// If an interrupt was just executed, only add the next 
+			// non-interrupt handler instruction, since we assume only
+			// up to one interrupt can be executed between two non-interrupt
+			// handler instructions 
+			if ( curr_node->type != INTERRUPT_NONE )
+			{
+				new_node = create_node(INTERRUPT_NONE, 
+					dev->regs[MSP430_REG_PC], NO_IRQ, curr_node->depth + 1);
+				add_child(curr_node, new_node);
+				push(new_node);
+			}
+			// Otherwise, a single instruction was executed, so add all possible
+			// interrupts
+			else
+			{
+				for (i = 0; i < INTERRUPT_TOTAL_NUM; ++i) {
+					create_child_node(dev, curr_node, i);
+				}
+			}
+		}
+	}
+
+	delete_subtree(root);
+	printc("search: Did not find a match!\n");
+	return 0;
+}
+
+/*
+ * Executes the interrupt handler pointed to by vector_addr and
+ * displays the CPU state changes induced by the interrupt handler.
+ * The bits set in sfr_mask will first be set in the peripheral register
+ * at address sfr_addr in order to allow the user to specify which interrupt
+ * handler routine to trigger when the handler at vector_addr is shared
+ * by multiple interrupt sources. Optionally, the interrupt can be executed
+ * a user defined number of times (num_iter) before printing the final state
+ * changes induced.
+ *
+ * Arguments
+ * 	dev:			the device to operate on 
+ *	vector_addr:	address of interrupt vector table entry of interrupt handler
+ *	sfr_addr:		address of peripheral register to set
+ * 	sfr_mask:		mask that specifies bits in peripheral register to set
+ *	num_iter:		number of times the interrupt will be executed before
+ *					comparing state changes and printing them to screen
+ */
+static int sim_intsc(device_t dev_base, address_t vector_addr,
+						address_t sfr_addr, address_t sfr_mask, address_t num_iter)
+{
+	struct sim_device *dev = (struct sim_device *)dev_base;
+	struct sim_device *saved_state = malloc(sizeof(struct sim_device));
+	int i;
+	int irq;
+	uint16_t sfr_val;
+	uint8_t code[16];
+	int code_len = sizeof(code);
+	struct msp430_instruction insn;
+	memset(&insn, 0, sizeof(struct msp430_instruction));
+
+	if ( (vector_addr > 0xfffe) || (vector_addr < 0xffc0) ) {
+		printc_err("Error: invalid interrupt vector address 0x%04x\n", 
+			vector_addr);
+		return 0;
+	}
+	else if ( (vector_addr & 0x1 ) != 0 ) {
+		printc_err("Error: interrupt vector address 0x%04x must be "
+			"16-bit aligned\n", vector_addr);
+		return 0;	
+	}
+	else if ( vector_addr == 0xfffe ) {
+		printc_err("Error: Reset handler at 0x%04x never returns, so cannot " 
+			"check state change\n", vector_addr);
+		return 0;	
+	}
+
+	/* Set bits in specified special function register */
+	sfr_val = MEM_GETW(dev, sfr_addr);
+	sfr_val |= sfr_mask;
+	MEM_SETW(dev, sfr_addr, sfr_val);
+
+	/* Save state before executing interrupt */
+	memcpy(saved_state, dev, sizeof(struct sim_device));
+
+	/* Execute the interrupt */
+	for ( i = 0; i < num_iter; ++i )
+	{
+		irq = 31 - ( (0xfffe - vector_addr) / 2 );
+		trigger_interrupt(dev, irq);
+		address_t last_addr = dev->regs[MSP430_REG_PC];
+		while ( insn.op != MSP430_OP_RETI )  
+		{
+			if ( dev->regs[MSP430_REG_PC] == 0xffff ) {
+				printc_err("Error: Interrupt handler loads 0xFFFF into PC "
+					"at 0x%04x\n", last_addr);
+				return 0;
+			}
+			if (code_len > 0x10000 - dev->regs[MSP430_REG_PC])
+				code_len = 0x10000 - dev->regs[MSP430_REG_PC];
+			if (device_readmem(dev->regs[MSP430_REG_PC], code, code_len) < 0)
+				printc("Error: cannot read instruction");
+			if (dis_decode(code, dev->regs[MSP430_REG_PC], code_len, &insn) < 0)
+				printc("Error: cannot decode instruction");
+			last_addr = dev->regs[MSP430_REG_PC];
+			step_system(dev);
+		}	
+	}
+
+	/* Print state changes */
+	printc("Register state changes\n");
+	printc("===========================\n");
+	for ( i = 0; i < DEVICE_NUM_REGS; ++i )
+	{
+		if ( dev->regs[i] != saved_state->regs[i] ) {
+			printc("%s:\t0x%04x ==> 0x%04x (changed by 0x%04x)\n", 
+				dis_reg_name(i), saved_state->regs[i], dev->regs[i], 
+					(saved_state->regs[i] - dev->regs[i]) );	
+		}
+	}
+	printc("\n");
+	printc("Memory state changes\n");
+	printc("===========================\n");
+	for ( i = 0; i < MEM_SIZE; ++i )
+	{
+		if ( dev->memory[i] != saved_state->memory[i] ) {
+			printc("[0x%04x]:\t0x%02x ==> 0x%02x (changed by 0x%02x)\n", 
+				i, saved_state->memory[i], dev->memory[i], 
+					(saved_state->memory[i] - dev->memory[i]) );	
+		}
+	}
+	
+	free(saved_state);
+	return 0;
+}
+
 const struct device_class device_sim = {
 	.name		= "sim",
 	.help		= "Simulation mode.",
@@ -805,5 +1559,7 @@
 	.getregs	= sim_getregs,
 	.setregs	= sim_setregs,
 	.ctl		= sim_ctl,
-	.poll		= sim_poll
-};
+	.poll		= sim_poll,
+	.search 	= sim_search,
+	.intsc 		= sim_intsc
+};
\ No newline at end of file
diff -ruN mspdebug-0.22/drivers/.tags mspdebug-0.22-new/drivers/.tags
--- mspdebug-0.22/drivers/.tags	1969-12-31 19:00:00.000000000 -0500
+++ mspdebug-0.22-new/drivers/.tags	2014-03-04 01:54:08.757212000 -0500
@@ -0,0 +1,1232 @@
+!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
+!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
+!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
+!_TAG_PROGRAM_NAME	Exuberant Ctags	//
+!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
+!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
+ACCVIE_MASK	sim.c	72;"	d	file:
+ACCVIFG_MASK	sim.c	78;"	d	file:
+ACK	jtdev.c	50;"	d	file:
+APP_DEBUG	goodfet.c	30;"	d	file:
+APP_JTAG430	goodfet.c	29;"	d	file:
+ARITH_BITS	sim.c	349;"	d	file:
+AUTOFEED	jtdev.c	55;"	d	file:
+BL_DATA_BLOCK_PROGRAMMED	tilib_defs.h	/^	BL_DATA_BLOCK_PROGRAMMED = 4,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_ERASE_FIRMWARE	tilib_defs.h	/^	BL_ERASE_FIRMWARE = 2,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_ERASE_INT_VECTORS	tilib_defs.h	/^	BL_ERASE_INT_VECTORS = 1,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_EXIT	tilib_defs.h	/^	BL_EXIT = 5,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_INIT	tilib_defs.h	/^	BL_INIT = 0,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_PROGRAM_FIRMWARE	tilib_defs.h	/^	BL_PROGRAM_FIRMWARE = 3,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_UPDATE_DONE	tilib_defs.h	/^	BL_UPDATE_DONE = 6,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_UPDATE_ERROR	tilib_defs.h	/^	BL_UPDATE_ERROR = 7,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_WAIT_FOR_TIMEOUT	tilib_defs.h	/^	BL_WAIT_FOR_TIMEOUT = 8$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BP_BRK	tilib_defs.h	/^	BP_BRK = 1,$/;"	e	enum:BpAction
+BP_BRK_STO	tilib_defs.h	/^	BP_BRK_STO = 3$/;"	e	enum:BpAction
+BP_CLEAR	tilib_defs.h	/^	BP_CLEAR = 0,$/;"	e	enum:BpMode
+BP_CODE	tilib_defs.h	/^	BP_CODE = 1,$/;"	e	enum:BpMode
+BP_COMPLEX	tilib_defs.h	/^	BP_COMPLEX = 3$/;"	e	enum:BpMode
+BP_COND	tilib_defs.h	/^	BP_COND = 1$/;"	e	enum:BpCondition
+BP_DMA	tilib_defs.h	/^	BP_DMA = 9,$/;"	e	enum:BpAccess
+BP_DONT_CARE	tilib_defs.h	/^	BP_DONT_CARE = 3,$/;"	e	enum:BpAccess
+BP_EQUAL	tilib_defs.h	/^	BP_EQUAL = 0,$/;"	e	enum:BpOperat
+BP_FETCH	tilib_defs.h	/^	BP_FETCH = 0,$/;"	e	enum:BpAccess
+BP_FETCH_HOLD	tilib_defs.h	/^	BP_FETCH_HOLD = 1,$/;"	e	enum:BpAccess
+BP_GREATER	tilib_defs.h	/^	BP_GREATER = 1,$/;"	e	enum:BpOperat
+BP_INSIDE	tilib_defs.h	/^	BP_INSIDE = 0,$/;"	e	enum:BpRangeAction
+BP_LOWER	tilib_defs.h	/^	BP_LOWER = 2,$/;"	e	enum:BpOperat
+BP_MAB	tilib_defs.h	/^	BP_MAB = 0,$/;"	e	enum:BpType
+BP_MDB	tilib_defs.h	/^	BP_MDB = 1,$/;"	e	enum:BpType
+BP_NONE	tilib_defs.h	/^	BP_NONE = 0,$/;"	e	enum:BpAction
+BP_NO_COND	tilib_defs.h	/^	BP_NO_COND = 0,$/;"	e	enum:BpCondition
+BP_NO_DMA	tilib_defs.h	/^	BP_NO_DMA = 10,$/;"	e	enum:BpAccess
+BP_NO_FETCH	tilib_defs.h	/^	BP_NO_FETCH = 2,$/;"	e	enum:BpAccess
+BP_NO_FETCH_NO_DMA	tilib_defs.h	/^	BP_NO_FETCH_NO_DMA = 8,$/;"	e	enum:BpAccess
+BP_NO_FETCH_READ	tilib_defs.h	/^	BP_NO_FETCH_READ = 4,$/;"	e	enum:BpAccess
+BP_NO_FETCH_READ_NO_DMA	tilib_defs.h	/^	BP_NO_FETCH_READ_NO_DMA = 12,$/;"	e	enum:BpAccess
+BP_NO_FETCH_WRITE	tilib_defs.h	/^	BP_NO_FETCH_WRITE = 5,$/;"	e	enum:BpAccess
+BP_OUTSIDE	tilib_defs.h	/^	BP_OUTSIDE = 1$/;"	e	enum:BpRangeAction
+BP_RANGE	tilib_defs.h	/^	BP_RANGE = 2,$/;"	e	enum:BpMode
+BP_READ	tilib_defs.h	/^	BP_READ = 6,$/;"	e	enum:BpAccess
+BP_READ_DMA	tilib_defs.h	/^	BP_READ_DMA = 14,$/;"	e	enum:BpAccess
+BP_READ_NO_DMA	tilib_defs.h	/^	BP_READ_NO_DMA = 13,$/;"	e	enum:BpAccess
+BP_REGISTER	tilib_defs.h	/^	BP_REGISTER = 2$/;"	e	enum:BpType
+BP_STO	tilib_defs.h	/^	BP_STO = 2,$/;"	e	enum:BpAction
+BP_UNEQUAL	tilib_defs.h	/^	BP_UNEQUAL = 3$/;"	e	enum:BpOperat
+BP_WRITE	tilib_defs.h	/^	BP_WRITE = 7,$/;"	e	enum:BpAccess
+BP_WRITE_DMA	tilib_defs.h	/^	BP_WRITE_DMA = 15$/;"	e	enum:BpAccess
+BP_WRITE_NO_DMA	tilib_defs.h	/^	BP_WRITE_NO_DMA = 11,$/;"	e	enum:BpAccess
+BREAKPOINT	tilib_defs.h	/^typedef struct BREAKPOINT {$/;"	s
+BREAKPOINT_HIT	tilib_defs.h	/^        BREAKPOINT_HIT = 3,$/;"	e	enum:STATE_MODES
+BSL_H_	bsl.h	20;"	d
+BUSY	jtdev.c	51;"	d	file:
+BYTE	tilib_defs.h	/^typedef uint8_t BYTE;$/;"	t
+BpAccess	tilib_defs.h	/^typedef enum BpAccess {$/;"	g
+BpAccess_t	tilib_defs.h	/^} BpAccess_t;$/;"	t	typeref:enum:BpAccess
+BpAction	tilib_defs.h	/^typedef enum BpAction {$/;"	g
+BpAction_t	tilib_defs.h	/^} BpAction_t;$/;"	t	typeref:enum:BpAction
+BpCondition	tilib_defs.h	/^typedef enum BpCondition {$/;"	g
+BpCondition_t	tilib_defs.h	/^} BpCondition_t;$/;"	t	typeref:enum:BpCondition
+BpMode	tilib_defs.h	/^typedef enum BpMode {$/;"	g
+BpMode_t	tilib_defs.h	/^} BpMode_t;$/;"	t	typeref:enum:BpMode
+BpOperat	tilib_defs.h	/^typedef enum BpOperat {$/;"	g
+BpOperat_t	tilib_defs.h	/^} BpOperat_t;$/;"	t	typeref:enum:BpOperat
+BpParameter_t	tilib_defs.h	/^} BpParameter_t;$/;"	t	typeref:struct:BREAKPOINT
+BpRangeAction	tilib_defs.h	/^typedef enum BpRangeAction {$/;"	g
+BpRangeAction_t	tilib_defs.h	/^} BpRangeAction_t;$/;"	t	typeref:enum:BpRangeAction
+BpType	tilib_defs.h	/^typedef enum BpType {$/;"	g
+BpType_t	tilib_defs.h	/^} BpType_t;$/;"	t	typeref:enum:BpType
+CHAR	tilib_defs.h	/^typedef char CHAR;$/;"	t
+CLK_CNTRL_MODE	tilib_defs.h	/^        CLK_CNTRL_MODE = 2,$/;"	e	enum:CONFIG_MODE
+CMD_ERASE	bsl.c	199;"	d	file:
+CMD_RESET	bsl.c	201;"	d	file:
+CMD_RX_DATA	bsl.c	200;"	d	file:
+CMD_TX_DATA	bsl.c	198;"	d	file:
+CONFIG_MODE	tilib_defs.h	/^enum CONFIG_MODE {$/;"	g
+COPY_OFFSET	obl.c	29;"	d	file:
+COPY_VALID_ADDR	obl.c	30;"	d	file:
+CRC_CHECK	flash_bsl.c	95;"	d	file:
+CRC_INIT	flash_bsl.c	46;"	d	file:
+C_BREAKPOINT	fet_core.c	78;"	d	file:
+C_CLOSE	fet_core.c	64;"	d	file:
+C_CMM_CTRL	fet_core.c	105;"	d	file:
+C_CMM_PARAM	fet_core.c	104;"	d	file:
+C_CMM_READ	fet_core.c	106;"	d	file:
+C_CONFIGURE	fet_core.c	67;"	d	file:
+C_DEVICE	fet_core.c	66;"	d	file:
+C_EEMCLOSE	fet_core.c	89;"	d	file:
+C_EEMOPEN	fet_core.c	85;"	d	file:
+C_EEMREADREGISTER	fet_core.c	86;"	d	file:
+C_EEMREADREGISTERTEST	fet_core.c	87;"	d	file:
+C_EEMWRITEREGISTER	fet_core.c	88;"	d	file:
+C_ENTERBOOTLOADER	fet_core.c	98;"	d	file:
+C_ERASE	fet_core.c	74;"	d	file:
+C_ERASECHECK	fet_core.c	84;"	d	file:
+C_ERRORNUMBER	fet_core.c	90;"	d	file:
+C_FASTFLASHER	fet_core.c	77;"	d	file:
+C_FASTVERIFYMEMORY	fet_core.c	83;"	d	file:
+C_FETRESET	fet_core.c	95;"	d	file:
+C_FETSELFTEST	fet_core.c	93;"	d	file:
+C_FETSETSIGNALS	fet_core.c	94;"	d	file:
+C_GETCURVCCT	fet_core.c	91;"	d	file:
+C_GETEXTVOLTAGE	fet_core.c	92;"	d	file:
+C_IDENT1	fet_core.c	100;"	d	file:
+C_IDENT2	fet_core.c	101;"	d	file:
+C_IDENT3	fet_core.c	102;"	d	file:
+C_IDENTIFY	fet_core.c	65;"	d	file:
+C_INITIALIZE	fet_core.c	63;"	d	file:
+C_READI2C	fet_core.c	96;"	d	file:
+C_READMEMORY	fet_core.c	75;"	d	file:
+C_READREGISTER	fet_core.c	72;"	d	file:
+C_READREGISTERS	fet_core.c	70;"	d	file:
+C_RESET	fet_core.c	69;"	d	file:
+C_RUN	fet_core.c	79;"	d	file:
+C_SECURE	fet_core.c	81;"	d	file:
+C_STATE	fet_core.c	80;"	d	file:
+C_VCC	fet_core.c	68;"	d	file:
+C_VERIFYMEMORY	fet_core.c	82;"	d	file:
+C_WRITEI2C	fet_core.c	97;"	d	file:
+C_WRITEMEMORY	fet_core.c	76;"	d	file:
+C_WRITEREGISTER	fet_core.c	73;"	d	file:
+C_WRITEREGISTERS	fet_core.c	71;"	d	file:
+DATA0	jtdev.c	37;"	d	file:
+DATA1	jtdev.c	38;"	d	file:
+DATA2	jtdev.c	39;"	d	file:
+DATA3	jtdev.c	40;"	d	file:
+DATA4	jtdev.c	41;"	d	file:
+DATA5	jtdev.c	42;"	d	file:
+DATA6	jtdev.c	43;"	d	file:
+DATA7	jtdev.c	44;"	d	file:
+DATA_ACK	bsl.c	44;"	d	file:
+DATA_HDR	bsl.c	43;"	d	file:
+DATA_NAK	bsl.c	45;"	d	file:
+DEBUG_LPM_X	tilib_defs.h	/^	DEBUG_LPM_X = 14$/;"	e	enum:CONFIG_MODE
+DEVICELIST_H_	devicelist.h	21;"	d
+DEVICE_BPTYPE_BREAK	device.h	/^	DEVICE_BPTYPE_BREAK,$/;"	e	enum:__anon6
+DEVICE_BPTYPE_READ	device.h	/^	DEVICE_BPTYPE_READ,$/;"	e	enum:__anon6
+DEVICE_BPTYPE_WATCH	device.h	/^	DEVICE_BPTYPE_WATCH,$/;"	e	enum:__anon6
+DEVICE_BPTYPE_WRITE	device.h	/^	DEVICE_BPTYPE_WRITE$/;"	e	enum:__anon6
+DEVICE_BP_DIRTY	device.h	53;"	d
+DEVICE_BP_ENABLED	device.h	52;"	d
+DEVICE_CODE	tilib_defs.h	/^	DEVICE_CODE = 12,$/;"	e	enum:CONFIG_MODE
+DEVICE_CTL_HALT	device.h	/^	DEVICE_CTL_HALT,$/;"	e	enum:__anon3
+DEVICE_CTL_RESET	device.h	/^	DEVICE_CTL_RESET,$/;"	e	enum:__anon3
+DEVICE_CTL_RUN	device.h	/^	DEVICE_CTL_RUN,$/;"	e	enum:__anon3
+DEVICE_CTL_STEP	device.h	/^	DEVICE_CTL_STEP$/;"	e	enum:__anon3
+DEVICE_ERASE_ALL	device.h	/^	DEVICE_ERASE_ALL,$/;"	e	enum:__anon5
+DEVICE_ERASE_MAIN	device.h	/^	DEVICE_ERASE_MAIN,$/;"	e	enum:__anon5
+DEVICE_ERASE_SEGMENT	device.h	/^	DEVICE_ERASE_SEGMENT$/;"	e	enum:__anon5
+DEVICE_FLAG_DO_FWUPDATE	device.h	72;"	d
+DEVICE_FLAG_FORCE_RESET	device.h	71;"	d
+DEVICE_FLAG_JTAG	device.h	68;"	d
+DEVICE_FLAG_LONG_PW	device.h	69;"	d
+DEVICE_FLAG_SKIP_CLOSE	device.h	73;"	d
+DEVICE_FLAG_TTY	device.h	70;"	d
+DEVICE_H_	device.h	20;"	d
+DEVICE_MAX_BREAKPOINTS	device.h	50;"	d
+DEVICE_NUM_REGS	device.h	49;"	d
+DEVICE_STATUS_ERROR	device.h	/^	DEVICE_STATUS_ERROR$/;"	e	enum:__anon4
+DEVICE_STATUS_HALTED	device.h	/^	DEVICE_STATUS_HALTED,$/;"	e	enum:__anon4
+DEVICE_STATUS_INTR	device.h	/^	DEVICE_STATUS_INTR,$/;"	e	enum:__anon4
+DEVICE_STATUS_RUNNING	device.h	/^	DEVICE_STATUS_RUNNING,$/;"	e	enum:__anon4
+DEVICE_T	tilib_defs.h	/^union DEVICE_T {$/;"	u
+DLL430_EVENTNOTIFY_FUNC	tilib_defs.h	/^typedef void (*DLL430_EVENTNOTIFY_FUNC)$/;"	t
+DLL430_FET_NOTIFY_FUNC	tilib_defs.h	/^typedef void (*DLL430_FET_NOTIFY_FUNC) (unsigned int MsgId,$/;"	t
+DT_CC430F5123	devicelist.h	/^	DT_CC430F5123,$/;"	e	enum:__anon1
+DT_CC430F5125	devicelist.h	/^	DT_CC430F5125,$/;"	e	enum:__anon1
+DT_CC430F5133	devicelist.h	/^	DT_CC430F5133,$/;"	e	enum:__anon1
+DT_CC430F5135	devicelist.h	/^	DT_CC430F5135,$/;"	e	enum:__anon1
+DT_CC430F5137	devicelist.h	/^	DT_CC430F5137,$/;"	e	enum:__anon1
+DT_CC430F5143	devicelist.h	/^	DT_CC430F5143,$/;"	e	enum:__anon1
+DT_CC430F5145	devicelist.h	/^	DT_CC430F5145,$/;"	e	enum:__anon1
+DT_CC430F5147	devicelist.h	/^	DT_CC430F5147,$/;"	e	enum:__anon1
+DT_CC430F6125	devicelist.h	/^	DT_CC430F6125,$/;"	e	enum:__anon1
+DT_CC430F6126	devicelist.h	/^	DT_CC430F6126,$/;"	e	enum:__anon1
+DT_CC430F6127	devicelist.h	/^	DT_CC430F6127,$/;"	e	enum:__anon1
+DT_CC430F6135	devicelist.h	/^	DT_CC430F6135,$/;"	e	enum:__anon1
+DT_CC430F6137	devicelist.h	/^	DT_CC430F6137,$/;"	e	enum:__anon1
+DT_CC430F6143	devicelist.h	/^	DT_CC430F6143,$/;"	e	enum:__anon1
+DT_CC430F6145	devicelist.h	/^	DT_CC430F6145,$/;"	e	enum:__anon1
+DT_CC430F6147	devicelist.h	/^	DT_CC430F6147,$/;"	e	enum:__anon1
+DT_END	devicelist.h	/^	DT_END$/;"	e	enum:__anon1
+DT_MSP430AFE220	devicelist.h	/^	DT_MSP430AFE220,$/;"	e	enum:__anon1
+DT_MSP430AFE221	devicelist.h	/^	DT_MSP430AFE221,$/;"	e	enum:__anon1
+DT_MSP430AFE222	devicelist.h	/^	DT_MSP430AFE222,$/;"	e	enum:__anon1
+DT_MSP430AFE223	devicelist.h	/^	DT_MSP430AFE223,$/;"	e	enum:__anon1
+DT_MSP430AFE230	devicelist.h	/^	DT_MSP430AFE230,$/;"	e	enum:__anon1
+DT_MSP430AFE231	devicelist.h	/^	DT_MSP430AFE231,$/;"	e	enum:__anon1
+DT_MSP430AFE232	devicelist.h	/^	DT_MSP430AFE232,$/;"	e	enum:__anon1
+DT_MSP430AFE233	devicelist.h	/^	DT_MSP430AFE233,$/;"	e	enum:__anon1
+DT_MSP430AFE250	devicelist.h	/^	DT_MSP430AFE250,$/;"	e	enum:__anon1
+DT_MSP430AFE251	devicelist.h	/^	DT_MSP430AFE251,$/;"	e	enum:__anon1
+DT_MSP430AFE252	devicelist.h	/^	DT_MSP430AFE252,$/;"	e	enum:__anon1
+DT_MSP430AFE253	devicelist.h	/^	DT_MSP430AFE253,$/;"	e	enum:__anon1
+DT_MSP430F11x1	devicelist.h	/^	DT_MSP430F11x1,$/;"	e	enum:__anon1
+DT_MSP430F11x1A	devicelist.h	/^	DT_MSP430F11x1A,$/;"	e	enum:__anon1
+DT_MSP430F11x1D	devicelist.h	/^	DT_MSP430F11x1D,$/;"	e	enum:__anon1
+DT_MSP430F11x2	devicelist.h	/^	DT_MSP430F11x2,$/;"	e	enum:__anon1
+DT_MSP430F12x	devicelist.h	/^	DT_MSP430F12x,$/;"	e	enum:__anon1
+DT_MSP430F12x2	devicelist.h	/^	DT_MSP430F12x2,$/;"	e	enum:__anon1
+DT_MSP430F12x2C	devicelist.h	/^	DT_MSP430F12x2C,$/;"	e	enum:__anon1
+DT_MSP430F12x2New	devicelist.h	/^	DT_MSP430F12x2New,$/;"	e	enum:__anon1
+DT_MSP430F133	devicelist.h	/^	DT_MSP430F133,$/;"	e	enum:__anon1
+DT_MSP430F135	devicelist.h	/^	DT_MSP430F135,$/;"	e	enum:__anon1
+DT_MSP430F147	devicelist.h	/^	DT_MSP430F147,$/;"	e	enum:__anon1
+DT_MSP430F148	devicelist.h	/^	DT_MSP430F148,$/;"	e	enum:__anon1
+DT_MSP430F149	devicelist.h	/^	DT_MSP430F149,$/;"	e	enum:__anon1
+DT_MSP430F155	devicelist.h	/^	DT_MSP430F155,$/;"	e	enum:__anon1
+DT_MSP430F156	devicelist.h	/^	DT_MSP430F156,$/;"	e	enum:__anon1
+DT_MSP430F157	devicelist.h	/^	DT_MSP430F157,$/;"	e	enum:__anon1
+DT_MSP430F1610	devicelist.h	/^	DT_MSP430F1610,$/;"	e	enum:__anon1
+DT_MSP430F1611	devicelist.h	/^	DT_MSP430F1611,$/;"	e	enum:__anon1
+DT_MSP430F1612	devicelist.h	/^	DT_MSP430F1612,$/;"	e	enum:__anon1
+DT_MSP430F167	devicelist.h	/^	DT_MSP430F167,$/;"	e	enum:__anon1
+DT_MSP430F168	devicelist.h	/^	DT_MSP430F168,$/;"	e	enum:__anon1
+DT_MSP430F169	devicelist.h	/^	DT_MSP430F169,$/;"	e	enum:__anon1
+DT_MSP430F20x1	devicelist.h	/^	DT_MSP430F20x1,$/;"	e	enum:__anon1
+DT_MSP430F20x2	devicelist.h	/^	DT_MSP430F20x2,$/;"	e	enum:__anon1
+DT_MSP430F20x3	devicelist.h	/^	DT_MSP430F20x3,$/;"	e	enum:__anon1
+DT_MSP430F2112	devicelist.h	/^	DT_MSP430F2112,$/;"	e	enum:__anon1
+DT_MSP430F2122	devicelist.h	/^	DT_MSP430F2122,$/;"	e	enum:__anon1
+DT_MSP430F2132	devicelist.h	/^	DT_MSP430F2132,$/;"	e	enum:__anon1
+DT_MSP430F21x1	devicelist.h	/^	DT_MSP430F21x1,$/;"	e	enum:__anon1
+DT_MSP430F2232	devicelist.h	/^	DT_MSP430F2232,$/;"	e	enum:__anon1
+DT_MSP430F2234	devicelist.h	/^	DT_MSP430F2234,$/;"	e	enum:__anon1
+DT_MSP430F2252	devicelist.h	/^	DT_MSP430F2252,$/;"	e	enum:__anon1
+DT_MSP430F2254	devicelist.h	/^	DT_MSP430F2254,$/;"	e	enum:__anon1
+DT_MSP430F2272	devicelist.h	/^	DT_MSP430F2272,$/;"	e	enum:__anon1
+DT_MSP430F2274	devicelist.h	/^	DT_MSP430F2274,$/;"	e	enum:__anon1
+DT_MSP430F233	devicelist.h	/^	DT_MSP430F233,$/;"	e	enum:__anon1
+DT_MSP430F2330	devicelist.h	/^	DT_MSP430F2330,$/;"	e	enum:__anon1
+DT_MSP430F235	devicelist.h	/^	DT_MSP430F235,$/;"	e	enum:__anon1
+DT_MSP430F2350	devicelist.h	/^	DT_MSP430F2350,$/;"	e	enum:__anon1
+DT_MSP430F2370	devicelist.h	/^	DT_MSP430F2370,$/;"	e	enum:__anon1
+DT_MSP430F2410	devicelist.h	/^	DT_MSP430F2410,$/;"	e	enum:__anon1
+DT_MSP430F2418	devicelist.h	/^	DT_MSP430F2418,$/;"	e	enum:__anon1
+DT_MSP430F2419	devicelist.h	/^	DT_MSP430F2419,$/;"	e	enum:__anon1
+DT_MSP430F247	devicelist.h	/^	DT_MSP430F247,$/;"	e	enum:__anon1
+DT_MSP430F2471	devicelist.h	/^	DT_MSP430F2471,$/;"	e	enum:__anon1
+DT_MSP430F248	devicelist.h	/^	DT_MSP430F248,$/;"	e	enum:__anon1
+DT_MSP430F2481	devicelist.h	/^	DT_MSP430F2481,$/;"	e	enum:__anon1
+DT_MSP430F249	devicelist.h	/^	DT_MSP430F249,$/;"	e	enum:__anon1
+DT_MSP430F2491	devicelist.h	/^	DT_MSP430F2491,$/;"	e	enum:__anon1
+DT_MSP430F2618	devicelist.h	/^	DT_MSP430F2618,$/;"	e	enum:__anon1
+DT_MSP430F2619	devicelist.h	/^	DT_MSP430F2619,$/;"	e	enum:__anon1
+DT_MSP430F4132	devicelist.h	/^	DT_MSP430F4132,$/;"	e	enum:__anon1
+DT_MSP430F413P	devicelist.h	/^	DT_MSP430F413P,$/;"	e	enum:__anon1
+DT_MSP430F4152	devicelist.h	/^	DT_MSP430F4152,$/;"	e	enum:__anon1
+DT_MSP430F41xC	devicelist.h	/^	DT_MSP430F41xC,$/;"	e	enum:__anon1
+DT_MSP430F423	devicelist.h	/^	DT_MSP430F423,$/;"	e	enum:__anon1
+DT_MSP430F4230	devicelist.h	/^	DT_MSP430F4230,$/;"	e	enum:__anon1
+DT_MSP430F423A	devicelist.h	/^	DT_MSP430F423A,$/;"	e	enum:__anon1
+DT_MSP430F425	devicelist.h	/^	DT_MSP430F425,$/;"	e	enum:__anon1
+DT_MSP430F4250	devicelist.h	/^	DT_MSP430F4250,$/;"	e	enum:__anon1
+DT_MSP430F425A	devicelist.h	/^	DT_MSP430F425A,$/;"	e	enum:__anon1
+DT_MSP430F427	devicelist.h	/^	DT_MSP430F427,$/;"	e	enum:__anon1
+DT_MSP430F427A	devicelist.h	/^	DT_MSP430F427A,$/;"	e	enum:__anon1
+DT_MSP430F42x0	devicelist.h	/^	DT_MSP430F42x0,$/;"	e	enum:__anon1
+DT_MSP430F43x	devicelist.h	/^	DT_MSP430F43x,$/;"	e	enum:__anon1
+DT_MSP430F44x	devicelist.h	/^	DT_MSP430F44x,$/;"	e	enum:__anon1
+DT_MSP430F47166	devicelist.h	/^	DT_MSP430F47166,$/;"	e	enum:__anon1
+DT_MSP430F47167	devicelist.h	/^	DT_MSP430F47167,$/;"	e	enum:__anon1
+DT_MSP430F47176	devicelist.h	/^	DT_MSP430F47176,$/;"	e	enum:__anon1
+DT_MSP430F47177	devicelist.h	/^	DT_MSP430F47177,$/;"	e	enum:__anon1
+DT_MSP430F47186	devicelist.h	/^	DT_MSP430F47186,$/;"	e	enum:__anon1
+DT_MSP430F47187	devicelist.h	/^	DT_MSP430F47187,$/;"	e	enum:__anon1
+DT_MSP430F47196	devicelist.h	/^	DT_MSP430F47196,$/;"	e	enum:__anon1
+DT_MSP430F47197	devicelist.h	/^	DT_MSP430F47197,$/;"	e	enum:__anon1
+DT_MSP430F477	devicelist.h	/^	DT_MSP430F477,$/;"	e	enum:__anon1
+DT_MSP430F478	devicelist.h	/^	DT_MSP430F478,$/;"	e	enum:__anon1
+DT_MSP430F4783	devicelist.h	/^	DT_MSP430F4783,$/;"	e	enum:__anon1
+DT_MSP430F4784	devicelist.h	/^	DT_MSP430F4784,$/;"	e	enum:__anon1
+DT_MSP430F479	devicelist.h	/^	DT_MSP430F479,$/;"	e	enum:__anon1
+DT_MSP430F4793	devicelist.h	/^	DT_MSP430F4793,$/;"	e	enum:__anon1
+DT_MSP430F4794	devicelist.h	/^	DT_MSP430F4794,$/;"	e	enum:__anon1
+DT_MSP430F5131	devicelist.h	/^	DT_MSP430F5131,$/;"	e	enum:__anon1
+DT_MSP430F5132	devicelist.h	/^	DT_MSP430F5132,$/;"	e	enum:__anon1
+DT_MSP430F5151	devicelist.h	/^	DT_MSP430F5151,$/;"	e	enum:__anon1
+DT_MSP430F5152	devicelist.h	/^	DT_MSP430F5152,$/;"	e	enum:__anon1
+DT_MSP430F5171	devicelist.h	/^	DT_MSP430F5171,$/;"	e	enum:__anon1
+DT_MSP430F5172	devicelist.h	/^	DT_MSP430F5172,$/;"	e	enum:__anon1
+DT_MSP430F5212	devicelist.h	/^	DT_MSP430F5212,$/;"	e	enum:__anon1
+DT_MSP430F5213	devicelist.h	/^	DT_MSP430F5213,$/;"	e	enum:__anon1
+DT_MSP430F5214	devicelist.h	/^	DT_MSP430F5214,$/;"	e	enum:__anon1
+DT_MSP430F5217	devicelist.h	/^	DT_MSP430F5217,$/;"	e	enum:__anon1
+DT_MSP430F5218	devicelist.h	/^	DT_MSP430F5218,$/;"	e	enum:__anon1
+DT_MSP430F5219	devicelist.h	/^	DT_MSP430F5219,$/;"	e	enum:__anon1
+DT_MSP430F5222	devicelist.h	/^	DT_MSP430F5222,$/;"	e	enum:__anon1
+DT_MSP430F5223	devicelist.h	/^	DT_MSP430F5223,$/;"	e	enum:__anon1
+DT_MSP430F5224	devicelist.h	/^	DT_MSP430F5224,$/;"	e	enum:__anon1
+DT_MSP430F5227	devicelist.h	/^	DT_MSP430F5227,$/;"	e	enum:__anon1
+DT_MSP430F5228	devicelist.h	/^	DT_MSP430F5228,$/;"	e	enum:__anon1
+DT_MSP430F5229	devicelist.h	/^	DT_MSP430F5229,$/;"	e	enum:__anon1
+DT_MSP430F5304	devicelist.h	/^	DT_MSP430F5304,$/;"	e	enum:__anon1
+DT_MSP430F5308	devicelist.h	/^	DT_MSP430F5308,$/;"	e	enum:__anon1
+DT_MSP430F5309	devicelist.h	/^	DT_MSP430F5309,$/;"	e	enum:__anon1
+DT_MSP430F5310	devicelist.h	/^	DT_MSP430F5310,$/;"	e	enum:__anon1
+DT_MSP430F5324	devicelist.h	/^	DT_MSP430F5324,$/;"	e	enum:__anon1
+DT_MSP430F5325	devicelist.h	/^	DT_MSP430F5325,$/;"	e	enum:__anon1
+DT_MSP430F5326	devicelist.h	/^	DT_MSP430F5326,$/;"	e	enum:__anon1
+DT_MSP430F5327	devicelist.h	/^	DT_MSP430F5327,$/;"	e	enum:__anon1
+DT_MSP430F5328	devicelist.h	/^	DT_MSP430F5328,$/;"	e	enum:__anon1
+DT_MSP430F5329	devicelist.h	/^	DT_MSP430F5329,$/;"	e	enum:__anon1
+DT_MSP430F5333	devicelist.h	/^	DT_MSP430F5333,$/;"	e	enum:__anon1
+DT_MSP430F5335	devicelist.h	/^	DT_MSP430F5335,$/;"	e	enum:__anon1
+DT_MSP430F5336	devicelist.h	/^	DT_MSP430F5336,$/;"	e	enum:__anon1
+DT_MSP430F5338	devicelist.h	/^	DT_MSP430F5338,$/;"	e	enum:__anon1
+DT_MSP430F5340	devicelist.h	/^	DT_MSP430F5340,$/;"	e	enum:__anon1
+DT_MSP430F5341	devicelist.h	/^	DT_MSP430F5341,$/;"	e	enum:__anon1
+DT_MSP430F5342	devicelist.h	/^	DT_MSP430F5342,$/;"	e	enum:__anon1
+DT_MSP430F5357	devicelist.h	/^	DT_MSP430F5357,$/;"	e	enum:__anon1
+DT_MSP430F5358	devicelist.h	/^	DT_MSP430F5358,$/;"	e	enum:__anon1
+DT_MSP430F5359	devicelist.h	/^	DT_MSP430F5359,$/;"	e	enum:__anon1
+DT_MSP430F5418	devicelist.h	/^	DT_MSP430F5418,$/;"	e	enum:__anon1
+DT_MSP430F5418A	devicelist.h	/^	DT_MSP430F5418A,$/;"	e	enum:__anon1
+DT_MSP430F5419	devicelist.h	/^	DT_MSP430F5419,$/;"	e	enum:__anon1
+DT_MSP430F5419A	devicelist.h	/^	DT_MSP430F5419A,$/;"	e	enum:__anon1
+DT_MSP430F5435	devicelist.h	/^	DT_MSP430F5435,$/;"	e	enum:__anon1
+DT_MSP430F5435A	devicelist.h	/^	DT_MSP430F5435A,$/;"	e	enum:__anon1
+DT_MSP430F5436	devicelist.h	/^	DT_MSP430F5436,$/;"	e	enum:__anon1
+DT_MSP430F5436A	devicelist.h	/^	DT_MSP430F5436A,$/;"	e	enum:__anon1
+DT_MSP430F5437	devicelist.h	/^	DT_MSP430F5437,$/;"	e	enum:__anon1
+DT_MSP430F5437A	devicelist.h	/^	DT_MSP430F5437A,$/;"	e	enum:__anon1
+DT_MSP430F5438	devicelist.h	/^	DT_MSP430F5438,$/;"	e	enum:__anon1
+DT_MSP430F5438A	devicelist.h	/^	DT_MSP430F5438A,$/;"	e	enum:__anon1
+DT_MSP430F5500	devicelist.h	/^	DT_MSP430F5500,$/;"	e	enum:__anon1
+DT_MSP430F5501	devicelist.h	/^	DT_MSP430F5501,$/;"	e	enum:__anon1
+DT_MSP430F5502	devicelist.h	/^	DT_MSP430F5502,$/;"	e	enum:__anon1
+DT_MSP430F5503	devicelist.h	/^	DT_MSP430F5503,$/;"	e	enum:__anon1
+DT_MSP430F5504	devicelist.h	/^	DT_MSP430F5504,$/;"	e	enum:__anon1
+DT_MSP430F5505	devicelist.h	/^	DT_MSP430F5505,$/;"	e	enum:__anon1
+DT_MSP430F5506	devicelist.h	/^	DT_MSP430F5506,$/;"	e	enum:__anon1
+DT_MSP430F5507	devicelist.h	/^	DT_MSP430F5507,$/;"	e	enum:__anon1
+DT_MSP430F5508	devicelist.h	/^	DT_MSP430F5508,$/;"	e	enum:__anon1
+DT_MSP430F5509	devicelist.h	/^	DT_MSP430F5509,$/;"	e	enum:__anon1
+DT_MSP430F5510	devicelist.h	/^	DT_MSP430F5510,$/;"	e	enum:__anon1
+DT_MSP430F5513	devicelist.h	/^	DT_MSP430F5513,$/;"	e	enum:__anon1
+DT_MSP430F5514	devicelist.h	/^	DT_MSP430F5514,$/;"	e	enum:__anon1
+DT_MSP430F5515	devicelist.h	/^	DT_MSP430F5515,$/;"	e	enum:__anon1
+DT_MSP430F5517	devicelist.h	/^	DT_MSP430F5517,$/;"	e	enum:__anon1
+DT_MSP430F5519	devicelist.h	/^	DT_MSP430F5519,$/;"	e	enum:__anon1
+DT_MSP430F5521	devicelist.h	/^	DT_MSP430F5521,$/;"	e	enum:__anon1
+DT_MSP430F5522	devicelist.h	/^	DT_MSP430F5522,$/;"	e	enum:__anon1
+DT_MSP430F5524	devicelist.h	/^	DT_MSP430F5524,$/;"	e	enum:__anon1
+DT_MSP430F5525	devicelist.h	/^	DT_MSP430F5525,$/;"	e	enum:__anon1
+DT_MSP430F5526	devicelist.h	/^	DT_MSP430F5526,$/;"	e	enum:__anon1
+DT_MSP430F5527	devicelist.h	/^	DT_MSP430F5527,$/;"	e	enum:__anon1
+DT_MSP430F5528	devicelist.h	/^	DT_MSP430F5528,$/;"	e	enum:__anon1
+DT_MSP430F5529	devicelist.h	/^	DT_MSP430F5529,$/;"	e	enum:__anon1
+DT_MSP430F5630	devicelist.h	/^	DT_MSP430F5630,$/;"	e	enum:__anon1
+DT_MSP430F5631	devicelist.h	/^	DT_MSP430F5631,$/;"	e	enum:__anon1
+DT_MSP430F5632	devicelist.h	/^	DT_MSP430F5632,$/;"	e	enum:__anon1
+DT_MSP430F5633	devicelist.h	/^	DT_MSP430F5633,$/;"	e	enum:__anon1
+DT_MSP430F5634	devicelist.h	/^	DT_MSP430F5634,$/;"	e	enum:__anon1
+DT_MSP430F5635	devicelist.h	/^	DT_MSP430F5635,$/;"	e	enum:__anon1
+DT_MSP430F5636	devicelist.h	/^	DT_MSP430F5636,$/;"	e	enum:__anon1
+DT_MSP430F5637	devicelist.h	/^	DT_MSP430F5637,$/;"	e	enum:__anon1
+DT_MSP430F5638	devicelist.h	/^	DT_MSP430F5638,$/;"	e	enum:__anon1
+DT_MSP430F5658	devicelist.h	/^	DT_MSP430F5658,$/;"	e	enum:__anon1
+DT_MSP430F5659	devicelist.h	/^	DT_MSP430F5659,$/;"	e	enum:__anon1
+DT_MSP430F6433	devicelist.h	/^	DT_MSP430F6433,$/;"	e	enum:__anon1
+DT_MSP430F6435	devicelist.h	/^	DT_MSP430F6435,$/;"	e	enum:__anon1
+DT_MSP430F6436	devicelist.h	/^	DT_MSP430F6436,$/;"	e	enum:__anon1
+DT_MSP430F6438	devicelist.h	/^	DT_MSP430F6438,$/;"	e	enum:__anon1
+DT_MSP430F6457	devicelist.h	/^	DT_MSP430F6457,$/;"	e	enum:__anon1
+DT_MSP430F6458	devicelist.h	/^	DT_MSP430F6458,$/;"	e	enum:__anon1
+DT_MSP430F6459	devicelist.h	/^	DT_MSP430F6459,$/;"	e	enum:__anon1
+DT_MSP430F6630	devicelist.h	/^	DT_MSP430F6630,$/;"	e	enum:__anon1
+DT_MSP430F6631	devicelist.h	/^	DT_MSP430F6631,$/;"	e	enum:__anon1
+DT_MSP430F6632	devicelist.h	/^	DT_MSP430F6632,$/;"	e	enum:__anon1
+DT_MSP430F6633	devicelist.h	/^	DT_MSP430F6633,$/;"	e	enum:__anon1
+DT_MSP430F6634	devicelist.h	/^	DT_MSP430F6634,$/;"	e	enum:__anon1
+DT_MSP430F6635	devicelist.h	/^	DT_MSP430F6635,$/;"	e	enum:__anon1
+DT_MSP430F6636	devicelist.h	/^	DT_MSP430F6636,$/;"	e	enum:__anon1
+DT_MSP430F6637	devicelist.h	/^	DT_MSP430F6637,$/;"	e	enum:__anon1
+DT_MSP430F6638	devicelist.h	/^	DT_MSP430F6638,$/;"	e	enum:__anon1
+DT_MSP430F6658	devicelist.h	/^	DT_MSP430F6658,$/;"	e	enum:__anon1
+DT_MSP430F6659	devicelist.h	/^	DT_MSP430F6659,$/;"	e	enum:__anon1
+DT_MSP430F6700	devicelist.h	/^	DT_MSP430F6700,$/;"	e	enum:__anon1
+DT_MSP430F6701	devicelist.h	/^	DT_MSP430F6701,$/;"	e	enum:__anon1
+DT_MSP430F6702	devicelist.h	/^	DT_MSP430F6702,$/;"	e	enum:__anon1
+DT_MSP430F6703	devicelist.h	/^	DT_MSP430F6703,$/;"	e	enum:__anon1
+DT_MSP430F6720	devicelist.h	/^	DT_MSP430F6720,$/;"	e	enum:__anon1
+DT_MSP430F6721	devicelist.h	/^	DT_MSP430F6721,$/;"	e	enum:__anon1
+DT_MSP430F6722	devicelist.h	/^	DT_MSP430F6722,$/;"	e	enum:__anon1
+DT_MSP430F6723	devicelist.h	/^	DT_MSP430F6723,$/;"	e	enum:__anon1
+DT_MSP430F6724	devicelist.h	/^	DT_MSP430F6724,$/;"	e	enum:__anon1
+DT_MSP430F6725	devicelist.h	/^	DT_MSP430F6725,$/;"	e	enum:__anon1
+DT_MSP430F6726	devicelist.h	/^	DT_MSP430F6726,$/;"	e	enum:__anon1
+DT_MSP430F6730	devicelist.h	/^	DT_MSP430F6730,$/;"	e	enum:__anon1
+DT_MSP430F6731	devicelist.h	/^	DT_MSP430F6731,$/;"	e	enum:__anon1
+DT_MSP430F6732	devicelist.h	/^	DT_MSP430F6732,$/;"	e	enum:__anon1
+DT_MSP430F6733	devicelist.h	/^	DT_MSP430F6733,$/;"	e	enum:__anon1
+DT_MSP430F6734	devicelist.h	/^	DT_MSP430F6734,$/;"	e	enum:__anon1
+DT_MSP430F6735	devicelist.h	/^	DT_MSP430F6735,$/;"	e	enum:__anon1
+DT_MSP430F6736	devicelist.h	/^	DT_MSP430F6736,$/;"	e	enum:__anon1
+DT_MSP430FE423	devicelist.h	/^	DT_MSP430FE423,$/;"	e	enum:__anon1
+DT_MSP430FE4232	devicelist.h	/^	DT_MSP430FE4232,$/;"	e	enum:__anon1
+DT_MSP430FE423A	devicelist.h	/^	DT_MSP430FE423A,$/;"	e	enum:__anon1
+DT_MSP430FE425	devicelist.h	/^	DT_MSP430FE425,$/;"	e	enum:__anon1
+DT_MSP430FE425A	devicelist.h	/^	DT_MSP430FE425A,$/;"	e	enum:__anon1
+DT_MSP430FE427	devicelist.h	/^	DT_MSP430FE427,$/;"	e	enum:__anon1
+DT_MSP430FE4272	devicelist.h	/^	DT_MSP430FE4272,$/;"	e	enum:__anon1
+DT_MSP430FE427A	devicelist.h	/^	DT_MSP430FE427A,$/;"	e	enum:__anon1
+DT_MSP430FE42x2	devicelist.h	/^	DT_MSP430FE42x2,$/;"	e	enum:__anon1
+DT_MSP430FG4250	devicelist.h	/^	DT_MSP430FG4250,$/;"	e	enum:__anon1
+DT_MSP430FG42x0	devicelist.h	/^	DT_MSP430FG42x0,$/;"	e	enum:__anon1
+DT_MSP430FG43x	devicelist.h	/^	DT_MSP430FG43x,$/;"	e	enum:__anon1
+DT_MSP430FG4618	devicelist.h	/^	DT_MSP430FG4618,$/;"	e	enum:__anon1
+DT_MSP430FG4619	devicelist.h	/^	DT_MSP430FG4619,$/;"	e	enum:__anon1
+DT_MSP430FG477	devicelist.h	/^	DT_MSP430FG477,$/;"	e	enum:__anon1
+DT_MSP430FG478	devicelist.h	/^	DT_MSP430FG478,$/;"	e	enum:__anon1
+DT_MSP430FG479	devicelist.h	/^	DT_MSP430FG479,$/;"	e	enum:__anon1
+DT_MSP430FR5720	devicelist.h	/^	DT_MSP430FR5720,$/;"	e	enum:__anon1
+DT_MSP430FR5721	devicelist.h	/^	DT_MSP430FR5721,$/;"	e	enum:__anon1
+DT_MSP430FR5722	devicelist.h	/^	DT_MSP430FR5722,$/;"	e	enum:__anon1
+DT_MSP430FR5723	devicelist.h	/^	DT_MSP430FR5723,$/;"	e	enum:__anon1
+DT_MSP430FR5724	devicelist.h	/^	DT_MSP430FR5724,$/;"	e	enum:__anon1
+DT_MSP430FR5725	devicelist.h	/^	DT_MSP430FR5725,$/;"	e	enum:__anon1
+DT_MSP430FR5726	devicelist.h	/^	DT_MSP430FR5726,$/;"	e	enum:__anon1
+DT_MSP430FR5727	devicelist.h	/^	DT_MSP430FR5727,$/;"	e	enum:__anon1
+DT_MSP430FR5728	devicelist.h	/^	DT_MSP430FR5728,$/;"	e	enum:__anon1
+DT_MSP430FR5729	devicelist.h	/^	DT_MSP430FR5729,$/;"	e	enum:__anon1
+DT_MSP430FR5730	devicelist.h	/^	DT_MSP430FR5730,$/;"	e	enum:__anon1
+DT_MSP430FR5731	devicelist.h	/^	DT_MSP430FR5731,$/;"	e	enum:__anon1
+DT_MSP430FR5732	devicelist.h	/^	DT_MSP430FR5732,$/;"	e	enum:__anon1
+DT_MSP430FR5733	devicelist.h	/^	DT_MSP430FR5733,$/;"	e	enum:__anon1
+DT_MSP430FR5734	devicelist.h	/^	DT_MSP430FR5734,$/;"	e	enum:__anon1
+DT_MSP430FR5735	devicelist.h	/^	DT_MSP430FR5735,$/;"	e	enum:__anon1
+DT_MSP430FR5736	devicelist.h	/^	DT_MSP430FR5736,$/;"	e	enum:__anon1
+DT_MSP430FR5737	devicelist.h	/^	DT_MSP430FR5737,$/;"	e	enum:__anon1
+DT_MSP430FR5738	devicelist.h	/^	DT_MSP430FR5738,$/;"	e	enum:__anon1
+DT_MSP430FR5739	devicelist.h	/^	DT_MSP430FR5739,$/;"	e	enum:__anon1
+DT_MSP430FR5969	devicelist.h	/^	DT_MSP430FR5969,$/;"	e	enum:__anon1
+DT_MSP430FW429	devicelist.h	/^	DT_MSP430FW429,$/;"	e	enum:__anon1
+DT_MSP430FW42x	devicelist.h	/^	DT_MSP430FW42x,$/;"	e	enum:__anon1
+DT_MSP430G2452	devicelist.h	/^	DT_MSP430G2452,$/;"	e	enum:__anon1
+DT_MSP430G2553	devicelist.h	/^	DT_MSP430G2553,$/;"	e	enum:__anon1
+DT_MSP430L092	devicelist.h	/^	DT_MSP430L092,$/;"	e	enum:__anon1
+DT_PMS430F16x	devicelist.h	/^	DT_PMS430F16x,$/;"	e	enum:__anon1
+DT_TMS430C1250	devicelist.h	/^	DT_TMS430C1250,$/;"	e	enum:__anon1
+DT_TMS430EMU	devicelist.h	/^	DT_TMS430EMU,$/;"	e	enum:__anon1
+DT_TMS430F1250	devicelist.h	/^	DT_TMS430F1250,$/;"	e	enum:__anon1
+DT_TMS430F1390	devicelist.h	/^	DT_TMS430F1390,$/;"	e	enum:__anon1
+DT_UNKNOWN_DEVICE	devicelist.h	/^	DT_UNKNOWN_DEVICE = 0,$/;"	e	enum:__anon1
+DT_XMS430F5438	devicelist.h	/^	DT_XMS430F5438,$/;"	e	enum:__anon1
+EDT_TRACE_MODE	tilib_defs.h	/^        EDT_TRACE_MODE = 7,$/;"	e	enum:CONFIG_MODE
+EMB_SYS_OFFSET	fet_olimex_db.c	33;"	d	file:
+EMULATION_MODE	tilib_defs.h	/^        EMULATION_MODE = 1,$/;"	e	enum:CONFIG_MODE
+ENABLE	jtdev.c	69;"	d	file:
+ERASE_ALL	tilib_defs.h	/^        ERASE_ALL = 2, \/**< Erase all MAIN and INFORMATION memory *\/$/;"	e	enum:ERASE_TYPE
+ERASE_MAIN	tilib_defs.h	/^        ERASE_MAIN = 1, \/**< Erase all MAIN memory *\/$/;"	e	enum:ERASE_TYPE
+ERASE_SEGMENT	flash_bsl.c	92;"	d	file:
+ERASE_SEGMENT	tilib_defs.h	/^        ERASE_SEGMENT = 0, \/**< Erase a segment *\/$/;"	e	enum:ERASE_TYPE
+ERASE_TYPE	tilib_defs.h	/^enum ERASE_TYPE {$/;"	g
+ERR	jtdev.c	47;"	d	file:
+FAB_ID_OFFSET	fet_olimex_db.c	30;"	d	file:
+FCTL3_ADDR	sim.c	68;"	d	file:
+FET_CONFIG_CLKCTRL	fet_core.c	111;"	d	file:
+FET_CONFIG_EMULATION	fet_core.c	110;"	d	file:
+FET_CONFIG_FLASH_LOCK	fet_core.c	114;"	d	file:
+FET_CONFIG_FLASH_TESET	fet_core.c	113;"	d	file:
+FET_CONFIG_MCLKCTRL	fet_core.c	112;"	d	file:
+FET_CONFIG_PROTOCOL	fet_core.c	115;"	d	file:
+FET_CONFIG_UNLOCK_BSL	fet_core.c	116;"	d	file:
+FET_CONFIG_VERIFICATION	fet_core.c	109;"	d	file:
+FET_CORE_H_	fet_core.h	20;"	d
+FET_DB_H_	fet_db.h	20;"	d
+FET_DB_MSG28_LEN	fet_db.h	24;"	d
+FET_DB_MSG29_LEN	fet_db.h	26;"	d
+FET_DB_MSG29_PARAMS	fet_db.h	25;"	d
+FET_DB_MSG2B_LEN	fet_db.h	27;"	d
+FET_ERASE_ALL	fet_core.c	129;"	d	file:
+FET_ERASE_MAIN	fet_core.c	128;"	d	file:
+FET_ERASE_SEGMENT	fet_core.c	127;"	d	file:
+FET_ERROR_H_	fet_error.h	20;"	d
+FET_FORCE_RESET	fet_core.h	32;"	d
+FET_H_	fet.h	20;"	d
+FET_IDENTIFY_NEW	fet_core.h	29;"	d
+FET_OLIMEX_DB_H_	fet_olimex_db.h	21;"	d
+FET_OLIMEX_DB_MSG28_LEN	fet_olimex_db.h	26;"	d
+FET_OLIMEX_DB_MSG29_LEN	fet_olimex_db.h	28;"	d
+FET_OLIMEX_DB_MSG29_PARAMS	fet_olimex_db.h	27;"	d
+FET_OLIMEX_DB_MSG2B_LEN	fet_olimex_db.h	29;"	d
+FET_POLL_BREAKPOINT	fet_core.c	132;"	d	file:
+FET_POLL_RUNNING	fet_core.c	131;"	d	file:
+FET_PROTO_EXTRA_RECV	fet_proto.h	30;"	d
+FET_PROTO_H_	fet_proto.h	20;"	d
+FET_PROTO_MAX_BLOCK	fet_proto.h	37;"	d
+FET_PROTO_MAX_PARAMS	fet_proto.h	36;"	d
+FET_PROTO_NOLEAD_SEND	fet_proto.h	33;"	d
+FET_PROTO_SEPARATE_DATA	fet_proto.h	27;"	d
+FET_RESET_ALL	fet_core.c	125;"	d	file:
+FET_RESET_PUC	fet_core.c	122;"	d	file:
+FET_RESET_RST	fet_core.c	123;"	d	file:
+FET_RESET_VCC	fet_core.c	124;"	d	file:
+FET_RUN_BREAKPOINT	fet_core.c	120;"	d	file:
+FET_RUN_FREE	fet_core.c	118;"	d	file:
+FET_RUN_STEP	fet_core.c	119;"	d	file:
+FET_SKIP_CLOSE	fet_core.h	26;"	d
+FLASH_BSL_H_	flash_bsl.h	21;"	d
+FLASH_PAGE_SIZE	obl.c	28;"	d	file:
+FLASH_SWOP	tilib_defs.h	/^        FLASH_SWOP = 6,$/;"	e	enum:CONFIG_MODE
+FLASH_TEST_MODE	tilib_defs.h	/^        FLASH_TEST_MODE = 4,$/;"	e	enum:CONFIG_MODE
+FORCE_RESET	tilib_defs.h	/^	FORCE_RESET = (1 << 3)$/;"	e	enum:RESET_METHOD
+FREE_RUN	tilib_defs.h	/^        FREE_RUN = 1,$/;"	e	enum:RUN_MODES
+GDBC_H_	gdbc.h	20;"	d
+GIE_MASK	sim.c	75;"	d	file:
+GLOBAL_CALL	goodfet.c	39;"	d	file:
+GLOBAL_DEBUG	goodfet.c	46;"	d	file:
+GLOBAL_EXEC	goodfet.c	40;"	d	file:
+GLOBAL_EXIST	goodfet.c	42;"	d	file:
+GLOBAL_LIMIT	goodfet.c	41;"	d	file:
+GLOBAL_NMEM	goodfet.c	43;"	d	file:
+GLOBAL_NOK	goodfet.c	44;"	d	file:
+GLOBAL_OK	goodfet.c	45;"	d	file:
+GLOBAL_PEEK	goodfet.c	34;"	d	file:
+GLOBAL_POKE	goodfet.c	35;"	d	file:
+GLOBAL_READ	goodfet.c	32;"	d	file:
+GLOBAL_SETUP	goodfet.c	36;"	d	file:
+GLOBAL_START	goodfet.c	37;"	d	file:
+GLOBAL_STOP	goodfet.c	38;"	d	file:
+GLOBAL_WRITE	goodfet.c	33;"	d	file:
+GOODFET_H_	goodfet.h	20;"	d
+HI_MASK_INTERRUPT_IRQ	sim.c	93;"	d	file:
+HasFramMemroy	tilib_defs.h	/^		WORD HasFramMemroy;$/;"	m	struct:DEVICE_T::__anon2
+ID0_OFFSET	fet_olimex_db.c	27;"	d	file:
+ID1_OFFSET	fet_olimex_db.c	28;"	d	file:
+IE1_ADDR	sim.c	65;"	d	file:
+IFG1_ADDR	sim.c	67;"	d	file:
+IMAGE_MAGIC	obl.c	27;"	d	file:
+INIT	jtdev.c	56;"	d	file:
+INTERFACE_MODE	tilib_defs.h	/^        INTERFACE_MODE = 8,$/;"	e	enum:CONFIG_MODE
+INTERRUPT_ACCV	sim.c	/^	INTERRUPT_ACCV,		\/* Flash Access Violation *\/$/;"	e	enum:__anon7	file:
+INTERRUPT_MASK	sim.c	/^	INTERRUPT_MASK,		\/* All maskable interrupts *\/$/;"	e	enum:__anon7	file:
+INTERRUPT_NMI	sim.c	/^	INTERRUPT_NMI,		\/* NMI *\/$/;"	e	enum:__anon7	file:
+INTERRUPT_NONE	sim.c	/^	INTERRUPT_NONE,$/;"	e	enum:__anon7	file:
+INTERRUPT_OF	sim.c	/^	INTERRUPT_OF,		\/* Oscilalator Fault *\/$/;"	e	enum:__anon7	file:
+INTERRUPT_RST	sim.c	/^	INTERRUPT_RST, 		\/* RST *\/$/;"	e	enum:__anon7	file:
+INTERRUPT_TOTAL_NUM	sim.c	/^	INTERRUPT_TOTAL_NUM$/;"	e	enum:__anon7	file:
+IRQEN	jtdev.c	58;"	d	file:
+IR_ADDR_16BIT	jtaglib.c	45;"	d	file:
+IR_ADDR_CAPTURE	jtaglib.c	46;"	d	file:
+IR_BYPASS	jtaglib.c	55;"	d	file:
+IR_CNTRL_SIG_16BIT	jtaglib.c	37;"	d	file:
+IR_CNTRL_SIG_CAPTURE	jtaglib.c	38;"	d	file:
+IR_CNTRL_SIG_RELEASE	jtaglib.c	39;"	d	file:
+IR_DATA_16BIT	jtaglib.c	41;"	d	file:
+IR_DATA_CAPTURE	jtaglib.c	42;"	d	file:
+IR_DATA_PSA	jtaglib.c	49;"	d	file:
+IR_DATA_QUICK	jtaglib.c	43;"	d	file:
+IR_DATA_TO_ADDR	jtaglib.c	47;"	d	file:
+IR_EX_BLOW	jtaglib.c	53;"	d	file:
+IR_PREPARE_BLOW	jtaglib.c	52;"	d	file:
+IR_SHIFT_OUT_PSA	jtaglib.c	50;"	d	file:
+JTAG430_BLOWFUSE	goodfet.c	60;"	d	file:
+JTAG430_COREIP_ID	goodfet.c	63;"	d	file:
+JTAG430_DEVICE_ID	goodfet.c	64;"	d	file:
+JTAG430_ERASECHECK	goodfet.c	58;"	d	file:
+JTAG430_ERASEFLASH	goodfet.c	57;"	d	file:
+JTAG430_ERASEINFO	goodfet.c	62;"	d	file:
+JTAG430_GETREG	goodfet.c	53;"	d	file:
+JTAG430_HALTCPU	goodfet.c	48;"	d	file:
+JTAG430_ISFUSEBLOWN	goodfet.c	61;"	d	file:
+JTAG430_READMEM	goodfet.c	56;"	d	file:
+JTAG430_RELEASECPU	goodfet.c	49;"	d	file:
+JTAG430_SETINSTRFETCH	goodfet.c	50;"	d	file:
+JTAG430_SETPC	goodfet.c	51;"	d	file:
+JTAG430_SETREG	goodfet.c	52;"	d	file:
+JTAG430_VERIFYMEM	goodfet.c	59;"	d	file:
+JTAG430_WRITEFLASH	goodfet.c	55;"	d	file:
+JTAG430_WRITEMEM	goodfet.c	54;"	d	file:
+JTAGLIB_H_	jtaglib.h	26;"	d
+JTAG_ERASE_MAIN	jtaglib.h	36;"	d
+JTAG_ERASE_MASS	jtaglib.h	35;"	d
+JTAG_ERASE_SGMT	jtaglib.h	37;"	d
+JTAG_ID	jtaglib.c	33;"	d	file:
+JTDEV_H_	jtdev.h	21;"	d
+LED_GREEN	jtdev.c	70;"	d	file:
+LED_RED	jtdev.c	71;"	d	file:
+LOAD_PC	flash_bsl.c	96;"	d	file:
+LOCKED_FLASH_ACCESS	tilib_defs.h	/^        LOCKED_FLASH_ACCESS = 5,$/;"	e	enum:CONFIG_MODE
+LONG	tilib_defs.h	/^typedef long LONG;$/;"	t
+LPMX5_MODE	tilib_defs.h	/^        LPMX5_MODE = 4,$/;"	e	enum:STATE_MODES
+LPMX5_WAKEUP	tilib_defs.h	/^        LPMX5_WAKEUP = 5$/;"	e	enum:STATE_MODES
+MASS_ERASE	flash_bsl.c	94;"	d	file:
+MAX_BLOCK	flash_bsl.c	40;"	d	file:
+MAX_LEN	goodfet.c	67;"	d	file:
+MAX_MEM_BLOCK	goodfet.c	68;"	d	file:
+MAX_PACKET	flash_bsl.c	43;"	d	file:
+MCLK_CNTRL_MODE	tilib_defs.h	/^        MCLK_CNTRL_MODE = 3,$/;"	e	enum:CONFIG_MODE
+MEM_GETB	sim.c	198;"	d	file:
+MEM_GETW	sim.c	200;"	d	file:
+MEM_IO_END	sim.c	40;"	d	file:
+MEM_SETB	sim.c	199;"	d	file:
+MEM_SETW	sim.c	203;"	d	file:
+MEM_SIZE	sim.c	39;"	d	file:
+MESSAGE_ID	tilib_defs.h	/^typedef struct MESSAGE_ID {$/;"	s
+MID_BREAKPOINT	tilib.c	96;"	d	file:
+MID_CPU_STOPPED	tilib.c	100;"	d	file:
+MID_HALT_ANY	tilib.c	102;"	d	file:
+MID_SINGLE_STEP	tilib.c	95;"	d	file:
+MID_STATE	tilib.c	98;"	d	file:
+MID_STORAGE	tilib.c	97;"	d	file:
+MID_WARNING	tilib.c	99;"	d	file:
+MSP430_Close	tilib.c	/^	STATUS_T TIDLL (*MSP430_Close)(long vccOff);$/;"	m	struct:tilib_device	file:
+MSP430_Configure	tilib.c	/^	STATUS_T TIDLL (*MSP430_Configure)(long mode, long value);$/;"	m	struct:tilib_device	file:
+MSP430_EEM_Init	tilib.c	/^	STATUS_T TIDLL (*MSP430_EEM_Init)(DLL430_EVENTNOTIFY_FUNC callback,$/;"	m	struct:tilib_device	file:
+MSP430_EEM_SetBreakpoint	tilib.c	/^	STATUS_T TIDLL (*MSP430_EEM_SetBreakpoint)(uint16_t *pwBpHandle,$/;"	m	struct:tilib_device	file:
+MSP430_Erase	tilib.c	/^	STATUS_T TIDLL (*MSP430_Erase)(long type, long address, long length);$/;"	m	struct:tilib_device	file:
+MSP430_Error_Number	tilib.c	/^	STATUS_T TIDLL (*MSP430_Error_Number)(void);$/;"	m	struct:tilib_device	file:
+MSP430_Error_String	tilib.c	/^	const char *TIDLL (*MSP430_Error_String)(long errNumber);$/;"	m	struct:tilib_device	file:
+MSP430_FET_FwUpdate	tilib.c	/^	STATUS_T TIDLL (*MSP430_FET_FwUpdate)(char* lpszFileName,$/;"	m	struct:tilib_device	file:
+MSP430_GetFoundDevice	tilib.c	/^	STATUS_T TIDLL (*MSP430_GetFoundDevice)(char *FoundDevice,$/;"	m	struct:tilib_device	file:
+MSP430_GetNameOfUsbIf	tilib.c	/^	STATUS_T TIDLL (*MSP430_GetNameOfUsbIf)(long idx, char **name,$/;"	m	struct:tilib_device	file:
+MSP430_GetNumberOfUsbIfs	tilib.c	/^	STATUS_T TIDLL (*MSP430_GetNumberOfUsbIfs)(long* number);$/;"	m	struct:tilib_device	file:
+MSP430_Initialize	tilib.c	/^	STATUS_T TIDLL (*MSP430_Initialize)(char *port, long *version);$/;"	m	struct:tilib_device	file:
+MSP430_Memory	tilib.c	/^	STATUS_T TIDLL (*MSP430_Memory)(long address, char *buffer,$/;"	m	struct:tilib_device	file:
+MSP430_OpenDevice	tilib.c	/^	STATUS_T TIDLL (*MSP430_OpenDevice)(char *Device, char *Password,$/;"	m	struct:tilib_device	file:
+MSP430_Registers	tilib.c	/^	STATUS_T TIDLL (*MSP430_Registers)(long *registers, long mask,$/;"	m	struct:tilib_device	file:
+MSP430_Reset	tilib.c	/^	STATUS_T TIDLL (*MSP430_Reset)(long method, long execute,$/;"	m	struct:tilib_device	file:
+MSP430_Run	tilib.c	/^	STATUS_T TIDLL (*MSP430_Run)(long mode, long releaseJTAG);$/;"	m	struct:tilib_device	file:
+MSP430_State	tilib.c	/^	STATUS_T TIDLL (*MSP430_State)(long *state, long stop,$/;"	m	struct:tilib_device	file:
+MSP430_VCC	tilib.c	/^	STATUS_T TIDLL (*MSP430_VCC)(long voltage);$/;"	m	struct:tilib_device	file:
+MessageID_t	tilib_defs.h	/^} MessageID_t;$/;"	t	typeref:struct:MESSAGE_ID
+NMIIE_MASK	sim.c	73;"	d	file:
+NMIIFG_MASK	sim.c	76;"	d	file:
+NO_INSTR	sim.c	91;"	d	file:
+NO_IRQ	sim.c	92;"	d	file:
+OBL_CMD_DEV_RESET	obl.c	/^	OBL_CMD_DEV_RESET	= 0x07,$/;"	e	enum:__anon8	file:
+OBL_CMD_DEV_VERSION	obl.c	/^	OBL_CMD_DEV_VERSION	= 0x08,$/;"	e	enum:__anon8	file:
+OBL_CMD_PROD_TEST	obl.c	/^	OBL_CMD_PROD_TEST	= 0x09$/;"	e	enum:__anon8	file:
+OBL_CMD_READ_FLASH	obl.c	/^	OBL_CMD_READ_FLASH	= 0x03,$/;"	e	enum:__anon8	file:
+OBL_CMD_READ_RAM	obl.c	/^	OBL_CMD_READ_RAM	= 0x01,$/;"	e	enum:__anon8	file:
+OBL_CMD_RF_SELF_TEST	obl.c	/^	OBL_CMD_RF_SELF_TEST	= 0x05,$/;"	e	enum:__anon8	file:
+OBL_CMD_SET_PROTECTION	obl.c	/^	OBL_CMD_SET_PROTECTION	= 0x06,$/;"	e	enum:__anon8	file:
+OBL_CMD_WRITE_FLASH	obl.c	/^	OBL_CMD_WRITE_FLASH	= 0x04,$/;"	e	enum:__anon8	file:
+OBL_CMD_WRITE_RAM	obl.c	/^	OBL_CMD_WRITE_RAM	= 0x02,$/;"	e	enum:__anon8	file:
+OBL_H_	obl.h	20;"	d
+OBL_RESULT_COMMAND_FAULT	obl.c	/^	OBL_RESULT_COMMAND_FAULT	= 0xff$/;"	e	enum:__anon9	file:
+OBL_RESULT_NRF_LINK_FAULT	obl.c	/^	OBL_RESULT_NRF_LINK_FAULT	= 0x02,$/;"	e	enum:__anon9	file:
+OBL_RESULT_NRF_SPI_FAULT	obl.c	/^	OBL_RESULT_NRF_SPI_FAULT	= 0x01,$/;"	e	enum:__anon9	file:
+OBL_RESULT_OK	obl.c	/^	OBL_RESULT_OK			= 0x00,$/;"	e	enum:__anon9	file:
+OFIE_MASK	sim.c	71;"	d	file:
+OFIFG_MASK	sim.c	77;"	d	file:
+PE	jtdev.c	49;"	d	file:
+PIF_H_	pif.h	27;"	d
+POWER	jtdev.c	67;"	d	file:
+PTYPE_ACK	fet_proto.c	117;"	d	file:
+PTYPE_CMD	fet_proto.c	118;"	d	file:
+PTYPE_DATA	fet_proto.c	120;"	d	file:
+PTYPE_FLASH_ACK	fet_proto.c	123;"	d	file:
+PTYPE_MIXED	fet_proto.c	121;"	d	file:
+PTYPE_NAK	fet_proto.c	122;"	d	file:
+PTYPE_PARAM	fet_proto.c	119;"	d	file:
+PUC_RESET	tilib_defs.h	/^	PUC_RESET   = (1 << 0), \/**< Power up clear (i.e., a "soft") reset *\/$/;"	e	enum:RESET_METHOD
+RAM_PRESERVE_MODE	tilib_defs.h	/^	RAM_PRESERVE_MODE = 10,$/;"	e	enum:CONFIG_MODE
+READ	tilib_defs.h	/^	READ = 1,$/;"	e	enum:READ_WRITE
+READ_WRITE	tilib_defs.h	/^enum READ_WRITE {$/;"	g
+RESET	jtdev.c	68;"	d	file:
+RESET_METHOD	tilib_defs.h	/^enum RESET_METHOD {$/;"	g
+REV_OFFSET	fet_olimex_db.c	29;"	d	file:
+RST_RESET	tilib_defs.h	/^	RST_RESET   = (1 << 1), \/**< RST\/NMI (i.e., "hard") reset *\/$/;"	e	enum:RESET_METHOD
+RUNNING	tilib_defs.h	/^        RUNNING = 1,$/;"	e	enum:STATE_MODES
+RUN_MODES	tilib_defs.h	/^enum RUN_MODES {$/;"	g
+RUN_TO_BREAKPOINT	tilib_defs.h	/^        RUN_TO_BREAKPOINT = 3$/;"	e	enum:RUN_MODES
+RX_DATA_BLOCK	flash_bsl.c	89;"	d	file:
+RX_DATA_BLOCK_FAST	flash_bsl.c	90;"	d	file:
+RX_PASSWORD	flash_bsl.c	91;"	d	file:
+SEL	jtdev.c	48;"	d	file:
+SELECTIN	jtdev.c	57;"	d	file:
+SELF_TEST0_OFFSET	fet_olimex_db.c	31;"	d	file:
+SELF_TEST1_OFFSET	fet_olimex_db.c	32;"	d	file:
+SET_MDB_BEFORE_RUN	tilib_defs.h	/^        SET_MDB_BEFORE_RUN = 9,$/;"	e	enum:CONFIG_MODE
+SIM_H_	sim.h	20;"	d
+SINGLE_STEP	tilib_defs.h	/^        SINGLE_STEP = 2,$/;"	e	enum:RUN_MODES
+SINGLE_STEP_COMPLETE	tilib_defs.h	/^        SINGLE_STEP_COMPLETE = 2,$/;"	e	enum:STATE_MODES
+STATE_MODES	tilib_defs.h	/^enum STATE_MODES {$/;"	g
+STATUS_T	tilib_defs.h	/^typedef long STATUS_T;$/;"	t
+STOPPED	tilib_defs.h	/^        STOPPED = 0,$/;"	e	enum:STATE_MODES
+STROBE	jtdev.c	54;"	d	file:
+TCK	jtdev.c	65;"	d	file:
+TCLK	jtdev.c	73;"	d	file:
+TDI	jtdev.c	63;"	d	file:
+TDO	jtdev.c	62;"	d	file:
+TEST	jtdev.c	61;"	d	file:
+TIDLL	tilib.c	33;"	d	file:
+TIDLL	tilib.c	36;"	d	file:
+TILIB_DEFS_H_	tilib_defs.h	20;"	d
+TILIB_H_	tilib.h	20;"	d
+TMS	jtdev.c	64;"	d	file:
+TX_BSL_VERSION	flash_bsl.c	98;"	d	file:
+TX_BUFFER_SIZE	flash_bsl.c	99;"	d	file:
+TX_DATA_BLOCK	flash_bsl.c	97;"	d	file:
+TrigerMask	tilib_defs.h	/^		WORD TrigerMask;$/;"	m	struct:DEVICE_T::__anon2
+ULONG	tilib_defs.h	/^typedef unsigned long ULONG;$/;"	t
+UNLOCK_BSL_MODE	tilib_defs.h	/^	UNLOCK_BSL_MODE =11,$/;"	e	enum:CONFIG_MODE
+UNLOCK_LOCK_INFO	flash_bsl.c	93;"	d	file:
+UPDATE_STATUS_MESSAGES	tilib_defs.h	/^typedef enum UPDATE_STATUS_MESSAGES {$/;"	g
+UPDATE_STATUS_MESSAGES_t	tilib_defs.h	/^} UPDATE_STATUS_MESSAGES_t;$/;"	t	typeref:enum:UPDATE_STATUS_MESSAGES
+VCC_RESET	tilib_defs.h	/^	VCC_RESET   = (1 << 2), \/**< Cycle Vcc (i.e., a "power on") reset *\/$/;"	e	enum:RESET_METHOD
+VERIFICATION_MODE	tilib_defs.h	/^        VERIFICATION_MODE = 0,$/;"	e	enum:CONFIG_MODE
+WDTCTL_ADDR	sim.c	66;"	d	file:
+WDTNMI_MASK	sim.c	74;"	d	file:
+WORD	tilib_defs.h	/^typedef uint16_t WORD;$/;"	t
+WRITE	tilib_defs.h	/^	WRITE = 0,$/;"	e	enum:READ_WRITE
+WRITE_EXTERNAL_MEMORY	tilib_defs.h	/^	WRITE_EXTERNAL_MEMORY = 13,$/;"	e	enum:CONFIG_MODE
+XOUT	jtdev.c	66;"	d	file:
+active_fperm	fet_core.c	/^	fperm_t				active_fperm;$/;"	m	struct:fet_device	file:
+active_fperm	tilib.c	/^	fperm_t			active_fperm;$/;"	m	struct:tilib_device	file:
+add_child	sim.c	/^void add_child(search_node *parent_node, search_node *new_node)$/;"	f
+addbrk	device.c	/^static int addbrk(device_t dev, address_t addr, device_bptype_t type)$/;"	f	file:
+addr	device.h	/^	address_t		addr;$/;"	m	struct:device_breakpoint
+app	goodfet.c	/^	uint8_t		app;$/;"	m	struct:packet	file:
+argc	fet_proto.h	/^	int				argc;$/;"	m	struct:fet_proto
+argv	fet_proto.h	/^	uint32_t			argv[FET_PROTO_MAX_PARAMS];$/;"	m	struct:fet_proto
+base	bsl.c	/^	struct device   base;$/;"	m	struct:bsl_device	typeref:struct:bsl_device::device	file:
+base	fet_core.c	/^	struct device                   base;$/;"	m	struct:fet_device	typeref:struct:fet_device::device	file:
+base	flash_bsl.c	/^	struct device   base;$/;"	m	struct:flash_bsl_device	typeref:struct:flash_bsl_device::device	file:
+base	gdbc.c	/^	struct device			base;$/;"	m	struct:gdb_client	typeref:struct:gdb_client::device	file:
+base	goodfet.c	/^	struct device		base;$/;"	m	struct:goodfet	typeref:struct:goodfet::device	file:
+base	pif.c	/^  struct device		base;$/;"	m	struct:pif_device	typeref:struct:pif_device::device	file:
+base	sim.c	/^	struct device           base;$/;"	m	struct:sim_device	typeref:struct:sim_device::device	file:
+base	tilib.c	/^	struct device		base;$/;"	m	struct:tilib_device	typeref:struct:tilib_device::device	file:
+bpAccess	tilib_defs.h	/^	BpAccess_t        bpAccess;$/;"	m	struct:BREAKPOINT
+bpAction	tilib_defs.h	/^	BpAction_t        bpAction;$/;"	m	struct:BREAKPOINT
+bpCondAccess	tilib_defs.h	/^	BpAccess_t        bpCondAccess;$/;"	m	struct:BREAKPOINT
+bpCondOperat	tilib_defs.h	/^	BpOperat_t        bpCondOperat;$/;"	m	struct:BREAKPOINT
+bpCondition	tilib_defs.h	/^	BpCondition_t     bpCondition;$/;"	m	struct:BREAKPOINT
+bpMode	tilib_defs.h	/^	BpMode_t          bpMode;$/;"	m	struct:BREAKPOINT
+bpOperat	tilib_defs.h	/^	BpOperat_t        bpOperat;$/;"	m	struct:BREAKPOINT
+bpRangeAction	tilib_defs.h	/^	BpRangeAction_t   bpRangeAction;$/;"	m	struct:BREAKPOINT
+bpType	tilib_defs.h	/^	BpType_t          bpType;$/;"	m	struct:BREAKPOINT
+bp_handles	tilib.c	/^	uint16_t		bp_handles[DEVICE_MAX_BREAKPOINTS];$/;"	m	struct:tilib_device	file:
+bp_send	gdbc.c	/^static int bp_send(struct gdb_data *gdb, int c, address_t addr,$/;"	f	file:
+breakpoints	device.h	/^	struct device_breakpoint breakpoints[DEVICE_MAX_BREAKPOINTS];$/;"	m	struct:device	typeref:struct:device::device_breakpoint
+bslEnd	tilib_defs.h	/^		WORD  bslEnd;$/;"	m	struct:DEVICE_T::__anon2
+bslStart	tilib_defs.h	/^		WORD  bslStart;$/;"	m	struct:DEVICE_T::__anon2
+bsl_ack	bsl.c	/^static int bsl_ack(struct bsl_device *dev)$/;"	f	file:
+bsl_ctl	bsl.c	/^static int bsl_ctl(device_t dev_base, device_ctl_t type)$/;"	f	file:
+bsl_destroy	bsl.c	/^static void bsl_destroy(device_t dev_base)$/;"	f	file:
+bsl_device	bsl.c	/^struct bsl_device {$/;"	s	file:
+bsl_erase	bsl.c	/^static int bsl_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+bsl_getregs	bsl.c	/^static int bsl_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+bsl_open	bsl.c	/^static device_t bsl_open(const struct device_args *args)$/;"	f	file:
+bsl_poll	bsl.c	/^static device_status_t bsl_poll(device_t dev_base)$/;"	f	file:
+bsl_readmem	bsl.c	/^static int bsl_readmem(device_t dev_base,$/;"	f	file:
+bsl_setregs	bsl.c	/^static int bsl_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+bsl_sync	bsl.c	/^static int bsl_sync(struct bsl_device *dev)$/;"	f	file:
+bsl_writemem	bsl.c	/^static int bsl_writemem(device_t dev_base,$/;"	f	file:
+bsl_xfer	bsl.c	/^static int bsl_xfer(struct bsl_device *dev,$/;"	f	file:
+buffer	tilib_defs.h	/^	CHAR buffer[110];$/;"	m	union:DEVICE_T
+calc_checksum	fet_proto.c	/^static uint16_t calc_checksum(uint8_t *cp, int len)$/;"	f	file:
+check_ok	gdbc.c	/^static int check_ok(struct gdb_data *gdb)$/;"	f	file:
+clockControl	tilib_defs.h	/^		WORD  clockControl;$/;"	m	struct:DEVICE_T::__anon2
+command_code	fet_proto.h	/^	int				command_code;$/;"	m	struct:fet_proto
+connect_to	gdbc.c	/^static int connect_to(const char *spec)$/;"	f	file:
+control_register	jtdev.h	/^	uint8_t		control_register;$/;"	m	struct:jtdev
+coreIpId	tilib_defs.h	/^		WORD  coreIpId;$/;"	m	struct:DEVICE_T::__anon2
+cpuArch	tilib_defs.h	/^		BYTE  cpuArch;$/;"	m	struct:DEVICE_T::__anon2
+crc_ccitt	flash_bsl.c	/^static uint16_t crc_ccitt(const uint8_t *data, int len) {$/;"	f	file:
+crc_selftest	flash_bsl.c	/^static void crc_selftest(void) {$/;"	f	file:
+create_child_node	sim.c	/^void create_child_node(struct sim_device *dev, search_node *parent, $/;"	f
+create_node	sim.c	/^search_node *create_node(interrupt_t type, uint16_t instr_addr, int irq, $/;"	f
+ctl	device.h	/^	int (*ctl)(device_t dev, device_ctl_t op);$/;"	m	struct:device_class
+current_insn	sim.c	/^	uint16_t                current_insn;$/;"	m	struct:sim_device	file:
+data	fet_proto.h	/^	uint8_t				*data;$/;"	m	struct:fet_proto
+data	goodfet.c	/^	uint8_t		data[MAX_LEN];$/;"	m	struct:packet	file:
+data_register	jtdev.h	/^	uint8_t		data_register;$/;"	m	struct:jtdev
+datalen	fet_proto.h	/^	int				datalen;$/;"	m	struct:fet_proto
+delbrk	device.c	/^static void delbrk(device_t dev, address_t addr, device_bptype_t type)$/;"	f	file:
+delete_prev_sib_subtree	sim.c	/^void delete_prev_sib_subtree(search_node *node)$/;"	f
+delete_subtree	sim.c	/^void delete_subtree(search_node *node)$/;"	f
+depth	sim.c	/^	int depth;$/;"	m	struct:search_node	file:
+destroy	device.h	/^	void (*destroy)(device_t dev);$/;"	m	struct:device_class
+dev_id	device.h	/^	uint8_t				dev_id[3];$/;"	m	struct:device
+device	device.h	/^struct device {$/;"	s
+deviceIdPtr	tilib_defs.h	/^		ULONG deviceIdPtr;$/;"	m	struct:DEVICE_T::__anon2
+device_args	device.h	/^struct device_args {$/;"	s
+device_bptype_t	device.h	/^} device_bptype_t;$/;"	t	typeref:enum:__anon6
+device_breakpoint	device.h	/^struct device_breakpoint {$/;"	s
+device_bsl	bsl.c	/^const struct device_class device_bsl = {$/;"	v	typeref:struct:device_class
+device_class	device.h	/^struct device_class {$/;"	s
+device_ctl	device.h	175;"	d
+device_ctl_t	device.h	/^} device_ctl_t;$/;"	t	typeref:enum:__anon3
+device_default	device.c	/^device_t device_default;$/;"	v
+device_destroy	device.h	166;"	d
+device_erase	device.c	/^int device_erase(device_erase_type_t et, address_t addr)$/;"	f
+device_erase_type_t	device.h	/^} device_erase_type_t;$/;"	t	typeref:enum:__anon5
+device_flash_bsl	flash_bsl.c	/^const struct device_class device_flash_bsl = {$/;"	v	typeref:struct:device_class
+device_gdbc	gdbc.c	/^const struct device_class device_gdbc = {$/;"	v	typeref:struct:device_class
+device_getregs	device.h	171;"	d
+device_goodfet	goodfet.c	/^const struct device_class device_goodfet = {$/;"	v	typeref:struct:device_class
+device_id_param	devicelist.h	/^	uint8_t         device_id_param[9];$/;"	m	struct:device_table
+device_intsc	device.h	181;"	d
+device_is_fram	device.c	/^int device_is_fram(device_t dev)$/;"	f
+device_olimex	fet.c	/^const struct device_class device_olimex = {$/;"	v	typeref:struct:device_class
+device_olimex_iso	fet.c	/^const struct device_class device_olimex_iso = {$/;"	v	typeref:struct:device_class
+device_olimex_iso_mk2	fet.c	/^const struct device_class device_olimex_iso_mk2 = {$/;"	v	typeref:struct:device_class
+device_olimex_v1	fet.c	/^const struct device_class device_olimex_v1 = {$/;"	v	typeref:struct:device_class
+device_pif	pif.c	/^const struct device_class device_pif = {$/;"	v	typeref:struct:device_class
+device_poll	device.h	177;"	d
+device_probe_id	device.c	/^int device_probe_id(device_t dev)$/;"	f
+device_readmem	device.h	167;"	d
+device_rf2500	fet.c	/^const struct device_class device_rf2500 = {$/;"	v	typeref:struct:device_class
+device_search	device.h	179;"	d
+device_setbrk	device.c	/^int device_setbrk(device_t dev, int which, int enabled, address_t addr,$/;"	f
+device_setregs	device.h	173;"	d
+device_sim	sim.c	/^const struct device_class device_sim = {$/;"	v	typeref:struct:device_class
+device_status_t	device.h	/^} device_status_t;$/;"	t	typeref:enum:__anon4
+device_t	device.h	/^typedef struct device *device_t;$/;"	t	typeref:struct:device
+device_table	devicelist.h	/^struct device_table {$/;"	s
+device_tilib	tilib.c	/^const struct device_class device_tilib = {$/;"	v	typeref:struct:device_class
+device_type_id	devicelist.h	/^	uint16_t        device_type_id;$/;"	m	struct:device_table
+device_uif	fet.c	/^const struct device_class device_uif = {$/;"	v	typeref:struct:device_class
+device_writemem	device.h	169;"	d
+devicetype_t	devicelist.h	/^} devicetype_t;$/;"	t	typeref:enum:__anon1
+do_configure	fet_core.c	/^static int do_configure(struct fet_device *dev,$/;"	f	file:
+do_findUif	tilib.c	/^static int do_findUif(struct tilib_device *dev)$/;"	f	file:
+do_fw_update	tilib.c	/^static int do_fw_update(struct tilib_device *dev, const char *filename)$/;"	f	file:
+do_halt	tilib.c	/^static int do_halt(struct tilib_device *dev)$/;"	f	file:
+do_identify	fet_core.c	/^static int do_identify(struct fet_device *dev, const char *force_id)$/;"	f	file:
+do_init	tilib.c	/^static int do_init(struct tilib_device *dev, const struct device_args *args)$/;"	f	file:
+do_ppwcontrol	jtdev.c	/^static void do_ppwcontrol(struct jtdev *p)$/;"	f	file:
+do_ppwdata	jtdev.c	/^static void do_ppwdata(struct jtdev *p)$/;"	f	file:
+do_reset	gdbc.c	/^static int do_reset(struct gdb_client *dev)$/;"	f	file:
+do_reset	sim.c	/^static void do_reset(struct sim_device *dev)$/;"	f	file:
+do_run	fet_core.c	/^static int do_run(struct fet_device *dev, int type)$/;"	f	file:
+do_step	tilib.c	/^static int do_step(struct tilib_device *dev)$/;"	f	file:
+eemVersion	tilib_defs.h	/^		WORD  eemVersion;$/;"	m	struct:DEVICE_T::__anon2
+emulation	tilib_defs.h	/^		WORD  emulation;$/;"	m	struct:DEVICE_T::__anon2
+endian	tilib_defs.h	/^		WORD  endian;$/;"	m	struct:DEVICE_T::__anon2
+enter_via_dtr_rts	flash_bsl.c	/^static int enter_via_dtr_rts(struct flash_bsl_device *dev)$/;"	f	file:
+enter_via_fet	bsl.c	/^static int enter_via_fet(struct bsl_device *dev)$/;"	f	file:
+entry	sim.c	/^struct entry {$/;"	s	file:
+entry_delay	flash_bsl.c	/^static void entry_delay(void)$/;"	f	file:
+erase	device.h	/^	int (*erase)(device_t dev, device_erase_type_t type,$/;"	m	struct:device_class
+error	fet_proto.h	/^	int				error;$/;"	m	struct:fet_proto
+error_strings	fet_error.c	/^static const char *error_strings[] =$/;"	v	file:
+event_fetch	tilib.c	/^static uint32_t event_fetch(struct tilib_device *dev)$/;"	f	file:
+event_notify	tilib.c	/^static void event_notify(unsigned int msg_id, unsigned int w_param,$/;"	f	file:
+exit_via_dtr_rts	flash_bsl.c	/^static void exit_via_dtr_rts(struct flash_bsl_device *dev)$/;"	f	file:
+failed	jtdev.h	/^	int		failed;$/;"	m	struct:jtdev
+fcstab	fet_proto.c	/^static const uint16_t fcstab[256] = {$/;"	v	file:
+fet_buf	fet_proto.h	/^	uint8_t                         fet_buf[65538];$/;"	m	struct:fet_proto
+fet_ctl	fet_core.c	/^int fet_ctl(device_t dev_base, device_ctl_t action)$/;"	f
+fet_db	fet_db.c	/^static const struct fet_db_record fet_db[] = {$/;"	v	typeref:struct:fet_db_record	file:
+fet_db_enum	fet_db.c	/^int fet_db_enum(fet_db_enum_func_t func, void *user_data)$/;"	f
+fet_db_enum_func_t	fet_db.h	/^typedef int (*fet_db_enum_func_t)(void *user_data,$/;"	t
+fet_db_find_by_msg28	fet_db.c	/^const struct fet_db_record *fet_db_find_by_msg28(uint8_t *data, int len)$/;"	f
+fet_db_find_by_name	fet_db.c	/^const struct fet_db_record *fet_db_find_by_name(const char *name)$/;"	f
+fet_db_get_record	fet_olimex_db.c	/^const struct fet_olimex_db_record *fet_db_get_record(devicetype_t type)$/;"	f
+fet_db_record	fet_db.h	/^struct fet_db_record {$/;"	s
+fet_destroy	fet_core.c	/^void fet_destroy(device_t dev_base)$/;"	f
+fet_device	fet_core.c	/^struct fet_device {$/;"	s	file:
+fet_erase	fet_core.c	/^int fet_erase(device_t dev_base, device_erase_type_t type, address_t addr)$/;"	f
+fet_error	fet_error.c	/^const char *fet_error(int code)$/;"	f
+fet_flags	fet_core.c	/^	int				fet_flags;$/;"	m	struct:fet_device	file:
+fet_getregs	fet_core.c	/^int fet_getregs(device_t dev_base, address_t *regs)$/;"	f
+fet_len	fet_proto.h	/^	int                             fet_len;$/;"	m	struct:fet_proto
+fet_olimex_db	fet_olimex_db.c	/^static const struct fet_olimex_db_record fet_olimex_db[] = {$/;"	v	typeref:struct:fet_olimex_db_record	file:
+fet_olimex_db_enum	fet_olimex_db.c	/^int fet_olimex_db_enum(fet_olimex_db_enum_func_t func, void *user_data)$/;"	f
+fet_olimex_db_enum_func_t	fet_olimex_db.h	/^typedef int (*fet_olimex_db_enum_func_t)(void *user_data, const char *name);$/;"	t
+fet_olimex_db_find_by_name	fet_olimex_db.c	/^int fet_olimex_db_find_by_name(const char *name)$/;"	f
+fet_olimex_db_identify	fet_olimex_db.c	/^int fet_olimex_db_identify(const uint8_t *data)$/;"	f
+fet_olimex_db_index_to_type	fet_olimex_db.c	/^devicetype_t fet_olimex_db_index_to_type(int indx)$/;"	f
+fet_olimex_db_record	fet_olimex_db.h	/^struct fet_olimex_db_record {$/;"	s
+fet_open	fet_core.c	/^device_t fet_open(const struct device_args *args,$/;"	f
+fet_open_olimex	fet.c	/^static device_t fet_open_olimex(const struct device_args *args)$/;"	f	file:
+fet_open_olimex_iso	fet.c	/^static device_t fet_open_olimex_iso(const struct device_args *args)$/;"	f	file:
+fet_open_olimex_iso_mk2	fet.c	/^static device_t fet_open_olimex_iso_mk2(const struct device_args *args)$/;"	f	file:
+fet_open_olimex_v1	fet.c	/^static device_t fet_open_olimex_v1(const struct device_args *args)$/;"	f	file:
+fet_open_rf2500	fet.c	/^static device_t fet_open_rf2500(const struct device_args *args)$/;"	f	file:
+fet_open_uif	fet.c	/^static device_t fet_open_uif(const struct device_args *args)$/;"	f	file:
+fet_poll	fet_core.c	/^device_status_t fet_poll(device_t dev_base)$/;"	f
+fet_proto	fet_proto.h	/^struct fet_proto {$/;"	s
+fet_proto_init	fet_proto.c	/^void fet_proto_init(struct fet_proto *dev, transport_t transport,$/;"	f
+fet_proto_xfer	fet_proto.c	/^int fet_proto_xfer(struct fet_proto *dev,$/;"	f
+fet_readmem	fet_core.c	/^int fet_readmem(device_t dev_base, address_t addr, uint8_t *buffer,$/;"	f
+fet_setregs	fet_core.c	/^int fet_setregs(device_t dev_base, const address_t *regs)$/;"	f
+fet_writemem	fet_core.c	/^int fet_writemem(device_t dev_base, address_t addr,$/;"	f
+fetch_operand	sim.c	/^static int fetch_operand(struct sim_device *dev,$/;"	f	file:
+fetch_reply	bsl.c	/^static int fetch_reply(struct bsl_device *dev)$/;"	f	file:
+flags	device.h	/^	int			flags;$/;"	m	struct:device_args
+flags	device.h	/^	int			flags;$/;"	m	struct:device_breakpoint
+flash_bsl_ctl	flash_bsl.c	/^static int flash_bsl_ctl(device_t dev_base, device_ctl_t type)$/;"	f	file:
+flash_bsl_destroy	flash_bsl.c	/^static void flash_bsl_destroy(device_t dev_base)$/;"	f	file:
+flash_bsl_device	flash_bsl.c	/^struct flash_bsl_device {$/;"	s	file:
+flash_bsl_erase	flash_bsl.c	/^static int flash_bsl_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+flash_bsl_getregs	flash_bsl.c	/^static int flash_bsl_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+flash_bsl_open	flash_bsl.c	/^static device_t flash_bsl_open(const struct device_args *args)$/;"	f	file:
+flash_bsl_perror	flash_bsl.c	/^static void flash_bsl_perror(uint8_t code) {$/;"	f	file:
+flash_bsl_poll	flash_bsl.c	/^static device_status_t flash_bsl_poll(device_t dev_base)$/;"	f	file:
+flash_bsl_readmem	flash_bsl.c	/^static int flash_bsl_readmem(device_t dev_base,$/;"	f	file:
+flash_bsl_recv	flash_bsl.c	/^static int flash_bsl_recv(struct flash_bsl_device *dev,$/;"	f	file:
+flash_bsl_send	flash_bsl.c	/^static int flash_bsl_send(struct flash_bsl_device *dev,$/;"	f	file:
+flash_bsl_setregs	flash_bsl.c	/^static int flash_bsl_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+flash_bsl_unlock	flash_bsl.c	/^static int flash_bsl_unlock(struct flash_bsl_device *dev)$/;"	f	file:
+flash_bsl_writemem	flash_bsl.c	/^static int flash_bsl_writemem(device_t dev_base,$/;"	f	file:
+forced_chip_id	device.h	/^	const char		*forced_chip_id;$/;"	m	struct:device_args
+fw_progress	tilib.c	/^static void fw_progress(unsigned int msg_id, unsigned long w_param,$/;"	f	file:
+gdb	gdbc.c	/^	struct gdb_data			gdb;$/;"	m	struct:gdb_client	typeref:struct:gdb_client::gdb_data	file:
+gdb_client	gdbc.c	/^struct gdb_client {$/;"	s	file:
+gdbc_ctl	gdbc.c	/^static int gdbc_ctl(device_t dev_base, device_ctl_t op)$/;"	f	file:
+gdbc_destroy	gdbc.c	/^static void gdbc_destroy(device_t dev_base)$/;"	f	file:
+gdbc_erase	gdbc.c	/^static int gdbc_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+gdbc_getregs	gdbc.c	/^static int gdbc_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+gdbc_open	gdbc.c	/^static device_t gdbc_open(const struct device_args *args)$/;"	f	file:
+gdbc_poll	gdbc.c	/^static device_status_t gdbc_poll(device_t dev_base)$/;"	f	file:
+gdbc_readmem	gdbc.c	/^static int gdbc_readmem(device_t dev_base, address_t addr,$/;"	f	file:
+gdbc_setregs	gdbc.c	/^static int gdbc_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+gdbc_writemem	gdbc.c	/^static int gdbc_writemem(device_t dev_base, address_t addr,$/;"	f	file:
+get_adjusted_block_size	fet_core.c	/^static int get_adjusted_block_size(void)$/;"	f	file:
+get_all_funcs	tilib.c	/^static int get_all_funcs(struct tilib_device *dev)$/;"	f	file:
+get_func	tilib.c	/^static void *get_func(dynload_handle_t hnd, const char *name)$/;"	f	file:
+get_next_instr	sim.c	/^address_t get_next_instr(struct sim_device *dev)$/;"	f
+get_xfer_size	gdbc.c	/^static int get_xfer_size(void)$/;"	f	file:
+getregs	device.h	/^	int (*getregs)(device_t dev, address_t *regs);$/;"	m	struct:device_class
+goodfet	goodfet.c	/^struct goodfet {$/;"	s	file:
+goodfet_ctl	goodfet.c	/^static int goodfet_ctl(device_t dev_base, device_ctl_t type)$/;"	f	file:
+goodfet_destroy	goodfet.c	/^static void goodfet_destroy(device_t dev_base)$/;"	f	file:
+goodfet_erase	goodfet.c	/^static int goodfet_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+goodfet_getregs	goodfet.c	/^static int goodfet_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+goodfet_halt	goodfet.c	/^static int goodfet_halt(struct goodfet *gc)$/;"	f	file:
+goodfet_open	goodfet.c	/^static device_t goodfet_open(const struct device_args *args)$/;"	f	file:
+goodfet_poll	goodfet.c	/^static device_status_t goodfet_poll(device_t dev_base)$/;"	f	file:
+goodfet_readmem	goodfet.c	/^static int goodfet_readmem(device_t dev_base, address_t addr,$/;"	f	file:
+goodfet_reset	goodfet.c	/^static int goodfet_reset(struct goodfet *gc)$/;"	f	file:
+goodfet_run	goodfet.c	/^static int goodfet_run(struct goodfet *gc)$/;"	f	file:
+goodfet_setregs	goodfet.c	/^static int goodfet_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+goodfet_writemem	goodfet.c	/^static int goodfet_writemem(device_t dev_base, address_t addr,$/;"	f	file:
+hasTestVpp	tilib_defs.h	/^		WORD  hasTestVpp;$/;"	m	struct:DEVICE_T::__anon2
+help	device.h	/^	const char		*help;$/;"	m	struct:device_class
+hnd	tilib.c	/^	dynload_handle_t	hnd;$/;"	m	struct:tilib_device	file:
+id	tilib_defs.h	/^		WORD  id;$/;"	m	struct:DEVICE_T::__anon2
+identify_new	fet_core.c	/^static int identify_new(struct fet_device *dev, const char *force_id)$/;"	f	file:
+identify_old	fet_core.c	/^static int identify_old(struct fet_device *dev)$/;"	f	file:
+identify_olimex	fet_core.c	/^static int identify_olimex(struct fet_device *dev, const char *force_id)$/;"	f	file:
+infoEnd	tilib_defs.h	/^		WORD  infoEnd;$/;"	m	struct:DEVICE_T::__anon2
+infoStart	tilib_defs.h	/^		WORD  infoStart;$/;"	m	struct:DEVICE_T::__anon2
+init_device	goodfet.c	/^static int init_device(sport_t fd)$/;"	f	file:
+init_device	pif.c	/^static int init_device(struct jtdev *p)$/;"	f	file:
+instr_addr	sim.c	/^	uint16_t instr_addr; \/* used only if this is not an interrupt *\/$/;"	m	struct:search_node	file:
+instr_after_jmp	sim.c	/^uint16_t instr_after_jmp(struct sim_device *dev, uint16_t ins)$/;"	f
+interrupt_t	sim.c	/^} interrupt_t;$/;"	t	typeref:enum:__anon7	file:
+interval_shift	obl.c	/^	int		interval_shift;$/;"	m	struct:progress_meter	file:
+intsc	device.h	/^	int (*intsc)(device_t dev_base, address_t vector_addr, $/;"	m	struct:device_class
+irq	sim.c	/^	int irq;$/;"	m	struct:search_node	file:
+is_new_olimex	fet_core.c	/^static int is_new_olimex(const struct fet_device *dev)$/;"	f	file:
+is_running	gdbc.c	/^	int				is_running;$/;"	m	struct:gdb_client	file:
+jtag	pif.c	/^  struct jtdev		jtag;$/;"	m	struct:pif_device	typeref:struct:pif_device::jtdev	file:
+jtagId	tilib_defs.h	/^		BYTE  jtagId;$/;"	m	struct:DEVICE_T::__anon2
+jtag_chip_id	jtaglib.c	/^unsigned int jtag_chip_id(struct jtdev *p)$/;"	f
+jtag_dr_shift	jtaglib.c	/^static unsigned int jtag_dr_shift( struct jtdev *p, unsigned int data )$/;"	f	file:
+jtag_erase_check	jtaglib.c	/^int jtag_erase_check( struct jtdev *p,$/;"	f
+jtag_erase_flash	jtaglib.c	/^void jtag_erase_flash( struct jtdev *p, unsigned int erase_mode,$/;"	f
+jtag_execute_puc	jtaglib.c	/^unsigned int jtag_execute_puc(struct jtdev *p)$/;"	f
+jtag_get_device	jtaglib.c	/^unsigned int jtag_get_device(struct jtdev *p)$/;"	f
+jtag_halt_cpu	jtaglib.c	/^static void jtag_halt_cpu(struct jtdev *p)$/;"	f	file:
+jtag_init	jtaglib.c	/^unsigned int jtag_init (struct jtdev *p)$/;"	f
+jtag_ir_shift	jtaglib.c	/^static unsigned int jtag_ir_shift(struct jtdev *p, unsigned int instruction)$/;"	f	file:
+jtag_is_fuse_blown	jtaglib.c	/^int jtag_is_fuse_blown (struct jtdev *p)$/;"	f
+jtag_led_green_off	jtaglib.c	71;"	d	file:
+jtag_led_green_on	jtaglib.c	70;"	d	file:
+jtag_led_red_off	jtaglib.c	73;"	d	file:
+jtag_led_red_on	jtaglib.c	72;"	d	file:
+jtag_read_mem	jtaglib.c	/^uint16_t jtag_read_mem( struct jtdev *p,$/;"	f
+jtag_read_mem_quick	jtaglib.c	/^void jtag_read_mem_quick( struct jtdev *p,$/;"	f
+jtag_read_reg	jtaglib.c	/^address_t jtag_read_reg( struct jtdev *p, int reg )$/;"	f
+jtag_release_cpu	jtaglib.c	/^static void jtag_release_cpu(struct jtdev *p)$/;"	f	file:
+jtag_release_device	jtaglib.c	/^void jtag_release_device( struct jtdev *p, address_t address )$/;"	f
+jtag_reset_tap	jtaglib.c	/^static void jtag_reset_tap(struct jtdev *p)$/;"	f	file:
+jtag_rst_clr	jtaglib.c	66;"	d	file:
+jtag_rst_set	jtaglib.c	65;"	d	file:
+jtag_set_instruction_fetch	jtaglib.c	/^static int jtag_set_instruction_fetch(struct jtdev *p)$/;"	f	file:
+jtag_shift	jtaglib.c	/^static unsigned int jtag_shift( struct jtdev *p,$/;"	f	file:
+jtag_tck_clr	jtaglib.c	60;"	d	file:
+jtag_tck_set	jtaglib.c	59;"	d	file:
+jtag_tclk_clr	jtaglib.c	64;"	d	file:
+jtag_tclk_prep	jtaglib.c	/^static void jtag_tclk_prep (struct jtdev *p)$/;"	f	file:
+jtag_tclk_set	jtaglib.c	63;"	d	file:
+jtag_tdi_clr	jtaglib.c	62;"	d	file:
+jtag_tdi_set	jtaglib.c	61;"	d	file:
+jtag_tms_clr	jtaglib.c	58;"	d	file:
+jtag_tms_set	jtaglib.c	57;"	d	file:
+jtag_tst_clr	jtaglib.c	68;"	d	file:
+jtag_tst_set	jtaglib.c	67;"	d	file:
+jtag_verify_mem	jtaglib.c	/^int jtag_verify_mem( struct jtdev *p,$/;"	f
+jtag_verify_psa	jtaglib.c	/^static int jtag_verify_psa( struct jtdev *p,$/;"	f	file:
+jtag_write_flash	jtaglib.c	/^void jtag_write_flash( struct jtdev *p,$/;"	f
+jtag_write_mem	jtaglib.c	/^void jtag_write_mem( struct jtdev *p,$/;"	f
+jtag_write_mem_quick	jtaglib.c	/^void jtag_write_mem_quick( struct jtdev *p,$/;"	f
+jtag_write_reg	jtaglib.c	/^void jtag_write_reg( struct jtdev *p, int reg, address_t value )$/;"	f
+jtdev	jtdev.h	/^struct jtdev {$/;"	s
+jtdev_close	jtdev.c	/^void jtdev_close(struct jtdev *p) { }$/;"	f
+jtdev_close	jtdev.c	/^void jtdev_close(struct jtdev *p)$/;"	f
+jtdev_connect	jtdev.c	/^void jtdev_connect(struct jtdev *p) { }$/;"	f
+jtdev_connect	jtdev.c	/^void jtdev_connect(struct jtdev *p)$/;"	f
+jtdev_led_green	jtdev.c	/^void jtdev_led_green(struct jtdev *p, int out) { }$/;"	f
+jtdev_led_green	jtdev.c	/^void jtdev_led_green(struct jtdev *p, int out)$/;"	f
+jtdev_led_red	jtdev.c	/^void jtdev_led_red(struct jtdev *p, int out) { }$/;"	f
+jtdev_led_red	jtdev.c	/^void jtdev_led_red(struct jtdev *p, int out)$/;"	f
+jtdev_open	jtdev.c	/^int jtdev_open(struct jtdev *p, const char *device)$/;"	f
+jtdev_power_off	jtdev.c	/^void jtdev_power_off(struct jtdev *p) { }$/;"	f
+jtdev_power_off	jtdev.c	/^void jtdev_power_off(struct jtdev *p)$/;"	f
+jtdev_power_on	jtdev.c	/^void jtdev_power_on(struct jtdev *p) { }$/;"	f
+jtdev_power_on	jtdev.c	/^void jtdev_power_on(struct jtdev *p)$/;"	f
+jtdev_release	jtdev.c	/^void jtdev_release(struct jtdev *p) { }$/;"	f
+jtdev_release	jtdev.c	/^void jtdev_release(struct jtdev *p)$/;"	f
+jtdev_rst	jtdev.c	/^void jtdev_rst(struct jtdev *p, int out) { }$/;"	f
+jtdev_rst	jtdev.c	/^void jtdev_rst(struct jtdev *p, int out)$/;"	f
+jtdev_tck	jtdev.c	/^void jtdev_tck(struct jtdev *p, int out) { }$/;"	f
+jtdev_tck	jtdev.c	/^void jtdev_tck(struct jtdev *p, int out)$/;"	f
+jtdev_tclk	jtdev.c	/^void jtdev_tclk(struct jtdev *p, int out) { }$/;"	f
+jtdev_tclk	jtdev.c	/^void jtdev_tclk(struct jtdev *p, int out)$/;"	f
+jtdev_tclk_get	jtdev.c	/^int jtdev_tclk_get(struct jtdev *p) { return 0; }$/;"	f
+jtdev_tclk_get	jtdev.c	/^int jtdev_tclk_get(struct jtdev *p)$/;"	f
+jtdev_tclk_strobe	jtdev.c	/^void jtdev_tclk_strobe(struct jtdev *p, unsigned int count) { }$/;"	f
+jtdev_tclk_strobe	jtdev.c	/^void jtdev_tclk_strobe(struct jtdev *p, unsigned int count)$/;"	f
+jtdev_tdi	jtdev.c	/^void jtdev_tdi(struct jtdev *p, int out) { }$/;"	f
+jtdev_tdi	jtdev.c	/^void jtdev_tdi(struct jtdev *p, int out)$/;"	f
+jtdev_tdo_get	jtdev.c	/^int jtdev_tdo_get(struct jtdev *p) { return 0; }$/;"	f
+jtdev_tdo_get	jtdev.c	/^int jtdev_tdo_get(struct jtdev *p)$/;"	f
+jtdev_tms	jtdev.c	/^void jtdev_tms(struct jtdev *p, int out) { }$/;"	f
+jtdev_tms	jtdev.c	/^void jtdev_tms(struct jtdev *p, int out)$/;"	f
+jtdev_tst	jtdev.c	/^void jtdev_tst(struct jtdev *p, int out) { }$/;"	f
+jtdev_tst	jtdev.c	/^void jtdev_tst(struct jtdev *p, int out)$/;"	f
+lAddrVal	tilib_defs.h	/^	LONG              lAddrVal;$/;"	m	struct:BREAKPOINT
+lCondMask	tilib_defs.h	/^	LONG              lCondMask;$/;"	m	struct:BREAKPOINT
+lCondMdbVal	tilib_defs.h	/^	ULONG             lCondMdbVal;$/;"	m	struct:BREAKPOINT
+lMask	tilib_defs.h	/^	LONG              lMask;$/;"	m	struct:BREAKPOINT
+lRangeEndAdVa	tilib_defs.h	/^	LONG              lRangeEndAdVa;$/;"	m	struct:BREAKPOINT
+lReg	tilib_defs.h	/^	LONG              lReg;$/;"	m	struct:BREAKPOINT
+l_child	sim.c	/^	struct search_node *l_child;$/;"	m	struct:search_node	typeref:struct:search_node::search_node	file:
+last	obl.c	/^	uint32_t	last;$/;"	m	struct:progress_meter	file:
+last_bps	gdbc.c	/^	struct device_breakpoint	last_bps[DEVICE_MAX_BREAKPOINTS];$/;"	m	struct:gdb_client	typeref:struct:gdb_client::device_breakpoint	file:
+lcdEnd	tilib_defs.h	/^		WORD  lcdEnd;$/;"	m	struct:DEVICE_T::__anon2
+lcdStart	tilib_defs.h	/^		WORD  lcdStart;$/;"	m	struct:DEVICE_T::__anon2
+len	goodfet.c	/^	uint16_t	len;$/;"	m	struct:packet	file:
+load_break	tilib.c	/^static void load_break(BpParameter_t *param, address_t addr)$/;"	f	file:
+load_complex	tilib.c	/^static void load_complex(BpParameter_t *param, address_t addr,$/;"	f	file:
+load_image	obl.c	/^static int load_image(transport_t trans, const uint8_t *file_data,$/;"	f	file:
+long_password	flash_bsl.c	/^	int		long_password;$/;"	m	struct:flash_bsl_device	file:
+mailbox	tilib.c	/^	uint32_t		mailbox;$/;"	m	struct:tilib_device	file:
+mainEnd	tilib_defs.h	/^		ULONG mainEnd;$/;"	m	struct:DEVICE_T::__anon2
+mainStart	tilib_defs.h	/^		WORD  mainStart;$/;"	m	struct:DEVICE_T::__anon2
+max_breakpoints	device.h	/^	int max_breakpoints;$/;"	m	struct:device
+mb_lock	tilib.c	/^	thread_lock_t		mb_lock;$/;"	m	struct:tilib_device	file:
+memory	sim.c	/^	uint8_t                 memory[MEM_SIZE];$/;"	m	struct:sim_device	file:
+msg28_data	fet_db.h	/^	uint8_t         msg28_data[FET_DB_MSG28_LEN];$/;"	m	struct:fet_db_record
+msg29_data	fet_db.h	/^	uint8_t         msg29_data[FET_DB_MSG29_LEN];$/;"	m	struct:fet_db_record
+msg29_data	fet_olimex_db.h	/^	uint8_t         msg29_data[FET_OLIMEX_DB_MSG29_LEN];$/;"	m	struct:fet_olimex_db_record
+msg29_params	fet_db.h	/^	int             msg29_params[FET_DB_MSG29_PARAMS];$/;"	m	struct:fet_db_record
+msg29_params	fet_olimex_db.h	/^	int             msg29_params[FET_OLIMEX_DB_MSG29_PARAMS];$/;"	m	struct:fet_olimex_db_record
+msg2b_data	fet_db.h	/^	uint8_t         msg2b_data[FET_DB_MSG2B_LEN];$/;"	m	struct:fet_db_record
+msg2b_data	fet_olimex_db.h	/^	uint8_t         msg2b_data[FET_OLIMEX_DB_MSG2B_LEN];$/;"	m	struct:fet_olimex_db_record
+msg2b_len	fet_db.h	/^	int             msg2b_len;$/;"	m	struct:fet_db_record
+msg2b_len	fet_olimex_db.h	/^	int             msg2b_len;$/;"	m	struct:fet_olimex_db_record
+my_message_ids	tilib.c	/^static const MessageID_t my_message_ids = {$/;"	v	file:
+nBreakpoints	tilib_defs.h	/^		WORD  nBreakpoints;$/;"	m	struct:DEVICE_T::__anon2
+nBreakpointsDma	tilib_defs.h	/^		WORD nBreakpointsDma;$/;"	m	struct:DEVICE_T::__anon2
+nBreakpointsOptions	tilib_defs.h	/^		WORD nBreakpointsOptions;$/;"	m	struct:DEVICE_T::__anon2
+nBreakpointsReadWrite	tilib_defs.h	/^		WORD nBreakpointsReadWrite;$/;"	m	struct:DEVICE_T::__anon2
+nCombinations	tilib_defs.h	/^		WORD  nCombinations;$/;"	m	struct:DEVICE_T::__anon2
+nCycleCounter	tilib_defs.h	/^		WORD nCycleCounter;$/;"	m	struct:DEVICE_T::__anon2
+nCycleCounterOperations	tilib_defs.h	/^		WORD nCycleCounterOperations;$/;"	m	struct:DEVICE_T::__anon2
+nRegTrigger	tilib_defs.h	/^		WORD  nRegTrigger;$/;"	m	struct:DEVICE_T::__anon2
+nRegTriggerOperations	tilib_defs.h	/^		WORD nRegTriggerOperations;$/;"	m	struct:DEVICE_T::__anon2
+nSequencer	tilib_defs.h	/^		WORD nSequencer;$/;"	m	struct:DEVICE_T::__anon2
+nStateStorage	tilib_defs.h	/^		WORD nStateStorage ;$/;"	m	struct:DEVICE_T::__anon2
+name	device.h	/^	const char		*name;$/;"	m	struct:device_class
+name	devicelist.h	/^	const char	*name;$/;"	m	struct:device_table
+name	fet_db.h	/^	const char      *name;$/;"	m	struct:fet_db_record
+name	fet_olimex_db.h	/^	const char      *name;$/;"	m	struct:fet_olimex_db_record
+node	sim.c	/^  search_node *node;$/;"	m	struct:entry	file:
+obl_cmd_t	obl.c	/^} obl_cmd_t;$/;"	t	typeref:enum:__anon8	file:
+obl_get_version	obl.c	/^int obl_get_version(transport_t tr, uint32_t *ver_ret)$/;"	f
+obl_read_mem	obl.c	/^static int obl_read_mem(transport_t tr, uint32_t addr,$/;"	f	file:
+obl_reset	obl.c	/^int obl_reset(transport_t trans)$/;"	f
+obl_result_t	obl.c	/^} obl_result_t;$/;"	t	typeref:enum:__anon9	file:
+obl_update	obl.c	/^int obl_update(transport_t trans, const char *image_filename)$/;"	f
+obl_write_flash	obl.c	/^static int obl_write_flash(transport_t tr, uint32_t addr,$/;"	f	file:
+obl_xfer	obl.c	/^static int obl_xfer(transport_t tr, const uint8_t *command, int cmd_len,$/;"	f	file:
+open	device.h	/^	device_t (*open)(const struct device_args *args);$/;"	m	struct:device_class
+packet	goodfet.c	/^struct packet {$/;"	s	file:
+parent	sim.c	/^	struct search_node *parent;$/;"	m	struct:search_node	typeref:struct:search_node::search_node	file:
+parse_packet	fet_proto.c	/^static int parse_packet(struct fet_proto *dev, int plen)$/;"	f	file:
+path	device.h	/^	const char		*path;$/;"	m	struct:device_args
+pif_ctl	pif.c	/^static int pif_ctl(device_t dev_base, device_ctl_t type)$/;"	f	file:
+pif_destroy	pif.c	/^static void pif_destroy(device_t dev_base)$/;"	f	file:
+pif_device	pif.c	/^struct pif_device {$/;"	s	file:
+pif_erase	pif.c	/^static int pif_erase( device_t dev_base,$/;"	f	file:
+pif_getregs	pif.c	/^static int pif_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+pif_open	pif.c	/^static device_t pif_open(const struct device_args *args)$/;"	f	file:
+pif_poll	pif.c	/^static device_status_t pif_poll(device_t dev_base)$/;"	f	file:
+pif_readmem	pif.c	/^static int pif_readmem( device_t  dev_base,$/;"	f	file:
+pif_setregs	pif.c	/^static int pif_setregs( device_t dev_base, const address_t* regs )$/;"	f	file:
+pif_writemem	pif.c	/^static int pif_writemem( device_t       dev_base,$/;"	f	file:
+poll	device.h	/^	device_status_t (*poll)(device_t dev);$/;"	m	struct:device_class
+poll_enable	fet_core.c	/^	int				poll_enable;$/;"	m	struct:fet_device	file:
+pop	sim.c	/^struct search_node *pop () {$/;"	f
+port	jtdev.h	/^	int		port;$/;"	m	struct:jtdev
+power_buf	device.h	/^	powerbuf_t power_buf;$/;"	m	struct:device
+power_end	fet_core.c	/^static int power_end(struct fet_device *dev)$/;"	f	file:
+power_init	fet_core.c	/^static void power_init(struct fet_device *dev)$/;"	f	file:
+power_poll	fet_core.c	/^static int power_poll(struct fet_device *dev)$/;"	f	file:
+power_start	fet_core.c	/^static int power_start(struct fet_device *dev)$/;"	f	file:
+progress_init	obl.c	/^static void progress_init(struct progress_meter *m, uint32_t size)$/;"	f	file:
+progress_meter	obl.c	/^struct progress_meter {$/;"	s	file:
+progress_update	obl.c	/^static void progress_update(struct progress_meter *m, const char *label,$/;"	f	file:
+proto	fet_core.c	/^	struct fet_proto		proto;$/;"	m	struct:fet_device	typeref:struct:fet_device::fet_proto	file:
+proto_flags	fet_proto.h	/^	int				proto_flags;$/;"	m	struct:fet_proto
+push	sim.c	/^void push( struct search_node *node ) {$/;"	f
+ram2End	tilib_defs.h	/^		WORD  ram2End;$/;"	m	struct:DEVICE_T::__anon2
+ram2Start	tilib_defs.h	/^		WORD  ram2Start;$/;"	m	struct:DEVICE_T::__anon2
+ramEnd	tilib_defs.h	/^		WORD  ramEnd;$/;"	m	struct:DEVICE_T::__anon2
+ramStart	tilib_defs.h	/^		WORD  ramStart;$/;"	m	struct:DEVICE_T::__anon2
+read_byte	fet_core.c	/^static int read_byte(struct fet_device *dev, address_t addr, uint8_t *out)$/;"	f	file:
+read_file	obl.c	/^static uint8_t *read_file(const char *filename, unsigned int *len_ret)$/;"	f	file:
+read_words	goodfet.c	/^static int read_words(sport_t fd, address_t addr,$/;"	f	file:
+read_words	pif.c	/^static int read_words( struct jtdev *p, address_t addr,$/;"	f	file:
+readmem	device.h	/^	int (*readmem)(device_t dev, address_t addr,$/;"	m	struct:device_class
+recv_packet	fet_proto.c	/^static int recv_packet(struct fet_proto *dev)$/;"	f	file:
+recv_packet	goodfet.c	/^static int recv_packet(sport_t fd, struct packet *pkt)$/;"	f	file:
+refresh_bps	fet_core.c	/^static int refresh_bps(struct fet_device *dev)$/;"	f	file:
+refresh_bps	gdbc.c	/^static int refresh_bps(struct gdb_client *dev)$/;"	f	file:
+refresh_bps	tilib.c	/^static int refresh_bps(struct tilib_device *dev)$/;"	f	file:
+refresh_fperm	fet_core.c	/^static int refresh_fperm(struct fet_device *dev)$/;"	f	file:
+refresh_fperm	tilib.c	/^static int refresh_fperm(struct tilib_device *dev)$/;"	f	file:
+regs	sim.c	/^	uint16_t                regs[DEVICE_NUM_REGS];$/;"	m	struct:sim_device	file:
+reply_buf	bsl.c	/^	uint8_t         reply_buf[256];$/;"	m	struct:bsl_device	file:
+reply_len	bsl.c	/^	int             reply_len;$/;"	m	struct:bsl_device	file:
+report_error	tilib.c	/^static void report_error(struct tilib_device *dev, const char *what)$/;"	f	file:
+requested_serial	device.h	/^	const char		*requested_serial;$/;"	m	struct:device_args
+require_fwupdate	device.h	/^	const char		*require_fwupdate;$/;"	m	struct:device_args
+reset_sequence	goodfet.c	/^static int reset_sequence(sport_t fd)$/;"	f	file:
+running	sim.c	/^	int                     running;$/;"	m	struct:sim_device	file:
+saved_state	sim.c	/^	struct sim_device *saved_state;$/;"	m	struct:search_node	typeref:struct:search_node::sim_device	file:
+sdeviceID	devicelist.c	/^const struct device_table sdeviceID[289] =$/;"	v	typeref:struct:device_table
+search	device.h	/^	int (*search)(device_t dev_base, address_t num_instr, int is_reg, $/;"	m	struct:device_class
+search_node	sim.c	/^typedef struct search_node {$/;"	s	file:
+search_node	sim.c	/^} search_node;$/;"	t	typeref:struct:search_node	file:
+send_command	bsl.c	/^static int send_command(struct bsl_device *dev,$/;"	f	file:
+send_command	fet_proto.c	/^static int send_command(struct fet_proto *dev, int command_code,$/;"	f	file:
+send_packet	goodfet.c	/^static int send_packet(sport_t fd,$/;"	f	file:
+send_rf2500_data	fet_proto.c	/^static int send_rf2500_data(struct fet_proto *dev,$/;"	f	file:
+serial	bsl.c	/^	transport_t     serial;$/;"	m	struct:bsl_device	file:
+serial_fd	flash_bsl.c	/^	sport_t		serial_fd;$/;"	m	struct:flash_bsl_device	file:
+serial_fd	goodfet.c	/^	sport_t			serial_fd;$/;"	m	struct:goodfet	file:
+setregs	device.h	/^	int (*setregs)(device_t dev, const address_t *regs);$/;"	m	struct:device_class
+shell_power	fet_core.c	/^static void shell_power(const uint8_t *data, int len)$/;"	f	file:
+show_dev_info	fet_core.c	/^static void show_dev_info(const char *name, const struct fet_device *dev)$/;"	f	file:
+sibling	sim.c	/^	struct search_node *sibling;$/;"	m	struct:search_node	typeref:struct:search_node::search_node	file:
+sim_ctl	sim.c	/^static int sim_ctl(device_t dev_base, device_ctl_t op)$/;"	f	file:
+sim_destroy	sim.c	/^static void sim_destroy(device_t dev_base)$/;"	f	file:
+sim_device	sim.c	/^struct sim_device {$/;"	s	file:
+sim_erase	sim.c	/^static int sim_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+sim_getregs	sim.c	/^static int sim_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+sim_intsc	sim.c	/^static int sim_intsc(device_t dev_base, address_t vector_addr,$/;"	f	file:
+sim_open	sim.c	/^static device_t sim_open(const struct device_args *args)$/;"	f	file:
+sim_poll	sim.c	/^static device_status_t sim_poll(device_t dev_base)$/;"	f	file:
+sim_readmem	sim.c	/^static int sim_readmem(device_t dev_base, address_t addr,$/;"	f	file:
+sim_search	sim.c	/^static int sim_search(device_t dev_base, address_t n, $/;"	f	file:
+sim_setregs	sim.c	/^static int sim_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+sim_writemem	sim.c	/^static int sim_writemem(device_t dev_base, address_t addr,$/;"	f	file:
+state	fet_proto.h	/^	int				state;$/;"	m	struct:fet_proto
+step_cpu	sim.c	/^static int step_cpu(struct sim_device *dev)$/;"	f	file:
+step_double	sim.c	/^static int step_double(struct sim_device *dev, uint16_t ins)$/;"	f	file:
+step_jump	sim.c	/^static int step_jump(struct sim_device *dev, uint16_t ins)$/;"	f	file:
+step_single	sim.c	/^static int step_single(struct sim_device *dev, uint16_t ins)$/;"	f	file:
+step_system	sim.c	/^static int step_system(struct sim_device *dev)$/;"	f	file:
+store_operand	sim.c	/^static int store_operand(struct sim_device *dev,$/;"	f	file:
+string	tilib_defs.h	/^		BYTE  string[32];$/;"	m	struct:DEVICE_T::__anon2
+ti_erase_type	tilib.c	/^static long ti_erase_type(device_erase_type_t e)$/;"	f	file:
+tilib_ctl	tilib.c	/^static int tilib_ctl(device_t dev_base, device_ctl_t op)$/;"	f	file:
+tilib_destroy	tilib.c	/^static void tilib_destroy(device_t dev_base)$/;"	f	file:
+tilib_device	tilib.c	/^struct tilib_device {$/;"	s	file:
+tilib_erase	tilib.c	/^static int tilib_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+tilib_filename	tilib.c	/^static const char tilib_filename[] = "MSP430.DLL";$/;"	v	file:
+tilib_filename	tilib.c	/^static const char tilib_filename[] = "libmsp430.so";$/;"	v	file:
+tilib_getregs	tilib.c	/^static int tilib_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+tilib_open	tilib.c	/^static device_t tilib_open(const struct device_args *args)$/;"	f	file:
+tilib_poll	tilib.c	/^static device_status_t tilib_poll(device_t dev_base)$/;"	f	file:
+tilib_readmem	tilib.c	/^static int tilib_readmem(device_t dev_base, address_t addr,$/;"	f	file:
+tilib_setregs	tilib.c	/^static int tilib_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+tilib_writemem	tilib.c	/^static int tilib_writemem(device_t dev_base, address_t addr,$/;"	f	file:
+total	obl.c	/^	uint32_t	total;$/;"	m	struct:progress_meter	file:
+transport	fet_proto.h	/^	transport_t			transport;$/;"	m	struct:fet_proto
+transport_read_all	obl.c	/^static int transport_read_all(transport_t tr, uint8_t *data, int len)$/;"	f	file:
+trigger_interrupt	sim.c	/^void trigger_interrupt(struct sim_device *dev, int irq)$/;"	f
+trigger_interrupt_set_flags	sim.c	/^void trigger_interrupt_set_flags(struct sim_device *dev, int irq, interrupt_t type)$/;"	f
+try_new	fet_core.c	/^static int try_new(struct fet_device *dev, const char *force_id)$/;"	f	file:
+try_open	fet_core.c	/^int try_open(struct fet_device *dev, const struct device_args *args,$/;"	f
+type	device.h	/^	const struct device_class	*type;$/;"	m	struct:device	typeref:struct:device::device_class
+type	device.h	/^	device_bptype_t		type;$/;"	m	struct:device_breakpoint
+type	sim.c	/^	interrupt_t type;$/;"	m	struct:search_node	file:
+uiMsgIdBreakpoint	tilib_defs.h	/^	ULONG	uiMsgIdBreakpoint;$/;"	m	struct:MESSAGE_ID
+uiMsgIdCPUStopped	tilib_defs.h	/^	ULONG	uiMsgIdCPUStopped;$/;"	m	struct:MESSAGE_ID
+uiMsgIdSingleStep	tilib_defs.h	/^	ULONG	uiMsgIdSingleStep;$/;"	m	struct:MESSAGE_ID
+uiMsgIdState	tilib_defs.h	/^	ULONG	uiMsgIdState;$/;"	m	struct:MESSAGE_ID
+uiMsgIdStorage	tilib_defs.h	/^	ULONG	uiMsgIdStorage;$/;"	m	struct:MESSAGE_ID
+uiMsgIdWarning	tilib_defs.h	/^	ULONG	uiMsgIdWarning;$/;"	m	struct:MESSAGE_ID
+uifPath	tilib.c	/^	char			uifPath[1024];$/;"	m	struct:tilib_device	file:
+vccMaxOp	tilib_defs.h	/^		WORD  vccMaxOp;$/;"	m	struct:DEVICE_T::__anon2
+vccMinOp	tilib_defs.h	/^		WORD  vccMinOp;$/;"	m	struct:DEVICE_T::__anon2
+vcc_mv	device.h	/^	int			vcc_mv;$/;"	m	struct:device_args
+verb	goodfet.c	/^	uint8_t		verb;$/;"	m	struct:packet	file:
+verify_checksum	bsl.c	/^static int verify_checksum(struct bsl_device *dev)$/;"	f	file:
+verify_image	obl.c	/^static int verify_image(transport_t tr, uint32_t addr, uint32_t size,$/;"	f	file:
+version	fet_core.c	/^	int                             version;$/;"	m	struct:fet_device	file:
+wExtCombine	tilib_defs.h	/^	WORD              wExtCombine;$/;"	m	struct:BREAKPOINT
+watchpoint_check	sim.c	/^static void watchpoint_check(struct sim_device *dev, uint16_t addr,$/;"	f	file:
+watchpoint_hit	sim.c	/^	int			watchpoint_hit;$/;"	m	struct:sim_device	file:
+write_byte	fet_core.c	/^static int write_byte(struct fet_device *dev, address_t addr, uint8_t value)$/;"	f	file:
+write_byte	goodfet.c	/^static int write_byte(sport_t fd, address_t addr, uint8_t value)$/;"	f	file:
+write_byte	pif.c	/^static int write_byte( struct jtdev *p,$/;"	f	file:
+write_flash_block	goodfet.c	/^static int write_flash_block(sport_t fd, address_t addr,$/;"	f	file:
+write_flash_block	pif.c	/^static int write_flash_block( struct jtdev *p, address_t addr,$/;"	f	file:
+write_image	obl.c	/^static int write_image(transport_t tr, uint32_t addr, uint32_t size,$/;"	f	file:
+write_ram_word	goodfet.c	/^static int write_ram_word(sport_t fd, address_t addr, uint16_t value)$/;"	f	file:
+write_ram_word	pif.c	/^int write_ram_word( struct jtdev *p, address_t addr,$/;"	f
+write_valid_size	obl.c	/^static int write_valid_size(transport_t tr, uint32_t size)$/;"	f	file:
+writemem	device.h	/^	int (*writemem)(device_t dev, address_t addr,$/;"	m	struct:device_class
+xfer	goodfet.c	/^static int xfer(sport_t fd,$/;"	f	file:
diff -ruN mspdebug-0.22/drivers/.tags_sorted_by_file mspdebug-0.22-new/drivers/.tags_sorted_by_file
--- mspdebug-0.22/drivers/.tags_sorted_by_file	1969-12-31 19:00:00.000000000 -0500
+++ mspdebug-0.22-new/drivers/.tags_sorted_by_file	2014-03-04 01:54:08.781212000 -0500
@@ -0,0 +1,1232 @@
+!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
+!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
+!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
+!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
+!_TAG_PROGRAM_NAME	Exuberant Ctags	//
+CMD_ERASE	bsl.c	199;"	d	file:
+CMD_RESET	bsl.c	201;"	d	file:
+CMD_RX_DATA	bsl.c	200;"	d	file:
+CMD_TX_DATA	bsl.c	198;"	d	file:
+DATA_ACK	bsl.c	44;"	d	file:
+DATA_HDR	bsl.c	43;"	d	file:
+DATA_NAK	bsl.c	45;"	d	file:
+base	bsl.c	/^	struct device   base;$/;"	m	struct:bsl_device	typeref:struct:bsl_device::device	file:
+bsl_ack	bsl.c	/^static int bsl_ack(struct bsl_device *dev)$/;"	f	file:
+bsl_ctl	bsl.c	/^static int bsl_ctl(device_t dev_base, device_ctl_t type)$/;"	f	file:
+bsl_destroy	bsl.c	/^static void bsl_destroy(device_t dev_base)$/;"	f	file:
+bsl_device	bsl.c	/^struct bsl_device {$/;"	s	file:
+bsl_erase	bsl.c	/^static int bsl_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+bsl_getregs	bsl.c	/^static int bsl_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+bsl_open	bsl.c	/^static device_t bsl_open(const struct device_args *args)$/;"	f	file:
+bsl_poll	bsl.c	/^static device_status_t bsl_poll(device_t dev_base)$/;"	f	file:
+bsl_readmem	bsl.c	/^static int bsl_readmem(device_t dev_base,$/;"	f	file:
+bsl_setregs	bsl.c	/^static int bsl_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+bsl_sync	bsl.c	/^static int bsl_sync(struct bsl_device *dev)$/;"	f	file:
+bsl_writemem	bsl.c	/^static int bsl_writemem(device_t dev_base,$/;"	f	file:
+bsl_xfer	bsl.c	/^static int bsl_xfer(struct bsl_device *dev,$/;"	f	file:
+device_bsl	bsl.c	/^const struct device_class device_bsl = {$/;"	v	typeref:struct:device_class
+enter_via_fet	bsl.c	/^static int enter_via_fet(struct bsl_device *dev)$/;"	f	file:
+fetch_reply	bsl.c	/^static int fetch_reply(struct bsl_device *dev)$/;"	f	file:
+reply_buf	bsl.c	/^	uint8_t         reply_buf[256];$/;"	m	struct:bsl_device	file:
+reply_len	bsl.c	/^	int             reply_len;$/;"	m	struct:bsl_device	file:
+send_command	bsl.c	/^static int send_command(struct bsl_device *dev,$/;"	f	file:
+serial	bsl.c	/^	transport_t     serial;$/;"	m	struct:bsl_device	file:
+verify_checksum	bsl.c	/^static int verify_checksum(struct bsl_device *dev)$/;"	f	file:
+BSL_H_	bsl.h	20;"	d
+addbrk	device.c	/^static int addbrk(device_t dev, address_t addr, device_bptype_t type)$/;"	f	file:
+delbrk	device.c	/^static void delbrk(device_t dev, address_t addr, device_bptype_t type)$/;"	f	file:
+device_default	device.c	/^device_t device_default;$/;"	v
+device_erase	device.c	/^int device_erase(device_erase_type_t et, address_t addr)$/;"	f
+device_is_fram	device.c	/^int device_is_fram(device_t dev)$/;"	f
+device_probe_id	device.c	/^int device_probe_id(device_t dev)$/;"	f
+device_setbrk	device.c	/^int device_setbrk(device_t dev, int which, int enabled, address_t addr,$/;"	f
+DEVICE_BPTYPE_BREAK	device.h	/^	DEVICE_BPTYPE_BREAK,$/;"	e	enum:__anon6
+DEVICE_BPTYPE_READ	device.h	/^	DEVICE_BPTYPE_READ,$/;"	e	enum:__anon6
+DEVICE_BPTYPE_WATCH	device.h	/^	DEVICE_BPTYPE_WATCH,$/;"	e	enum:__anon6
+DEVICE_BPTYPE_WRITE	device.h	/^	DEVICE_BPTYPE_WRITE$/;"	e	enum:__anon6
+DEVICE_BP_DIRTY	device.h	53;"	d
+DEVICE_BP_ENABLED	device.h	52;"	d
+DEVICE_CTL_HALT	device.h	/^	DEVICE_CTL_HALT,$/;"	e	enum:__anon3
+DEVICE_CTL_RESET	device.h	/^	DEVICE_CTL_RESET,$/;"	e	enum:__anon3
+DEVICE_CTL_RUN	device.h	/^	DEVICE_CTL_RUN,$/;"	e	enum:__anon3
+DEVICE_CTL_STEP	device.h	/^	DEVICE_CTL_STEP$/;"	e	enum:__anon3
+DEVICE_ERASE_ALL	device.h	/^	DEVICE_ERASE_ALL,$/;"	e	enum:__anon5
+DEVICE_ERASE_MAIN	device.h	/^	DEVICE_ERASE_MAIN,$/;"	e	enum:__anon5
+DEVICE_ERASE_SEGMENT	device.h	/^	DEVICE_ERASE_SEGMENT$/;"	e	enum:__anon5
+DEVICE_FLAG_DO_FWUPDATE	device.h	72;"	d
+DEVICE_FLAG_FORCE_RESET	device.h	71;"	d
+DEVICE_FLAG_JTAG	device.h	68;"	d
+DEVICE_FLAG_LONG_PW	device.h	69;"	d
+DEVICE_FLAG_SKIP_CLOSE	device.h	73;"	d
+DEVICE_FLAG_TTY	device.h	70;"	d
+DEVICE_H_	device.h	20;"	d
+DEVICE_MAX_BREAKPOINTS	device.h	50;"	d
+DEVICE_NUM_REGS	device.h	49;"	d
+DEVICE_STATUS_ERROR	device.h	/^	DEVICE_STATUS_ERROR$/;"	e	enum:__anon4
+DEVICE_STATUS_HALTED	device.h	/^	DEVICE_STATUS_HALTED,$/;"	e	enum:__anon4
+DEVICE_STATUS_INTR	device.h	/^	DEVICE_STATUS_INTR,$/;"	e	enum:__anon4
+DEVICE_STATUS_RUNNING	device.h	/^	DEVICE_STATUS_RUNNING,$/;"	e	enum:__anon4
+addr	device.h	/^	address_t		addr;$/;"	m	struct:device_breakpoint
+breakpoints	device.h	/^	struct device_breakpoint breakpoints[DEVICE_MAX_BREAKPOINTS];$/;"	m	struct:device	typeref:struct:device::device_breakpoint
+ctl	device.h	/^	int (*ctl)(device_t dev, device_ctl_t op);$/;"	m	struct:device_class
+destroy	device.h	/^	void (*destroy)(device_t dev);$/;"	m	struct:device_class
+dev_id	device.h	/^	uint8_t				dev_id[3];$/;"	m	struct:device
+device	device.h	/^struct device {$/;"	s
+device_args	device.h	/^struct device_args {$/;"	s
+device_bptype_t	device.h	/^} device_bptype_t;$/;"	t	typeref:enum:__anon6
+device_breakpoint	device.h	/^struct device_breakpoint {$/;"	s
+device_class	device.h	/^struct device_class {$/;"	s
+device_ctl	device.h	175;"	d
+device_ctl_t	device.h	/^} device_ctl_t;$/;"	t	typeref:enum:__anon3
+device_destroy	device.h	166;"	d
+device_erase_type_t	device.h	/^} device_erase_type_t;$/;"	t	typeref:enum:__anon5
+device_getregs	device.h	171;"	d
+device_intsc	device.h	181;"	d
+device_poll	device.h	177;"	d
+device_readmem	device.h	167;"	d
+device_search	device.h	179;"	d
+device_setregs	device.h	173;"	d
+device_status_t	device.h	/^} device_status_t;$/;"	t	typeref:enum:__anon4
+device_t	device.h	/^typedef struct device *device_t;$/;"	t	typeref:struct:device
+device_writemem	device.h	169;"	d
+erase	device.h	/^	int (*erase)(device_t dev, device_erase_type_t type,$/;"	m	struct:device_class
+flags	device.h	/^	int			flags;$/;"	m	struct:device_args
+flags	device.h	/^	int			flags;$/;"	m	struct:device_breakpoint
+forced_chip_id	device.h	/^	const char		*forced_chip_id;$/;"	m	struct:device_args
+getregs	device.h	/^	int (*getregs)(device_t dev, address_t *regs);$/;"	m	struct:device_class
+help	device.h	/^	const char		*help;$/;"	m	struct:device_class
+intsc	device.h	/^	int (*intsc)(device_t dev_base, address_t vector_addr, $/;"	m	struct:device_class
+max_breakpoints	device.h	/^	int max_breakpoints;$/;"	m	struct:device
+name	device.h	/^	const char		*name;$/;"	m	struct:device_class
+open	device.h	/^	device_t (*open)(const struct device_args *args);$/;"	m	struct:device_class
+path	device.h	/^	const char		*path;$/;"	m	struct:device_args
+poll	device.h	/^	device_status_t (*poll)(device_t dev);$/;"	m	struct:device_class
+power_buf	device.h	/^	powerbuf_t power_buf;$/;"	m	struct:device
+readmem	device.h	/^	int (*readmem)(device_t dev, address_t addr,$/;"	m	struct:device_class
+requested_serial	device.h	/^	const char		*requested_serial;$/;"	m	struct:device_args
+require_fwupdate	device.h	/^	const char		*require_fwupdate;$/;"	m	struct:device_args
+search	device.h	/^	int (*search)(device_t dev_base, address_t num_instr, int is_reg, $/;"	m	struct:device_class
+setregs	device.h	/^	int (*setregs)(device_t dev, const address_t *regs);$/;"	m	struct:device_class
+type	device.h	/^	const struct device_class	*type;$/;"	m	struct:device	typeref:struct:device::device_class
+type	device.h	/^	device_bptype_t		type;$/;"	m	struct:device_breakpoint
+vcc_mv	device.h	/^	int			vcc_mv;$/;"	m	struct:device_args
+writemem	device.h	/^	int (*writemem)(device_t dev, address_t addr,$/;"	m	struct:device_class
+sdeviceID	devicelist.c	/^const struct device_table sdeviceID[289] =$/;"	v	typeref:struct:device_table
+DEVICELIST_H_	devicelist.h	21;"	d
+DT_CC430F5123	devicelist.h	/^	DT_CC430F5123,$/;"	e	enum:__anon1
+DT_CC430F5125	devicelist.h	/^	DT_CC430F5125,$/;"	e	enum:__anon1
+DT_CC430F5133	devicelist.h	/^	DT_CC430F5133,$/;"	e	enum:__anon1
+DT_CC430F5135	devicelist.h	/^	DT_CC430F5135,$/;"	e	enum:__anon1
+DT_CC430F5137	devicelist.h	/^	DT_CC430F5137,$/;"	e	enum:__anon1
+DT_CC430F5143	devicelist.h	/^	DT_CC430F5143,$/;"	e	enum:__anon1
+DT_CC430F5145	devicelist.h	/^	DT_CC430F5145,$/;"	e	enum:__anon1
+DT_CC430F5147	devicelist.h	/^	DT_CC430F5147,$/;"	e	enum:__anon1
+DT_CC430F6125	devicelist.h	/^	DT_CC430F6125,$/;"	e	enum:__anon1
+DT_CC430F6126	devicelist.h	/^	DT_CC430F6126,$/;"	e	enum:__anon1
+DT_CC430F6127	devicelist.h	/^	DT_CC430F6127,$/;"	e	enum:__anon1
+DT_CC430F6135	devicelist.h	/^	DT_CC430F6135,$/;"	e	enum:__anon1
+DT_CC430F6137	devicelist.h	/^	DT_CC430F6137,$/;"	e	enum:__anon1
+DT_CC430F6143	devicelist.h	/^	DT_CC430F6143,$/;"	e	enum:__anon1
+DT_CC430F6145	devicelist.h	/^	DT_CC430F6145,$/;"	e	enum:__anon1
+DT_CC430F6147	devicelist.h	/^	DT_CC430F6147,$/;"	e	enum:__anon1
+DT_END	devicelist.h	/^	DT_END$/;"	e	enum:__anon1
+DT_MSP430AFE220	devicelist.h	/^	DT_MSP430AFE220,$/;"	e	enum:__anon1
+DT_MSP430AFE221	devicelist.h	/^	DT_MSP430AFE221,$/;"	e	enum:__anon1
+DT_MSP430AFE222	devicelist.h	/^	DT_MSP430AFE222,$/;"	e	enum:__anon1
+DT_MSP430AFE223	devicelist.h	/^	DT_MSP430AFE223,$/;"	e	enum:__anon1
+DT_MSP430AFE230	devicelist.h	/^	DT_MSP430AFE230,$/;"	e	enum:__anon1
+DT_MSP430AFE231	devicelist.h	/^	DT_MSP430AFE231,$/;"	e	enum:__anon1
+DT_MSP430AFE232	devicelist.h	/^	DT_MSP430AFE232,$/;"	e	enum:__anon1
+DT_MSP430AFE233	devicelist.h	/^	DT_MSP430AFE233,$/;"	e	enum:__anon1
+DT_MSP430AFE250	devicelist.h	/^	DT_MSP430AFE250,$/;"	e	enum:__anon1
+DT_MSP430AFE251	devicelist.h	/^	DT_MSP430AFE251,$/;"	e	enum:__anon1
+DT_MSP430AFE252	devicelist.h	/^	DT_MSP430AFE252,$/;"	e	enum:__anon1
+DT_MSP430AFE253	devicelist.h	/^	DT_MSP430AFE253,$/;"	e	enum:__anon1
+DT_MSP430F11x1	devicelist.h	/^	DT_MSP430F11x1,$/;"	e	enum:__anon1
+DT_MSP430F11x1A	devicelist.h	/^	DT_MSP430F11x1A,$/;"	e	enum:__anon1
+DT_MSP430F11x1D	devicelist.h	/^	DT_MSP430F11x1D,$/;"	e	enum:__anon1
+DT_MSP430F11x2	devicelist.h	/^	DT_MSP430F11x2,$/;"	e	enum:__anon1
+DT_MSP430F12x	devicelist.h	/^	DT_MSP430F12x,$/;"	e	enum:__anon1
+DT_MSP430F12x2	devicelist.h	/^	DT_MSP430F12x2,$/;"	e	enum:__anon1
+DT_MSP430F12x2C	devicelist.h	/^	DT_MSP430F12x2C,$/;"	e	enum:__anon1
+DT_MSP430F12x2New	devicelist.h	/^	DT_MSP430F12x2New,$/;"	e	enum:__anon1
+DT_MSP430F133	devicelist.h	/^	DT_MSP430F133,$/;"	e	enum:__anon1
+DT_MSP430F135	devicelist.h	/^	DT_MSP430F135,$/;"	e	enum:__anon1
+DT_MSP430F147	devicelist.h	/^	DT_MSP430F147,$/;"	e	enum:__anon1
+DT_MSP430F148	devicelist.h	/^	DT_MSP430F148,$/;"	e	enum:__anon1
+DT_MSP430F149	devicelist.h	/^	DT_MSP430F149,$/;"	e	enum:__anon1
+DT_MSP430F155	devicelist.h	/^	DT_MSP430F155,$/;"	e	enum:__anon1
+DT_MSP430F156	devicelist.h	/^	DT_MSP430F156,$/;"	e	enum:__anon1
+DT_MSP430F157	devicelist.h	/^	DT_MSP430F157,$/;"	e	enum:__anon1
+DT_MSP430F1610	devicelist.h	/^	DT_MSP430F1610,$/;"	e	enum:__anon1
+DT_MSP430F1611	devicelist.h	/^	DT_MSP430F1611,$/;"	e	enum:__anon1
+DT_MSP430F1612	devicelist.h	/^	DT_MSP430F1612,$/;"	e	enum:__anon1
+DT_MSP430F167	devicelist.h	/^	DT_MSP430F167,$/;"	e	enum:__anon1
+DT_MSP430F168	devicelist.h	/^	DT_MSP430F168,$/;"	e	enum:__anon1
+DT_MSP430F169	devicelist.h	/^	DT_MSP430F169,$/;"	e	enum:__anon1
+DT_MSP430F20x1	devicelist.h	/^	DT_MSP430F20x1,$/;"	e	enum:__anon1
+DT_MSP430F20x2	devicelist.h	/^	DT_MSP430F20x2,$/;"	e	enum:__anon1
+DT_MSP430F20x3	devicelist.h	/^	DT_MSP430F20x3,$/;"	e	enum:__anon1
+DT_MSP430F2112	devicelist.h	/^	DT_MSP430F2112,$/;"	e	enum:__anon1
+DT_MSP430F2122	devicelist.h	/^	DT_MSP430F2122,$/;"	e	enum:__anon1
+DT_MSP430F2132	devicelist.h	/^	DT_MSP430F2132,$/;"	e	enum:__anon1
+DT_MSP430F21x1	devicelist.h	/^	DT_MSP430F21x1,$/;"	e	enum:__anon1
+DT_MSP430F2232	devicelist.h	/^	DT_MSP430F2232,$/;"	e	enum:__anon1
+DT_MSP430F2234	devicelist.h	/^	DT_MSP430F2234,$/;"	e	enum:__anon1
+DT_MSP430F2252	devicelist.h	/^	DT_MSP430F2252,$/;"	e	enum:__anon1
+DT_MSP430F2254	devicelist.h	/^	DT_MSP430F2254,$/;"	e	enum:__anon1
+DT_MSP430F2272	devicelist.h	/^	DT_MSP430F2272,$/;"	e	enum:__anon1
+DT_MSP430F2274	devicelist.h	/^	DT_MSP430F2274,$/;"	e	enum:__anon1
+DT_MSP430F233	devicelist.h	/^	DT_MSP430F233,$/;"	e	enum:__anon1
+DT_MSP430F2330	devicelist.h	/^	DT_MSP430F2330,$/;"	e	enum:__anon1
+DT_MSP430F235	devicelist.h	/^	DT_MSP430F235,$/;"	e	enum:__anon1
+DT_MSP430F2350	devicelist.h	/^	DT_MSP430F2350,$/;"	e	enum:__anon1
+DT_MSP430F2370	devicelist.h	/^	DT_MSP430F2370,$/;"	e	enum:__anon1
+DT_MSP430F2410	devicelist.h	/^	DT_MSP430F2410,$/;"	e	enum:__anon1
+DT_MSP430F2418	devicelist.h	/^	DT_MSP430F2418,$/;"	e	enum:__anon1
+DT_MSP430F2419	devicelist.h	/^	DT_MSP430F2419,$/;"	e	enum:__anon1
+DT_MSP430F247	devicelist.h	/^	DT_MSP430F247,$/;"	e	enum:__anon1
+DT_MSP430F2471	devicelist.h	/^	DT_MSP430F2471,$/;"	e	enum:__anon1
+DT_MSP430F248	devicelist.h	/^	DT_MSP430F248,$/;"	e	enum:__anon1
+DT_MSP430F2481	devicelist.h	/^	DT_MSP430F2481,$/;"	e	enum:__anon1
+DT_MSP430F249	devicelist.h	/^	DT_MSP430F249,$/;"	e	enum:__anon1
+DT_MSP430F2491	devicelist.h	/^	DT_MSP430F2491,$/;"	e	enum:__anon1
+DT_MSP430F2618	devicelist.h	/^	DT_MSP430F2618,$/;"	e	enum:__anon1
+DT_MSP430F2619	devicelist.h	/^	DT_MSP430F2619,$/;"	e	enum:__anon1
+DT_MSP430F4132	devicelist.h	/^	DT_MSP430F4132,$/;"	e	enum:__anon1
+DT_MSP430F413P	devicelist.h	/^	DT_MSP430F413P,$/;"	e	enum:__anon1
+DT_MSP430F4152	devicelist.h	/^	DT_MSP430F4152,$/;"	e	enum:__anon1
+DT_MSP430F41xC	devicelist.h	/^	DT_MSP430F41xC,$/;"	e	enum:__anon1
+DT_MSP430F423	devicelist.h	/^	DT_MSP430F423,$/;"	e	enum:__anon1
+DT_MSP430F4230	devicelist.h	/^	DT_MSP430F4230,$/;"	e	enum:__anon1
+DT_MSP430F423A	devicelist.h	/^	DT_MSP430F423A,$/;"	e	enum:__anon1
+DT_MSP430F425	devicelist.h	/^	DT_MSP430F425,$/;"	e	enum:__anon1
+DT_MSP430F4250	devicelist.h	/^	DT_MSP430F4250,$/;"	e	enum:__anon1
+DT_MSP430F425A	devicelist.h	/^	DT_MSP430F425A,$/;"	e	enum:__anon1
+DT_MSP430F427	devicelist.h	/^	DT_MSP430F427,$/;"	e	enum:__anon1
+DT_MSP430F427A	devicelist.h	/^	DT_MSP430F427A,$/;"	e	enum:__anon1
+DT_MSP430F42x0	devicelist.h	/^	DT_MSP430F42x0,$/;"	e	enum:__anon1
+DT_MSP430F43x	devicelist.h	/^	DT_MSP430F43x,$/;"	e	enum:__anon1
+DT_MSP430F44x	devicelist.h	/^	DT_MSP430F44x,$/;"	e	enum:__anon1
+DT_MSP430F47166	devicelist.h	/^	DT_MSP430F47166,$/;"	e	enum:__anon1
+DT_MSP430F47167	devicelist.h	/^	DT_MSP430F47167,$/;"	e	enum:__anon1
+DT_MSP430F47176	devicelist.h	/^	DT_MSP430F47176,$/;"	e	enum:__anon1
+DT_MSP430F47177	devicelist.h	/^	DT_MSP430F47177,$/;"	e	enum:__anon1
+DT_MSP430F47186	devicelist.h	/^	DT_MSP430F47186,$/;"	e	enum:__anon1
+DT_MSP430F47187	devicelist.h	/^	DT_MSP430F47187,$/;"	e	enum:__anon1
+DT_MSP430F47196	devicelist.h	/^	DT_MSP430F47196,$/;"	e	enum:__anon1
+DT_MSP430F47197	devicelist.h	/^	DT_MSP430F47197,$/;"	e	enum:__anon1
+DT_MSP430F477	devicelist.h	/^	DT_MSP430F477,$/;"	e	enum:__anon1
+DT_MSP430F478	devicelist.h	/^	DT_MSP430F478,$/;"	e	enum:__anon1
+DT_MSP430F4783	devicelist.h	/^	DT_MSP430F4783,$/;"	e	enum:__anon1
+DT_MSP430F4784	devicelist.h	/^	DT_MSP430F4784,$/;"	e	enum:__anon1
+DT_MSP430F479	devicelist.h	/^	DT_MSP430F479,$/;"	e	enum:__anon1
+DT_MSP430F4793	devicelist.h	/^	DT_MSP430F4793,$/;"	e	enum:__anon1
+DT_MSP430F4794	devicelist.h	/^	DT_MSP430F4794,$/;"	e	enum:__anon1
+DT_MSP430F5131	devicelist.h	/^	DT_MSP430F5131,$/;"	e	enum:__anon1
+DT_MSP430F5132	devicelist.h	/^	DT_MSP430F5132,$/;"	e	enum:__anon1
+DT_MSP430F5151	devicelist.h	/^	DT_MSP430F5151,$/;"	e	enum:__anon1
+DT_MSP430F5152	devicelist.h	/^	DT_MSP430F5152,$/;"	e	enum:__anon1
+DT_MSP430F5171	devicelist.h	/^	DT_MSP430F5171,$/;"	e	enum:__anon1
+DT_MSP430F5172	devicelist.h	/^	DT_MSP430F5172,$/;"	e	enum:__anon1
+DT_MSP430F5212	devicelist.h	/^	DT_MSP430F5212,$/;"	e	enum:__anon1
+DT_MSP430F5213	devicelist.h	/^	DT_MSP430F5213,$/;"	e	enum:__anon1
+DT_MSP430F5214	devicelist.h	/^	DT_MSP430F5214,$/;"	e	enum:__anon1
+DT_MSP430F5217	devicelist.h	/^	DT_MSP430F5217,$/;"	e	enum:__anon1
+DT_MSP430F5218	devicelist.h	/^	DT_MSP430F5218,$/;"	e	enum:__anon1
+DT_MSP430F5219	devicelist.h	/^	DT_MSP430F5219,$/;"	e	enum:__anon1
+DT_MSP430F5222	devicelist.h	/^	DT_MSP430F5222,$/;"	e	enum:__anon1
+DT_MSP430F5223	devicelist.h	/^	DT_MSP430F5223,$/;"	e	enum:__anon1
+DT_MSP430F5224	devicelist.h	/^	DT_MSP430F5224,$/;"	e	enum:__anon1
+DT_MSP430F5227	devicelist.h	/^	DT_MSP430F5227,$/;"	e	enum:__anon1
+DT_MSP430F5228	devicelist.h	/^	DT_MSP430F5228,$/;"	e	enum:__anon1
+DT_MSP430F5229	devicelist.h	/^	DT_MSP430F5229,$/;"	e	enum:__anon1
+DT_MSP430F5304	devicelist.h	/^	DT_MSP430F5304,$/;"	e	enum:__anon1
+DT_MSP430F5308	devicelist.h	/^	DT_MSP430F5308,$/;"	e	enum:__anon1
+DT_MSP430F5309	devicelist.h	/^	DT_MSP430F5309,$/;"	e	enum:__anon1
+DT_MSP430F5310	devicelist.h	/^	DT_MSP430F5310,$/;"	e	enum:__anon1
+DT_MSP430F5324	devicelist.h	/^	DT_MSP430F5324,$/;"	e	enum:__anon1
+DT_MSP430F5325	devicelist.h	/^	DT_MSP430F5325,$/;"	e	enum:__anon1
+DT_MSP430F5326	devicelist.h	/^	DT_MSP430F5326,$/;"	e	enum:__anon1
+DT_MSP430F5327	devicelist.h	/^	DT_MSP430F5327,$/;"	e	enum:__anon1
+DT_MSP430F5328	devicelist.h	/^	DT_MSP430F5328,$/;"	e	enum:__anon1
+DT_MSP430F5329	devicelist.h	/^	DT_MSP430F5329,$/;"	e	enum:__anon1
+DT_MSP430F5333	devicelist.h	/^	DT_MSP430F5333,$/;"	e	enum:__anon1
+DT_MSP430F5335	devicelist.h	/^	DT_MSP430F5335,$/;"	e	enum:__anon1
+DT_MSP430F5336	devicelist.h	/^	DT_MSP430F5336,$/;"	e	enum:__anon1
+DT_MSP430F5338	devicelist.h	/^	DT_MSP430F5338,$/;"	e	enum:__anon1
+DT_MSP430F5340	devicelist.h	/^	DT_MSP430F5340,$/;"	e	enum:__anon1
+DT_MSP430F5341	devicelist.h	/^	DT_MSP430F5341,$/;"	e	enum:__anon1
+DT_MSP430F5342	devicelist.h	/^	DT_MSP430F5342,$/;"	e	enum:__anon1
+DT_MSP430F5357	devicelist.h	/^	DT_MSP430F5357,$/;"	e	enum:__anon1
+DT_MSP430F5358	devicelist.h	/^	DT_MSP430F5358,$/;"	e	enum:__anon1
+DT_MSP430F5359	devicelist.h	/^	DT_MSP430F5359,$/;"	e	enum:__anon1
+DT_MSP430F5418	devicelist.h	/^	DT_MSP430F5418,$/;"	e	enum:__anon1
+DT_MSP430F5418A	devicelist.h	/^	DT_MSP430F5418A,$/;"	e	enum:__anon1
+DT_MSP430F5419	devicelist.h	/^	DT_MSP430F5419,$/;"	e	enum:__anon1
+DT_MSP430F5419A	devicelist.h	/^	DT_MSP430F5419A,$/;"	e	enum:__anon1
+DT_MSP430F5435	devicelist.h	/^	DT_MSP430F5435,$/;"	e	enum:__anon1
+DT_MSP430F5435A	devicelist.h	/^	DT_MSP430F5435A,$/;"	e	enum:__anon1
+DT_MSP430F5436	devicelist.h	/^	DT_MSP430F5436,$/;"	e	enum:__anon1
+DT_MSP430F5436A	devicelist.h	/^	DT_MSP430F5436A,$/;"	e	enum:__anon1
+DT_MSP430F5437	devicelist.h	/^	DT_MSP430F5437,$/;"	e	enum:__anon1
+DT_MSP430F5437A	devicelist.h	/^	DT_MSP430F5437A,$/;"	e	enum:__anon1
+DT_MSP430F5438	devicelist.h	/^	DT_MSP430F5438,$/;"	e	enum:__anon1
+DT_MSP430F5438A	devicelist.h	/^	DT_MSP430F5438A,$/;"	e	enum:__anon1
+DT_MSP430F5500	devicelist.h	/^	DT_MSP430F5500,$/;"	e	enum:__anon1
+DT_MSP430F5501	devicelist.h	/^	DT_MSP430F5501,$/;"	e	enum:__anon1
+DT_MSP430F5502	devicelist.h	/^	DT_MSP430F5502,$/;"	e	enum:__anon1
+DT_MSP430F5503	devicelist.h	/^	DT_MSP430F5503,$/;"	e	enum:__anon1
+DT_MSP430F5504	devicelist.h	/^	DT_MSP430F5504,$/;"	e	enum:__anon1
+DT_MSP430F5505	devicelist.h	/^	DT_MSP430F5505,$/;"	e	enum:__anon1
+DT_MSP430F5506	devicelist.h	/^	DT_MSP430F5506,$/;"	e	enum:__anon1
+DT_MSP430F5507	devicelist.h	/^	DT_MSP430F5507,$/;"	e	enum:__anon1
+DT_MSP430F5508	devicelist.h	/^	DT_MSP430F5508,$/;"	e	enum:__anon1
+DT_MSP430F5509	devicelist.h	/^	DT_MSP430F5509,$/;"	e	enum:__anon1
+DT_MSP430F5510	devicelist.h	/^	DT_MSP430F5510,$/;"	e	enum:__anon1
+DT_MSP430F5513	devicelist.h	/^	DT_MSP430F5513,$/;"	e	enum:__anon1
+DT_MSP430F5514	devicelist.h	/^	DT_MSP430F5514,$/;"	e	enum:__anon1
+DT_MSP430F5515	devicelist.h	/^	DT_MSP430F5515,$/;"	e	enum:__anon1
+DT_MSP430F5517	devicelist.h	/^	DT_MSP430F5517,$/;"	e	enum:__anon1
+DT_MSP430F5519	devicelist.h	/^	DT_MSP430F5519,$/;"	e	enum:__anon1
+DT_MSP430F5521	devicelist.h	/^	DT_MSP430F5521,$/;"	e	enum:__anon1
+DT_MSP430F5522	devicelist.h	/^	DT_MSP430F5522,$/;"	e	enum:__anon1
+DT_MSP430F5524	devicelist.h	/^	DT_MSP430F5524,$/;"	e	enum:__anon1
+DT_MSP430F5525	devicelist.h	/^	DT_MSP430F5525,$/;"	e	enum:__anon1
+DT_MSP430F5526	devicelist.h	/^	DT_MSP430F5526,$/;"	e	enum:__anon1
+DT_MSP430F5527	devicelist.h	/^	DT_MSP430F5527,$/;"	e	enum:__anon1
+DT_MSP430F5528	devicelist.h	/^	DT_MSP430F5528,$/;"	e	enum:__anon1
+DT_MSP430F5529	devicelist.h	/^	DT_MSP430F5529,$/;"	e	enum:__anon1
+DT_MSP430F5630	devicelist.h	/^	DT_MSP430F5630,$/;"	e	enum:__anon1
+DT_MSP430F5631	devicelist.h	/^	DT_MSP430F5631,$/;"	e	enum:__anon1
+DT_MSP430F5632	devicelist.h	/^	DT_MSP430F5632,$/;"	e	enum:__anon1
+DT_MSP430F5633	devicelist.h	/^	DT_MSP430F5633,$/;"	e	enum:__anon1
+DT_MSP430F5634	devicelist.h	/^	DT_MSP430F5634,$/;"	e	enum:__anon1
+DT_MSP430F5635	devicelist.h	/^	DT_MSP430F5635,$/;"	e	enum:__anon1
+DT_MSP430F5636	devicelist.h	/^	DT_MSP430F5636,$/;"	e	enum:__anon1
+DT_MSP430F5637	devicelist.h	/^	DT_MSP430F5637,$/;"	e	enum:__anon1
+DT_MSP430F5638	devicelist.h	/^	DT_MSP430F5638,$/;"	e	enum:__anon1
+DT_MSP430F5658	devicelist.h	/^	DT_MSP430F5658,$/;"	e	enum:__anon1
+DT_MSP430F5659	devicelist.h	/^	DT_MSP430F5659,$/;"	e	enum:__anon1
+DT_MSP430F6433	devicelist.h	/^	DT_MSP430F6433,$/;"	e	enum:__anon1
+DT_MSP430F6435	devicelist.h	/^	DT_MSP430F6435,$/;"	e	enum:__anon1
+DT_MSP430F6436	devicelist.h	/^	DT_MSP430F6436,$/;"	e	enum:__anon1
+DT_MSP430F6438	devicelist.h	/^	DT_MSP430F6438,$/;"	e	enum:__anon1
+DT_MSP430F6457	devicelist.h	/^	DT_MSP430F6457,$/;"	e	enum:__anon1
+DT_MSP430F6458	devicelist.h	/^	DT_MSP430F6458,$/;"	e	enum:__anon1
+DT_MSP430F6459	devicelist.h	/^	DT_MSP430F6459,$/;"	e	enum:__anon1
+DT_MSP430F6630	devicelist.h	/^	DT_MSP430F6630,$/;"	e	enum:__anon1
+DT_MSP430F6631	devicelist.h	/^	DT_MSP430F6631,$/;"	e	enum:__anon1
+DT_MSP430F6632	devicelist.h	/^	DT_MSP430F6632,$/;"	e	enum:__anon1
+DT_MSP430F6633	devicelist.h	/^	DT_MSP430F6633,$/;"	e	enum:__anon1
+DT_MSP430F6634	devicelist.h	/^	DT_MSP430F6634,$/;"	e	enum:__anon1
+DT_MSP430F6635	devicelist.h	/^	DT_MSP430F6635,$/;"	e	enum:__anon1
+DT_MSP430F6636	devicelist.h	/^	DT_MSP430F6636,$/;"	e	enum:__anon1
+DT_MSP430F6637	devicelist.h	/^	DT_MSP430F6637,$/;"	e	enum:__anon1
+DT_MSP430F6638	devicelist.h	/^	DT_MSP430F6638,$/;"	e	enum:__anon1
+DT_MSP430F6658	devicelist.h	/^	DT_MSP430F6658,$/;"	e	enum:__anon1
+DT_MSP430F6659	devicelist.h	/^	DT_MSP430F6659,$/;"	e	enum:__anon1
+DT_MSP430F6700	devicelist.h	/^	DT_MSP430F6700,$/;"	e	enum:__anon1
+DT_MSP430F6701	devicelist.h	/^	DT_MSP430F6701,$/;"	e	enum:__anon1
+DT_MSP430F6702	devicelist.h	/^	DT_MSP430F6702,$/;"	e	enum:__anon1
+DT_MSP430F6703	devicelist.h	/^	DT_MSP430F6703,$/;"	e	enum:__anon1
+DT_MSP430F6720	devicelist.h	/^	DT_MSP430F6720,$/;"	e	enum:__anon1
+DT_MSP430F6721	devicelist.h	/^	DT_MSP430F6721,$/;"	e	enum:__anon1
+DT_MSP430F6722	devicelist.h	/^	DT_MSP430F6722,$/;"	e	enum:__anon1
+DT_MSP430F6723	devicelist.h	/^	DT_MSP430F6723,$/;"	e	enum:__anon1
+DT_MSP430F6724	devicelist.h	/^	DT_MSP430F6724,$/;"	e	enum:__anon1
+DT_MSP430F6725	devicelist.h	/^	DT_MSP430F6725,$/;"	e	enum:__anon1
+DT_MSP430F6726	devicelist.h	/^	DT_MSP430F6726,$/;"	e	enum:__anon1
+DT_MSP430F6730	devicelist.h	/^	DT_MSP430F6730,$/;"	e	enum:__anon1
+DT_MSP430F6731	devicelist.h	/^	DT_MSP430F6731,$/;"	e	enum:__anon1
+DT_MSP430F6732	devicelist.h	/^	DT_MSP430F6732,$/;"	e	enum:__anon1
+DT_MSP430F6733	devicelist.h	/^	DT_MSP430F6733,$/;"	e	enum:__anon1
+DT_MSP430F6734	devicelist.h	/^	DT_MSP430F6734,$/;"	e	enum:__anon1
+DT_MSP430F6735	devicelist.h	/^	DT_MSP430F6735,$/;"	e	enum:__anon1
+DT_MSP430F6736	devicelist.h	/^	DT_MSP430F6736,$/;"	e	enum:__anon1
+DT_MSP430FE423	devicelist.h	/^	DT_MSP430FE423,$/;"	e	enum:__anon1
+DT_MSP430FE4232	devicelist.h	/^	DT_MSP430FE4232,$/;"	e	enum:__anon1
+DT_MSP430FE423A	devicelist.h	/^	DT_MSP430FE423A,$/;"	e	enum:__anon1
+DT_MSP430FE425	devicelist.h	/^	DT_MSP430FE425,$/;"	e	enum:__anon1
+DT_MSP430FE425A	devicelist.h	/^	DT_MSP430FE425A,$/;"	e	enum:__anon1
+DT_MSP430FE427	devicelist.h	/^	DT_MSP430FE427,$/;"	e	enum:__anon1
+DT_MSP430FE4272	devicelist.h	/^	DT_MSP430FE4272,$/;"	e	enum:__anon1
+DT_MSP430FE427A	devicelist.h	/^	DT_MSP430FE427A,$/;"	e	enum:__anon1
+DT_MSP430FE42x2	devicelist.h	/^	DT_MSP430FE42x2,$/;"	e	enum:__anon1
+DT_MSP430FG4250	devicelist.h	/^	DT_MSP430FG4250,$/;"	e	enum:__anon1
+DT_MSP430FG42x0	devicelist.h	/^	DT_MSP430FG42x0,$/;"	e	enum:__anon1
+DT_MSP430FG43x	devicelist.h	/^	DT_MSP430FG43x,$/;"	e	enum:__anon1
+DT_MSP430FG4618	devicelist.h	/^	DT_MSP430FG4618,$/;"	e	enum:__anon1
+DT_MSP430FG4619	devicelist.h	/^	DT_MSP430FG4619,$/;"	e	enum:__anon1
+DT_MSP430FG477	devicelist.h	/^	DT_MSP430FG477,$/;"	e	enum:__anon1
+DT_MSP430FG478	devicelist.h	/^	DT_MSP430FG478,$/;"	e	enum:__anon1
+DT_MSP430FG479	devicelist.h	/^	DT_MSP430FG479,$/;"	e	enum:__anon1
+DT_MSP430FR5720	devicelist.h	/^	DT_MSP430FR5720,$/;"	e	enum:__anon1
+DT_MSP430FR5721	devicelist.h	/^	DT_MSP430FR5721,$/;"	e	enum:__anon1
+DT_MSP430FR5722	devicelist.h	/^	DT_MSP430FR5722,$/;"	e	enum:__anon1
+DT_MSP430FR5723	devicelist.h	/^	DT_MSP430FR5723,$/;"	e	enum:__anon1
+DT_MSP430FR5724	devicelist.h	/^	DT_MSP430FR5724,$/;"	e	enum:__anon1
+DT_MSP430FR5725	devicelist.h	/^	DT_MSP430FR5725,$/;"	e	enum:__anon1
+DT_MSP430FR5726	devicelist.h	/^	DT_MSP430FR5726,$/;"	e	enum:__anon1
+DT_MSP430FR5727	devicelist.h	/^	DT_MSP430FR5727,$/;"	e	enum:__anon1
+DT_MSP430FR5728	devicelist.h	/^	DT_MSP430FR5728,$/;"	e	enum:__anon1
+DT_MSP430FR5729	devicelist.h	/^	DT_MSP430FR5729,$/;"	e	enum:__anon1
+DT_MSP430FR5730	devicelist.h	/^	DT_MSP430FR5730,$/;"	e	enum:__anon1
+DT_MSP430FR5731	devicelist.h	/^	DT_MSP430FR5731,$/;"	e	enum:__anon1
+DT_MSP430FR5732	devicelist.h	/^	DT_MSP430FR5732,$/;"	e	enum:__anon1
+DT_MSP430FR5733	devicelist.h	/^	DT_MSP430FR5733,$/;"	e	enum:__anon1
+DT_MSP430FR5734	devicelist.h	/^	DT_MSP430FR5734,$/;"	e	enum:__anon1
+DT_MSP430FR5735	devicelist.h	/^	DT_MSP430FR5735,$/;"	e	enum:__anon1
+DT_MSP430FR5736	devicelist.h	/^	DT_MSP430FR5736,$/;"	e	enum:__anon1
+DT_MSP430FR5737	devicelist.h	/^	DT_MSP430FR5737,$/;"	e	enum:__anon1
+DT_MSP430FR5738	devicelist.h	/^	DT_MSP430FR5738,$/;"	e	enum:__anon1
+DT_MSP430FR5739	devicelist.h	/^	DT_MSP430FR5739,$/;"	e	enum:__anon1
+DT_MSP430FR5969	devicelist.h	/^	DT_MSP430FR5969,$/;"	e	enum:__anon1
+DT_MSP430FW429	devicelist.h	/^	DT_MSP430FW429,$/;"	e	enum:__anon1
+DT_MSP430FW42x	devicelist.h	/^	DT_MSP430FW42x,$/;"	e	enum:__anon1
+DT_MSP430G2452	devicelist.h	/^	DT_MSP430G2452,$/;"	e	enum:__anon1
+DT_MSP430G2553	devicelist.h	/^	DT_MSP430G2553,$/;"	e	enum:__anon1
+DT_MSP430L092	devicelist.h	/^	DT_MSP430L092,$/;"	e	enum:__anon1
+DT_PMS430F16x	devicelist.h	/^	DT_PMS430F16x,$/;"	e	enum:__anon1
+DT_TMS430C1250	devicelist.h	/^	DT_TMS430C1250,$/;"	e	enum:__anon1
+DT_TMS430EMU	devicelist.h	/^	DT_TMS430EMU,$/;"	e	enum:__anon1
+DT_TMS430F1250	devicelist.h	/^	DT_TMS430F1250,$/;"	e	enum:__anon1
+DT_TMS430F1390	devicelist.h	/^	DT_TMS430F1390,$/;"	e	enum:__anon1
+DT_UNKNOWN_DEVICE	devicelist.h	/^	DT_UNKNOWN_DEVICE = 0,$/;"	e	enum:__anon1
+DT_XMS430F5438	devicelist.h	/^	DT_XMS430F5438,$/;"	e	enum:__anon1
+device_id_param	devicelist.h	/^	uint8_t         device_id_param[9];$/;"	m	struct:device_table
+device_table	devicelist.h	/^struct device_table {$/;"	s
+device_type_id	devicelist.h	/^	uint16_t        device_type_id;$/;"	m	struct:device_table
+devicetype_t	devicelist.h	/^} devicetype_t;$/;"	t	typeref:enum:__anon1
+name	devicelist.h	/^	const char	*name;$/;"	m	struct:device_table
+device_olimex	fet.c	/^const struct device_class device_olimex = {$/;"	v	typeref:struct:device_class
+device_olimex_iso	fet.c	/^const struct device_class device_olimex_iso = {$/;"	v	typeref:struct:device_class
+device_olimex_iso_mk2	fet.c	/^const struct device_class device_olimex_iso_mk2 = {$/;"	v	typeref:struct:device_class
+device_olimex_v1	fet.c	/^const struct device_class device_olimex_v1 = {$/;"	v	typeref:struct:device_class
+device_rf2500	fet.c	/^const struct device_class device_rf2500 = {$/;"	v	typeref:struct:device_class
+device_uif	fet.c	/^const struct device_class device_uif = {$/;"	v	typeref:struct:device_class
+fet_open_olimex	fet.c	/^static device_t fet_open_olimex(const struct device_args *args)$/;"	f	file:
+fet_open_olimex_iso	fet.c	/^static device_t fet_open_olimex_iso(const struct device_args *args)$/;"	f	file:
+fet_open_olimex_iso_mk2	fet.c	/^static device_t fet_open_olimex_iso_mk2(const struct device_args *args)$/;"	f	file:
+fet_open_olimex_v1	fet.c	/^static device_t fet_open_olimex_v1(const struct device_args *args)$/;"	f	file:
+fet_open_rf2500	fet.c	/^static device_t fet_open_rf2500(const struct device_args *args)$/;"	f	file:
+fet_open_uif	fet.c	/^static device_t fet_open_uif(const struct device_args *args)$/;"	f	file:
+FET_H_	fet.h	20;"	d
+C_BREAKPOINT	fet_core.c	78;"	d	file:
+C_CLOSE	fet_core.c	64;"	d	file:
+C_CMM_CTRL	fet_core.c	105;"	d	file:
+C_CMM_PARAM	fet_core.c	104;"	d	file:
+C_CMM_READ	fet_core.c	106;"	d	file:
+C_CONFIGURE	fet_core.c	67;"	d	file:
+C_DEVICE	fet_core.c	66;"	d	file:
+C_EEMCLOSE	fet_core.c	89;"	d	file:
+C_EEMOPEN	fet_core.c	85;"	d	file:
+C_EEMREADREGISTER	fet_core.c	86;"	d	file:
+C_EEMREADREGISTERTEST	fet_core.c	87;"	d	file:
+C_EEMWRITEREGISTER	fet_core.c	88;"	d	file:
+C_ENTERBOOTLOADER	fet_core.c	98;"	d	file:
+C_ERASE	fet_core.c	74;"	d	file:
+C_ERASECHECK	fet_core.c	84;"	d	file:
+C_ERRORNUMBER	fet_core.c	90;"	d	file:
+C_FASTFLASHER	fet_core.c	77;"	d	file:
+C_FASTVERIFYMEMORY	fet_core.c	83;"	d	file:
+C_FETRESET	fet_core.c	95;"	d	file:
+C_FETSELFTEST	fet_core.c	93;"	d	file:
+C_FETSETSIGNALS	fet_core.c	94;"	d	file:
+C_GETCURVCCT	fet_core.c	91;"	d	file:
+C_GETEXTVOLTAGE	fet_core.c	92;"	d	file:
+C_IDENT1	fet_core.c	100;"	d	file:
+C_IDENT2	fet_core.c	101;"	d	file:
+C_IDENT3	fet_core.c	102;"	d	file:
+C_IDENTIFY	fet_core.c	65;"	d	file:
+C_INITIALIZE	fet_core.c	63;"	d	file:
+C_READI2C	fet_core.c	96;"	d	file:
+C_READMEMORY	fet_core.c	75;"	d	file:
+C_READREGISTER	fet_core.c	72;"	d	file:
+C_READREGISTERS	fet_core.c	70;"	d	file:
+C_RESET	fet_core.c	69;"	d	file:
+C_RUN	fet_core.c	79;"	d	file:
+C_SECURE	fet_core.c	81;"	d	file:
+C_STATE	fet_core.c	80;"	d	file:
+C_VCC	fet_core.c	68;"	d	file:
+C_VERIFYMEMORY	fet_core.c	82;"	d	file:
+C_WRITEI2C	fet_core.c	97;"	d	file:
+C_WRITEMEMORY	fet_core.c	76;"	d	file:
+C_WRITEREGISTER	fet_core.c	73;"	d	file:
+C_WRITEREGISTERS	fet_core.c	71;"	d	file:
+FET_CONFIG_CLKCTRL	fet_core.c	111;"	d	file:
+FET_CONFIG_EMULATION	fet_core.c	110;"	d	file:
+FET_CONFIG_FLASH_LOCK	fet_core.c	114;"	d	file:
+FET_CONFIG_FLASH_TESET	fet_core.c	113;"	d	file:
+FET_CONFIG_MCLKCTRL	fet_core.c	112;"	d	file:
+FET_CONFIG_PROTOCOL	fet_core.c	115;"	d	file:
+FET_CONFIG_UNLOCK_BSL	fet_core.c	116;"	d	file:
+FET_CONFIG_VERIFICATION	fet_core.c	109;"	d	file:
+FET_ERASE_ALL	fet_core.c	129;"	d	file:
+FET_ERASE_MAIN	fet_core.c	128;"	d	file:
+FET_ERASE_SEGMENT	fet_core.c	127;"	d	file:
+FET_POLL_BREAKPOINT	fet_core.c	132;"	d	file:
+FET_POLL_RUNNING	fet_core.c	131;"	d	file:
+FET_RESET_ALL	fet_core.c	125;"	d	file:
+FET_RESET_PUC	fet_core.c	122;"	d	file:
+FET_RESET_RST	fet_core.c	123;"	d	file:
+FET_RESET_VCC	fet_core.c	124;"	d	file:
+FET_RUN_BREAKPOINT	fet_core.c	120;"	d	file:
+FET_RUN_FREE	fet_core.c	118;"	d	file:
+FET_RUN_STEP	fet_core.c	119;"	d	file:
+active_fperm	fet_core.c	/^	fperm_t				active_fperm;$/;"	m	struct:fet_device	file:
+base	fet_core.c	/^	struct device                   base;$/;"	m	struct:fet_device	typeref:struct:fet_device::device	file:
+do_configure	fet_core.c	/^static int do_configure(struct fet_device *dev,$/;"	f	file:
+do_identify	fet_core.c	/^static int do_identify(struct fet_device *dev, const char *force_id)$/;"	f	file:
+do_run	fet_core.c	/^static int do_run(struct fet_device *dev, int type)$/;"	f	file:
+fet_ctl	fet_core.c	/^int fet_ctl(device_t dev_base, device_ctl_t action)$/;"	f
+fet_destroy	fet_core.c	/^void fet_destroy(device_t dev_base)$/;"	f
+fet_device	fet_core.c	/^struct fet_device {$/;"	s	file:
+fet_erase	fet_core.c	/^int fet_erase(device_t dev_base, device_erase_type_t type, address_t addr)$/;"	f
+fet_flags	fet_core.c	/^	int				fet_flags;$/;"	m	struct:fet_device	file:
+fet_getregs	fet_core.c	/^int fet_getregs(device_t dev_base, address_t *regs)$/;"	f
+fet_open	fet_core.c	/^device_t fet_open(const struct device_args *args,$/;"	f
+fet_poll	fet_core.c	/^device_status_t fet_poll(device_t dev_base)$/;"	f
+fet_readmem	fet_core.c	/^int fet_readmem(device_t dev_base, address_t addr, uint8_t *buffer,$/;"	f
+fet_setregs	fet_core.c	/^int fet_setregs(device_t dev_base, const address_t *regs)$/;"	f
+fet_writemem	fet_core.c	/^int fet_writemem(device_t dev_base, address_t addr,$/;"	f
+get_adjusted_block_size	fet_core.c	/^static int get_adjusted_block_size(void)$/;"	f	file:
+identify_new	fet_core.c	/^static int identify_new(struct fet_device *dev, const char *force_id)$/;"	f	file:
+identify_old	fet_core.c	/^static int identify_old(struct fet_device *dev)$/;"	f	file:
+identify_olimex	fet_core.c	/^static int identify_olimex(struct fet_device *dev, const char *force_id)$/;"	f	file:
+is_new_olimex	fet_core.c	/^static int is_new_olimex(const struct fet_device *dev)$/;"	f	file:
+poll_enable	fet_core.c	/^	int				poll_enable;$/;"	m	struct:fet_device	file:
+power_end	fet_core.c	/^static int power_end(struct fet_device *dev)$/;"	f	file:
+power_init	fet_core.c	/^static void power_init(struct fet_device *dev)$/;"	f	file:
+power_poll	fet_core.c	/^static int power_poll(struct fet_device *dev)$/;"	f	file:
+power_start	fet_core.c	/^static int power_start(struct fet_device *dev)$/;"	f	file:
+proto	fet_core.c	/^	struct fet_proto		proto;$/;"	m	struct:fet_device	typeref:struct:fet_device::fet_proto	file:
+read_byte	fet_core.c	/^static int read_byte(struct fet_device *dev, address_t addr, uint8_t *out)$/;"	f	file:
+refresh_bps	fet_core.c	/^static int refresh_bps(struct fet_device *dev)$/;"	f	file:
+refresh_fperm	fet_core.c	/^static int refresh_fperm(struct fet_device *dev)$/;"	f	file:
+shell_power	fet_core.c	/^static void shell_power(const uint8_t *data, int len)$/;"	f	file:
+show_dev_info	fet_core.c	/^static void show_dev_info(const char *name, const struct fet_device *dev)$/;"	f	file:
+try_new	fet_core.c	/^static int try_new(struct fet_device *dev, const char *force_id)$/;"	f	file:
+try_open	fet_core.c	/^int try_open(struct fet_device *dev, const struct device_args *args,$/;"	f
+version	fet_core.c	/^	int                             version;$/;"	m	struct:fet_device	file:
+write_byte	fet_core.c	/^static int write_byte(struct fet_device *dev, address_t addr, uint8_t value)$/;"	f	file:
+FET_CORE_H_	fet_core.h	20;"	d
+FET_FORCE_RESET	fet_core.h	32;"	d
+FET_IDENTIFY_NEW	fet_core.h	29;"	d
+FET_SKIP_CLOSE	fet_core.h	26;"	d
+fet_db	fet_db.c	/^static const struct fet_db_record fet_db[] = {$/;"	v	typeref:struct:fet_db_record	file:
+fet_db_enum	fet_db.c	/^int fet_db_enum(fet_db_enum_func_t func, void *user_data)$/;"	f
+fet_db_find_by_msg28	fet_db.c	/^const struct fet_db_record *fet_db_find_by_msg28(uint8_t *data, int len)$/;"	f
+fet_db_find_by_name	fet_db.c	/^const struct fet_db_record *fet_db_find_by_name(const char *name)$/;"	f
+FET_DB_H_	fet_db.h	20;"	d
+FET_DB_MSG28_LEN	fet_db.h	24;"	d
+FET_DB_MSG29_LEN	fet_db.h	26;"	d
+FET_DB_MSG29_PARAMS	fet_db.h	25;"	d
+FET_DB_MSG2B_LEN	fet_db.h	27;"	d
+fet_db_enum_func_t	fet_db.h	/^typedef int (*fet_db_enum_func_t)(void *user_data,$/;"	t
+fet_db_record	fet_db.h	/^struct fet_db_record {$/;"	s
+msg28_data	fet_db.h	/^	uint8_t         msg28_data[FET_DB_MSG28_LEN];$/;"	m	struct:fet_db_record
+msg29_data	fet_db.h	/^	uint8_t         msg29_data[FET_DB_MSG29_LEN];$/;"	m	struct:fet_db_record
+msg29_params	fet_db.h	/^	int             msg29_params[FET_DB_MSG29_PARAMS];$/;"	m	struct:fet_db_record
+msg2b_data	fet_db.h	/^	uint8_t         msg2b_data[FET_DB_MSG2B_LEN];$/;"	m	struct:fet_db_record
+msg2b_len	fet_db.h	/^	int             msg2b_len;$/;"	m	struct:fet_db_record
+name	fet_db.h	/^	const char      *name;$/;"	m	struct:fet_db_record
+error_strings	fet_error.c	/^static const char *error_strings[] =$/;"	v	file:
+fet_error	fet_error.c	/^const char *fet_error(int code)$/;"	f
+FET_ERROR_H_	fet_error.h	20;"	d
+EMB_SYS_OFFSET	fet_olimex_db.c	33;"	d	file:
+FAB_ID_OFFSET	fet_olimex_db.c	30;"	d	file:
+ID0_OFFSET	fet_olimex_db.c	27;"	d	file:
+ID1_OFFSET	fet_olimex_db.c	28;"	d	file:
+REV_OFFSET	fet_olimex_db.c	29;"	d	file:
+SELF_TEST0_OFFSET	fet_olimex_db.c	31;"	d	file:
+SELF_TEST1_OFFSET	fet_olimex_db.c	32;"	d	file:
+fet_db_get_record	fet_olimex_db.c	/^const struct fet_olimex_db_record *fet_db_get_record(devicetype_t type)$/;"	f
+fet_olimex_db	fet_olimex_db.c	/^static const struct fet_olimex_db_record fet_olimex_db[] = {$/;"	v	typeref:struct:fet_olimex_db_record	file:
+fet_olimex_db_enum	fet_olimex_db.c	/^int fet_olimex_db_enum(fet_olimex_db_enum_func_t func, void *user_data)$/;"	f
+fet_olimex_db_find_by_name	fet_olimex_db.c	/^int fet_olimex_db_find_by_name(const char *name)$/;"	f
+fet_olimex_db_identify	fet_olimex_db.c	/^int fet_olimex_db_identify(const uint8_t *data)$/;"	f
+fet_olimex_db_index_to_type	fet_olimex_db.c	/^devicetype_t fet_olimex_db_index_to_type(int indx)$/;"	f
+FET_OLIMEX_DB_H_	fet_olimex_db.h	21;"	d
+FET_OLIMEX_DB_MSG28_LEN	fet_olimex_db.h	26;"	d
+FET_OLIMEX_DB_MSG29_LEN	fet_olimex_db.h	28;"	d
+FET_OLIMEX_DB_MSG29_PARAMS	fet_olimex_db.h	27;"	d
+FET_OLIMEX_DB_MSG2B_LEN	fet_olimex_db.h	29;"	d
+fet_olimex_db_enum_func_t	fet_olimex_db.h	/^typedef int (*fet_olimex_db_enum_func_t)(void *user_data, const char *name);$/;"	t
+fet_olimex_db_record	fet_olimex_db.h	/^struct fet_olimex_db_record {$/;"	s
+msg29_data	fet_olimex_db.h	/^	uint8_t         msg29_data[FET_OLIMEX_DB_MSG29_LEN];$/;"	m	struct:fet_olimex_db_record
+msg29_params	fet_olimex_db.h	/^	int             msg29_params[FET_OLIMEX_DB_MSG29_PARAMS];$/;"	m	struct:fet_olimex_db_record
+msg2b_data	fet_olimex_db.h	/^	uint8_t         msg2b_data[FET_OLIMEX_DB_MSG2B_LEN];$/;"	m	struct:fet_olimex_db_record
+msg2b_len	fet_olimex_db.h	/^	int             msg2b_len;$/;"	m	struct:fet_olimex_db_record
+name	fet_olimex_db.h	/^	const char      *name;$/;"	m	struct:fet_olimex_db_record
+PTYPE_ACK	fet_proto.c	117;"	d	file:
+PTYPE_CMD	fet_proto.c	118;"	d	file:
+PTYPE_DATA	fet_proto.c	120;"	d	file:
+PTYPE_FLASH_ACK	fet_proto.c	123;"	d	file:
+PTYPE_MIXED	fet_proto.c	121;"	d	file:
+PTYPE_NAK	fet_proto.c	122;"	d	file:
+PTYPE_PARAM	fet_proto.c	119;"	d	file:
+calc_checksum	fet_proto.c	/^static uint16_t calc_checksum(uint8_t *cp, int len)$/;"	f	file:
+fcstab	fet_proto.c	/^static const uint16_t fcstab[256] = {$/;"	v	file:
+fet_proto_init	fet_proto.c	/^void fet_proto_init(struct fet_proto *dev, transport_t transport,$/;"	f
+fet_proto_xfer	fet_proto.c	/^int fet_proto_xfer(struct fet_proto *dev,$/;"	f
+parse_packet	fet_proto.c	/^static int parse_packet(struct fet_proto *dev, int plen)$/;"	f	file:
+recv_packet	fet_proto.c	/^static int recv_packet(struct fet_proto *dev)$/;"	f	file:
+send_command	fet_proto.c	/^static int send_command(struct fet_proto *dev, int command_code,$/;"	f	file:
+send_rf2500_data	fet_proto.c	/^static int send_rf2500_data(struct fet_proto *dev,$/;"	f	file:
+FET_PROTO_EXTRA_RECV	fet_proto.h	30;"	d
+FET_PROTO_H_	fet_proto.h	20;"	d
+FET_PROTO_MAX_BLOCK	fet_proto.h	37;"	d
+FET_PROTO_MAX_PARAMS	fet_proto.h	36;"	d
+FET_PROTO_NOLEAD_SEND	fet_proto.h	33;"	d
+FET_PROTO_SEPARATE_DATA	fet_proto.h	27;"	d
+argc	fet_proto.h	/^	int				argc;$/;"	m	struct:fet_proto
+argv	fet_proto.h	/^	uint32_t			argv[FET_PROTO_MAX_PARAMS];$/;"	m	struct:fet_proto
+command_code	fet_proto.h	/^	int				command_code;$/;"	m	struct:fet_proto
+data	fet_proto.h	/^	uint8_t				*data;$/;"	m	struct:fet_proto
+datalen	fet_proto.h	/^	int				datalen;$/;"	m	struct:fet_proto
+error	fet_proto.h	/^	int				error;$/;"	m	struct:fet_proto
+fet_buf	fet_proto.h	/^	uint8_t                         fet_buf[65538];$/;"	m	struct:fet_proto
+fet_len	fet_proto.h	/^	int                             fet_len;$/;"	m	struct:fet_proto
+fet_proto	fet_proto.h	/^struct fet_proto {$/;"	s
+proto_flags	fet_proto.h	/^	int				proto_flags;$/;"	m	struct:fet_proto
+state	fet_proto.h	/^	int				state;$/;"	m	struct:fet_proto
+transport	fet_proto.h	/^	transport_t			transport;$/;"	m	struct:fet_proto
+CRC_CHECK	flash_bsl.c	95;"	d	file:
+CRC_INIT	flash_bsl.c	46;"	d	file:
+ERASE_SEGMENT	flash_bsl.c	92;"	d	file:
+LOAD_PC	flash_bsl.c	96;"	d	file:
+MASS_ERASE	flash_bsl.c	94;"	d	file:
+MAX_BLOCK	flash_bsl.c	40;"	d	file:
+MAX_PACKET	flash_bsl.c	43;"	d	file:
+RX_DATA_BLOCK	flash_bsl.c	89;"	d	file:
+RX_DATA_BLOCK_FAST	flash_bsl.c	90;"	d	file:
+RX_PASSWORD	flash_bsl.c	91;"	d	file:
+TX_BSL_VERSION	flash_bsl.c	98;"	d	file:
+TX_BUFFER_SIZE	flash_bsl.c	99;"	d	file:
+TX_DATA_BLOCK	flash_bsl.c	97;"	d	file:
+UNLOCK_LOCK_INFO	flash_bsl.c	93;"	d	file:
+base	flash_bsl.c	/^	struct device   base;$/;"	m	struct:flash_bsl_device	typeref:struct:flash_bsl_device::device	file:
+crc_ccitt	flash_bsl.c	/^static uint16_t crc_ccitt(const uint8_t *data, int len) {$/;"	f	file:
+crc_selftest	flash_bsl.c	/^static void crc_selftest(void) {$/;"	f	file:
+device_flash_bsl	flash_bsl.c	/^const struct device_class device_flash_bsl = {$/;"	v	typeref:struct:device_class
+enter_via_dtr_rts	flash_bsl.c	/^static int enter_via_dtr_rts(struct flash_bsl_device *dev)$/;"	f	file:
+entry_delay	flash_bsl.c	/^static void entry_delay(void)$/;"	f	file:
+exit_via_dtr_rts	flash_bsl.c	/^static void exit_via_dtr_rts(struct flash_bsl_device *dev)$/;"	f	file:
+flash_bsl_ctl	flash_bsl.c	/^static int flash_bsl_ctl(device_t dev_base, device_ctl_t type)$/;"	f	file:
+flash_bsl_destroy	flash_bsl.c	/^static void flash_bsl_destroy(device_t dev_base)$/;"	f	file:
+flash_bsl_device	flash_bsl.c	/^struct flash_bsl_device {$/;"	s	file:
+flash_bsl_erase	flash_bsl.c	/^static int flash_bsl_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+flash_bsl_getregs	flash_bsl.c	/^static int flash_bsl_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+flash_bsl_open	flash_bsl.c	/^static device_t flash_bsl_open(const struct device_args *args)$/;"	f	file:
+flash_bsl_perror	flash_bsl.c	/^static void flash_bsl_perror(uint8_t code) {$/;"	f	file:
+flash_bsl_poll	flash_bsl.c	/^static device_status_t flash_bsl_poll(device_t dev_base)$/;"	f	file:
+flash_bsl_readmem	flash_bsl.c	/^static int flash_bsl_readmem(device_t dev_base,$/;"	f	file:
+flash_bsl_recv	flash_bsl.c	/^static int flash_bsl_recv(struct flash_bsl_device *dev,$/;"	f	file:
+flash_bsl_send	flash_bsl.c	/^static int flash_bsl_send(struct flash_bsl_device *dev,$/;"	f	file:
+flash_bsl_setregs	flash_bsl.c	/^static int flash_bsl_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+flash_bsl_unlock	flash_bsl.c	/^static int flash_bsl_unlock(struct flash_bsl_device *dev)$/;"	f	file:
+flash_bsl_writemem	flash_bsl.c	/^static int flash_bsl_writemem(device_t dev_base,$/;"	f	file:
+long_password	flash_bsl.c	/^	int		long_password;$/;"	m	struct:flash_bsl_device	file:
+serial_fd	flash_bsl.c	/^	sport_t		serial_fd;$/;"	m	struct:flash_bsl_device	file:
+FLASH_BSL_H_	flash_bsl.h	21;"	d
+base	gdbc.c	/^	struct device			base;$/;"	m	struct:gdb_client	typeref:struct:gdb_client::device	file:
+bp_send	gdbc.c	/^static int bp_send(struct gdb_data *gdb, int c, address_t addr,$/;"	f	file:
+check_ok	gdbc.c	/^static int check_ok(struct gdb_data *gdb)$/;"	f	file:
+connect_to	gdbc.c	/^static int connect_to(const char *spec)$/;"	f	file:
+device_gdbc	gdbc.c	/^const struct device_class device_gdbc = {$/;"	v	typeref:struct:device_class
+do_reset	gdbc.c	/^static int do_reset(struct gdb_client *dev)$/;"	f	file:
+gdb	gdbc.c	/^	struct gdb_data			gdb;$/;"	m	struct:gdb_client	typeref:struct:gdb_client::gdb_data	file:
+gdb_client	gdbc.c	/^struct gdb_client {$/;"	s	file:
+gdbc_ctl	gdbc.c	/^static int gdbc_ctl(device_t dev_base, device_ctl_t op)$/;"	f	file:
+gdbc_destroy	gdbc.c	/^static void gdbc_destroy(device_t dev_base)$/;"	f	file:
+gdbc_erase	gdbc.c	/^static int gdbc_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+gdbc_getregs	gdbc.c	/^static int gdbc_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+gdbc_open	gdbc.c	/^static device_t gdbc_open(const struct device_args *args)$/;"	f	file:
+gdbc_poll	gdbc.c	/^static device_status_t gdbc_poll(device_t dev_base)$/;"	f	file:
+gdbc_readmem	gdbc.c	/^static int gdbc_readmem(device_t dev_base, address_t addr,$/;"	f	file:
+gdbc_setregs	gdbc.c	/^static int gdbc_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+gdbc_writemem	gdbc.c	/^static int gdbc_writemem(device_t dev_base, address_t addr,$/;"	f	file:
+get_xfer_size	gdbc.c	/^static int get_xfer_size(void)$/;"	f	file:
+is_running	gdbc.c	/^	int				is_running;$/;"	m	struct:gdb_client	file:
+last_bps	gdbc.c	/^	struct device_breakpoint	last_bps[DEVICE_MAX_BREAKPOINTS];$/;"	m	struct:gdb_client	typeref:struct:gdb_client::device_breakpoint	file:
+refresh_bps	gdbc.c	/^static int refresh_bps(struct gdb_client *dev)$/;"	f	file:
+GDBC_H_	gdbc.h	20;"	d
+APP_DEBUG	goodfet.c	30;"	d	file:
+APP_JTAG430	goodfet.c	29;"	d	file:
+GLOBAL_CALL	goodfet.c	39;"	d	file:
+GLOBAL_DEBUG	goodfet.c	46;"	d	file:
+GLOBAL_EXEC	goodfet.c	40;"	d	file:
+GLOBAL_EXIST	goodfet.c	42;"	d	file:
+GLOBAL_LIMIT	goodfet.c	41;"	d	file:
+GLOBAL_NMEM	goodfet.c	43;"	d	file:
+GLOBAL_NOK	goodfet.c	44;"	d	file:
+GLOBAL_OK	goodfet.c	45;"	d	file:
+GLOBAL_PEEK	goodfet.c	34;"	d	file:
+GLOBAL_POKE	goodfet.c	35;"	d	file:
+GLOBAL_READ	goodfet.c	32;"	d	file:
+GLOBAL_SETUP	goodfet.c	36;"	d	file:
+GLOBAL_START	goodfet.c	37;"	d	file:
+GLOBAL_STOP	goodfet.c	38;"	d	file:
+GLOBAL_WRITE	goodfet.c	33;"	d	file:
+JTAG430_BLOWFUSE	goodfet.c	60;"	d	file:
+JTAG430_COREIP_ID	goodfet.c	63;"	d	file:
+JTAG430_DEVICE_ID	goodfet.c	64;"	d	file:
+JTAG430_ERASECHECK	goodfet.c	58;"	d	file:
+JTAG430_ERASEFLASH	goodfet.c	57;"	d	file:
+JTAG430_ERASEINFO	goodfet.c	62;"	d	file:
+JTAG430_GETREG	goodfet.c	53;"	d	file:
+JTAG430_HALTCPU	goodfet.c	48;"	d	file:
+JTAG430_ISFUSEBLOWN	goodfet.c	61;"	d	file:
+JTAG430_READMEM	goodfet.c	56;"	d	file:
+JTAG430_RELEASECPU	goodfet.c	49;"	d	file:
+JTAG430_SETINSTRFETCH	goodfet.c	50;"	d	file:
+JTAG430_SETPC	goodfet.c	51;"	d	file:
+JTAG430_SETREG	goodfet.c	52;"	d	file:
+JTAG430_VERIFYMEM	goodfet.c	59;"	d	file:
+JTAG430_WRITEFLASH	goodfet.c	55;"	d	file:
+JTAG430_WRITEMEM	goodfet.c	54;"	d	file:
+MAX_LEN	goodfet.c	67;"	d	file:
+MAX_MEM_BLOCK	goodfet.c	68;"	d	file:
+app	goodfet.c	/^	uint8_t		app;$/;"	m	struct:packet	file:
+base	goodfet.c	/^	struct device		base;$/;"	m	struct:goodfet	typeref:struct:goodfet::device	file:
+data	goodfet.c	/^	uint8_t		data[MAX_LEN];$/;"	m	struct:packet	file:
+device_goodfet	goodfet.c	/^const struct device_class device_goodfet = {$/;"	v	typeref:struct:device_class
+goodfet	goodfet.c	/^struct goodfet {$/;"	s	file:
+goodfet_ctl	goodfet.c	/^static int goodfet_ctl(device_t dev_base, device_ctl_t type)$/;"	f	file:
+goodfet_destroy	goodfet.c	/^static void goodfet_destroy(device_t dev_base)$/;"	f	file:
+goodfet_erase	goodfet.c	/^static int goodfet_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+goodfet_getregs	goodfet.c	/^static int goodfet_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+goodfet_halt	goodfet.c	/^static int goodfet_halt(struct goodfet *gc)$/;"	f	file:
+goodfet_open	goodfet.c	/^static device_t goodfet_open(const struct device_args *args)$/;"	f	file:
+goodfet_poll	goodfet.c	/^static device_status_t goodfet_poll(device_t dev_base)$/;"	f	file:
+goodfet_readmem	goodfet.c	/^static int goodfet_readmem(device_t dev_base, address_t addr,$/;"	f	file:
+goodfet_reset	goodfet.c	/^static int goodfet_reset(struct goodfet *gc)$/;"	f	file:
+goodfet_run	goodfet.c	/^static int goodfet_run(struct goodfet *gc)$/;"	f	file:
+goodfet_setregs	goodfet.c	/^static int goodfet_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+goodfet_writemem	goodfet.c	/^static int goodfet_writemem(device_t dev_base, address_t addr,$/;"	f	file:
+init_device	goodfet.c	/^static int init_device(sport_t fd)$/;"	f	file:
+len	goodfet.c	/^	uint16_t	len;$/;"	m	struct:packet	file:
+packet	goodfet.c	/^struct packet {$/;"	s	file:
+read_words	goodfet.c	/^static int read_words(sport_t fd, address_t addr,$/;"	f	file:
+recv_packet	goodfet.c	/^static int recv_packet(sport_t fd, struct packet *pkt)$/;"	f	file:
+reset_sequence	goodfet.c	/^static int reset_sequence(sport_t fd)$/;"	f	file:
+send_packet	goodfet.c	/^static int send_packet(sport_t fd,$/;"	f	file:
+serial_fd	goodfet.c	/^	sport_t			serial_fd;$/;"	m	struct:goodfet	file:
+verb	goodfet.c	/^	uint8_t		verb;$/;"	m	struct:packet	file:
+write_byte	goodfet.c	/^static int write_byte(sport_t fd, address_t addr, uint8_t value)$/;"	f	file:
+write_flash_block	goodfet.c	/^static int write_flash_block(sport_t fd, address_t addr,$/;"	f	file:
+write_ram_word	goodfet.c	/^static int write_ram_word(sport_t fd, address_t addr, uint16_t value)$/;"	f	file:
+xfer	goodfet.c	/^static int xfer(sport_t fd,$/;"	f	file:
+GOODFET_H_	goodfet.h	20;"	d
+!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
+IR_ADDR_16BIT	jtaglib.c	45;"	d	file:
+IR_ADDR_CAPTURE	jtaglib.c	46;"	d	file:
+IR_BYPASS	jtaglib.c	55;"	d	file:
+IR_CNTRL_SIG_16BIT	jtaglib.c	37;"	d	file:
+IR_CNTRL_SIG_CAPTURE	jtaglib.c	38;"	d	file:
+IR_CNTRL_SIG_RELEASE	jtaglib.c	39;"	d	file:
+IR_DATA_16BIT	jtaglib.c	41;"	d	file:
+IR_DATA_CAPTURE	jtaglib.c	42;"	d	file:
+IR_DATA_PSA	jtaglib.c	49;"	d	file:
+IR_DATA_QUICK	jtaglib.c	43;"	d	file:
+IR_DATA_TO_ADDR	jtaglib.c	47;"	d	file:
+IR_EX_BLOW	jtaglib.c	53;"	d	file:
+IR_PREPARE_BLOW	jtaglib.c	52;"	d	file:
+IR_SHIFT_OUT_PSA	jtaglib.c	50;"	d	file:
+JTAG_ID	jtaglib.c	33;"	d	file:
+jtag_chip_id	jtaglib.c	/^unsigned int jtag_chip_id(struct jtdev *p)$/;"	f
+jtag_dr_shift	jtaglib.c	/^static unsigned int jtag_dr_shift( struct jtdev *p, unsigned int data )$/;"	f	file:
+jtag_erase_check	jtaglib.c	/^int jtag_erase_check( struct jtdev *p,$/;"	f
+jtag_erase_flash	jtaglib.c	/^void jtag_erase_flash( struct jtdev *p, unsigned int erase_mode,$/;"	f
+jtag_execute_puc	jtaglib.c	/^unsigned int jtag_execute_puc(struct jtdev *p)$/;"	f
+jtag_get_device	jtaglib.c	/^unsigned int jtag_get_device(struct jtdev *p)$/;"	f
+jtag_halt_cpu	jtaglib.c	/^static void jtag_halt_cpu(struct jtdev *p)$/;"	f	file:
+jtag_init	jtaglib.c	/^unsigned int jtag_init (struct jtdev *p)$/;"	f
+jtag_ir_shift	jtaglib.c	/^static unsigned int jtag_ir_shift(struct jtdev *p, unsigned int instruction)$/;"	f	file:
+jtag_is_fuse_blown	jtaglib.c	/^int jtag_is_fuse_blown (struct jtdev *p)$/;"	f
+jtag_led_green_off	jtaglib.c	71;"	d	file:
+jtag_led_green_on	jtaglib.c	70;"	d	file:
+jtag_led_red_off	jtaglib.c	73;"	d	file:
+jtag_led_red_on	jtaglib.c	72;"	d	file:
+jtag_read_mem	jtaglib.c	/^uint16_t jtag_read_mem( struct jtdev *p,$/;"	f
+jtag_read_mem_quick	jtaglib.c	/^void jtag_read_mem_quick( struct jtdev *p,$/;"	f
+jtag_read_reg	jtaglib.c	/^address_t jtag_read_reg( struct jtdev *p, int reg )$/;"	f
+jtag_release_cpu	jtaglib.c	/^static void jtag_release_cpu(struct jtdev *p)$/;"	f	file:
+jtag_release_device	jtaglib.c	/^void jtag_release_device( struct jtdev *p, address_t address )$/;"	f
+jtag_reset_tap	jtaglib.c	/^static void jtag_reset_tap(struct jtdev *p)$/;"	f	file:
+jtag_rst_clr	jtaglib.c	66;"	d	file:
+jtag_rst_set	jtaglib.c	65;"	d	file:
+jtag_set_instruction_fetch	jtaglib.c	/^static int jtag_set_instruction_fetch(struct jtdev *p)$/;"	f	file:
+jtag_shift	jtaglib.c	/^static unsigned int jtag_shift( struct jtdev *p,$/;"	f	file:
+jtag_tck_clr	jtaglib.c	60;"	d	file:
+jtag_tck_set	jtaglib.c	59;"	d	file:
+jtag_tclk_clr	jtaglib.c	64;"	d	file:
+jtag_tclk_prep	jtaglib.c	/^static void jtag_tclk_prep (struct jtdev *p)$/;"	f	file:
+jtag_tclk_set	jtaglib.c	63;"	d	file:
+jtag_tdi_clr	jtaglib.c	62;"	d	file:
+jtag_tdi_set	jtaglib.c	61;"	d	file:
+jtag_tms_clr	jtaglib.c	58;"	d	file:
+jtag_tms_set	jtaglib.c	57;"	d	file:
+jtag_tst_clr	jtaglib.c	68;"	d	file:
+jtag_tst_set	jtaglib.c	67;"	d	file:
+jtag_verify_mem	jtaglib.c	/^int jtag_verify_mem( struct jtdev *p,$/;"	f
+jtag_verify_psa	jtaglib.c	/^static int jtag_verify_psa( struct jtdev *p,$/;"	f	file:
+jtag_write_flash	jtaglib.c	/^void jtag_write_flash( struct jtdev *p,$/;"	f
+jtag_write_mem	jtaglib.c	/^void jtag_write_mem( struct jtdev *p,$/;"	f
+jtag_write_mem_quick	jtaglib.c	/^void jtag_write_mem_quick( struct jtdev *p,$/;"	f
+jtag_write_reg	jtaglib.c	/^void jtag_write_reg( struct jtdev *p, int reg, address_t value )$/;"	f
+JTAGLIB_H_	jtaglib.h	26;"	d
+JTAG_ERASE_MAIN	jtaglib.h	36;"	d
+JTAG_ERASE_MASS	jtaglib.h	35;"	d
+JTAG_ERASE_SGMT	jtaglib.h	37;"	d
+ACK	jtdev.c	50;"	d	file:
+AUTOFEED	jtdev.c	55;"	d	file:
+BUSY	jtdev.c	51;"	d	file:
+DATA0	jtdev.c	37;"	d	file:
+DATA1	jtdev.c	38;"	d	file:
+DATA2	jtdev.c	39;"	d	file:
+DATA3	jtdev.c	40;"	d	file:
+DATA4	jtdev.c	41;"	d	file:
+DATA5	jtdev.c	42;"	d	file:
+DATA6	jtdev.c	43;"	d	file:
+DATA7	jtdev.c	44;"	d	file:
+ENABLE	jtdev.c	69;"	d	file:
+ERR	jtdev.c	47;"	d	file:
+INIT	jtdev.c	56;"	d	file:
+IRQEN	jtdev.c	58;"	d	file:
+LED_GREEN	jtdev.c	70;"	d	file:
+LED_RED	jtdev.c	71;"	d	file:
+PE	jtdev.c	49;"	d	file:
+POWER	jtdev.c	67;"	d	file:
+RESET	jtdev.c	68;"	d	file:
+SEL	jtdev.c	48;"	d	file:
+SELECTIN	jtdev.c	57;"	d	file:
+STROBE	jtdev.c	54;"	d	file:
+TCK	jtdev.c	65;"	d	file:
+TCLK	jtdev.c	73;"	d	file:
+TDI	jtdev.c	63;"	d	file:
+TDO	jtdev.c	62;"	d	file:
+TEST	jtdev.c	61;"	d	file:
+TMS	jtdev.c	64;"	d	file:
+XOUT	jtdev.c	66;"	d	file:
+do_ppwcontrol	jtdev.c	/^static void do_ppwcontrol(struct jtdev *p)$/;"	f	file:
+do_ppwdata	jtdev.c	/^static void do_ppwdata(struct jtdev *p)$/;"	f	file:
+jtdev_close	jtdev.c	/^void jtdev_close(struct jtdev *p) { }$/;"	f
+jtdev_close	jtdev.c	/^void jtdev_close(struct jtdev *p)$/;"	f
+jtdev_connect	jtdev.c	/^void jtdev_connect(struct jtdev *p) { }$/;"	f
+jtdev_connect	jtdev.c	/^void jtdev_connect(struct jtdev *p)$/;"	f
+jtdev_led_green	jtdev.c	/^void jtdev_led_green(struct jtdev *p, int out) { }$/;"	f
+jtdev_led_green	jtdev.c	/^void jtdev_led_green(struct jtdev *p, int out)$/;"	f
+jtdev_led_red	jtdev.c	/^void jtdev_led_red(struct jtdev *p, int out) { }$/;"	f
+jtdev_led_red	jtdev.c	/^void jtdev_led_red(struct jtdev *p, int out)$/;"	f
+jtdev_open	jtdev.c	/^int jtdev_open(struct jtdev *p, const char *device)$/;"	f
+jtdev_power_off	jtdev.c	/^void jtdev_power_off(struct jtdev *p) { }$/;"	f
+jtdev_power_off	jtdev.c	/^void jtdev_power_off(struct jtdev *p)$/;"	f
+jtdev_power_on	jtdev.c	/^void jtdev_power_on(struct jtdev *p) { }$/;"	f
+jtdev_power_on	jtdev.c	/^void jtdev_power_on(struct jtdev *p)$/;"	f
+jtdev_release	jtdev.c	/^void jtdev_release(struct jtdev *p) { }$/;"	f
+jtdev_release	jtdev.c	/^void jtdev_release(struct jtdev *p)$/;"	f
+jtdev_rst	jtdev.c	/^void jtdev_rst(struct jtdev *p, int out) { }$/;"	f
+jtdev_rst	jtdev.c	/^void jtdev_rst(struct jtdev *p, int out)$/;"	f
+jtdev_tck	jtdev.c	/^void jtdev_tck(struct jtdev *p, int out) { }$/;"	f
+jtdev_tck	jtdev.c	/^void jtdev_tck(struct jtdev *p, int out)$/;"	f
+jtdev_tclk	jtdev.c	/^void jtdev_tclk(struct jtdev *p, int out) { }$/;"	f
+jtdev_tclk	jtdev.c	/^void jtdev_tclk(struct jtdev *p, int out)$/;"	f
+jtdev_tclk_get	jtdev.c	/^int jtdev_tclk_get(struct jtdev *p) { return 0; }$/;"	f
+jtdev_tclk_get	jtdev.c	/^int jtdev_tclk_get(struct jtdev *p)$/;"	f
+jtdev_tclk_strobe	jtdev.c	/^void jtdev_tclk_strobe(struct jtdev *p, unsigned int count) { }$/;"	f
+jtdev_tclk_strobe	jtdev.c	/^void jtdev_tclk_strobe(struct jtdev *p, unsigned int count)$/;"	f
+jtdev_tdi	jtdev.c	/^void jtdev_tdi(struct jtdev *p, int out) { }$/;"	f
+jtdev_tdi	jtdev.c	/^void jtdev_tdi(struct jtdev *p, int out)$/;"	f
+jtdev_tdo_get	jtdev.c	/^int jtdev_tdo_get(struct jtdev *p) { return 0; }$/;"	f
+jtdev_tdo_get	jtdev.c	/^int jtdev_tdo_get(struct jtdev *p)$/;"	f
+jtdev_tms	jtdev.c	/^void jtdev_tms(struct jtdev *p, int out) { }$/;"	f
+jtdev_tms	jtdev.c	/^void jtdev_tms(struct jtdev *p, int out)$/;"	f
+jtdev_tst	jtdev.c	/^void jtdev_tst(struct jtdev *p, int out) { }$/;"	f
+jtdev_tst	jtdev.c	/^void jtdev_tst(struct jtdev *p, int out)$/;"	f
+JTDEV_H_	jtdev.h	21;"	d
+control_register	jtdev.h	/^	uint8_t		control_register;$/;"	m	struct:jtdev
+data_register	jtdev.h	/^	uint8_t		data_register;$/;"	m	struct:jtdev
+failed	jtdev.h	/^	int		failed;$/;"	m	struct:jtdev
+jtdev	jtdev.h	/^struct jtdev {$/;"	s
+port	jtdev.h	/^	int		port;$/;"	m	struct:jtdev
+COPY_OFFSET	obl.c	29;"	d	file:
+COPY_VALID_ADDR	obl.c	30;"	d	file:
+FLASH_PAGE_SIZE	obl.c	28;"	d	file:
+IMAGE_MAGIC	obl.c	27;"	d	file:
+OBL_CMD_DEV_RESET	obl.c	/^	OBL_CMD_DEV_RESET	= 0x07,$/;"	e	enum:__anon8	file:
+OBL_CMD_DEV_VERSION	obl.c	/^	OBL_CMD_DEV_VERSION	= 0x08,$/;"	e	enum:__anon8	file:
+OBL_CMD_PROD_TEST	obl.c	/^	OBL_CMD_PROD_TEST	= 0x09$/;"	e	enum:__anon8	file:
+OBL_CMD_READ_FLASH	obl.c	/^	OBL_CMD_READ_FLASH	= 0x03,$/;"	e	enum:__anon8	file:
+OBL_CMD_READ_RAM	obl.c	/^	OBL_CMD_READ_RAM	= 0x01,$/;"	e	enum:__anon8	file:
+OBL_CMD_RF_SELF_TEST	obl.c	/^	OBL_CMD_RF_SELF_TEST	= 0x05,$/;"	e	enum:__anon8	file:
+OBL_CMD_SET_PROTECTION	obl.c	/^	OBL_CMD_SET_PROTECTION	= 0x06,$/;"	e	enum:__anon8	file:
+OBL_CMD_WRITE_FLASH	obl.c	/^	OBL_CMD_WRITE_FLASH	= 0x04,$/;"	e	enum:__anon8	file:
+OBL_CMD_WRITE_RAM	obl.c	/^	OBL_CMD_WRITE_RAM	= 0x02,$/;"	e	enum:__anon8	file:
+OBL_RESULT_COMMAND_FAULT	obl.c	/^	OBL_RESULT_COMMAND_FAULT	= 0xff$/;"	e	enum:__anon9	file:
+OBL_RESULT_NRF_LINK_FAULT	obl.c	/^	OBL_RESULT_NRF_LINK_FAULT	= 0x02,$/;"	e	enum:__anon9	file:
+OBL_RESULT_NRF_SPI_FAULT	obl.c	/^	OBL_RESULT_NRF_SPI_FAULT	= 0x01,$/;"	e	enum:__anon9	file:
+OBL_RESULT_OK	obl.c	/^	OBL_RESULT_OK			= 0x00,$/;"	e	enum:__anon9	file:
+interval_shift	obl.c	/^	int		interval_shift;$/;"	m	struct:progress_meter	file:
+last	obl.c	/^	uint32_t	last;$/;"	m	struct:progress_meter	file:
+load_image	obl.c	/^static int load_image(transport_t trans, const uint8_t *file_data,$/;"	f	file:
+obl_cmd_t	obl.c	/^} obl_cmd_t;$/;"	t	typeref:enum:__anon8	file:
+obl_get_version	obl.c	/^int obl_get_version(transport_t tr, uint32_t *ver_ret)$/;"	f
+obl_read_mem	obl.c	/^static int obl_read_mem(transport_t tr, uint32_t addr,$/;"	f	file:
+obl_reset	obl.c	/^int obl_reset(transport_t trans)$/;"	f
+obl_result_t	obl.c	/^} obl_result_t;$/;"	t	typeref:enum:__anon9	file:
+obl_update	obl.c	/^int obl_update(transport_t trans, const char *image_filename)$/;"	f
+obl_write_flash	obl.c	/^static int obl_write_flash(transport_t tr, uint32_t addr,$/;"	f	file:
+obl_xfer	obl.c	/^static int obl_xfer(transport_t tr, const uint8_t *command, int cmd_len,$/;"	f	file:
+progress_init	obl.c	/^static void progress_init(struct progress_meter *m, uint32_t size)$/;"	f	file:
+progress_meter	obl.c	/^struct progress_meter {$/;"	s	file:
+progress_update	obl.c	/^static void progress_update(struct progress_meter *m, const char *label,$/;"	f	file:
+read_file	obl.c	/^static uint8_t *read_file(const char *filename, unsigned int *len_ret)$/;"	f	file:
+total	obl.c	/^	uint32_t	total;$/;"	m	struct:progress_meter	file:
+transport_read_all	obl.c	/^static int transport_read_all(transport_t tr, uint8_t *data, int len)$/;"	f	file:
+verify_image	obl.c	/^static int verify_image(transport_t tr, uint32_t addr, uint32_t size,$/;"	f	file:
+write_image	obl.c	/^static int write_image(transport_t tr, uint32_t addr, uint32_t size,$/;"	f	file:
+write_valid_size	obl.c	/^static int write_valid_size(transport_t tr, uint32_t size)$/;"	f	file:
+OBL_H_	obl.h	20;"	d
+base	pif.c	/^  struct device		base;$/;"	m	struct:pif_device	typeref:struct:pif_device::device	file:
+device_pif	pif.c	/^const struct device_class device_pif = {$/;"	v	typeref:struct:device_class
+init_device	pif.c	/^static int init_device(struct jtdev *p)$/;"	f	file:
+jtag	pif.c	/^  struct jtdev		jtag;$/;"	m	struct:pif_device	typeref:struct:pif_device::jtdev	file:
+pif_ctl	pif.c	/^static int pif_ctl(device_t dev_base, device_ctl_t type)$/;"	f	file:
+pif_destroy	pif.c	/^static void pif_destroy(device_t dev_base)$/;"	f	file:
+pif_device	pif.c	/^struct pif_device {$/;"	s	file:
+pif_erase	pif.c	/^static int pif_erase( device_t dev_base,$/;"	f	file:
+pif_getregs	pif.c	/^static int pif_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+pif_open	pif.c	/^static device_t pif_open(const struct device_args *args)$/;"	f	file:
+pif_poll	pif.c	/^static device_status_t pif_poll(device_t dev_base)$/;"	f	file:
+pif_readmem	pif.c	/^static int pif_readmem( device_t  dev_base,$/;"	f	file:
+pif_setregs	pif.c	/^static int pif_setregs( device_t dev_base, const address_t* regs )$/;"	f	file:
+pif_writemem	pif.c	/^static int pif_writemem( device_t       dev_base,$/;"	f	file:
+read_words	pif.c	/^static int read_words( struct jtdev *p, address_t addr,$/;"	f	file:
+write_byte	pif.c	/^static int write_byte( struct jtdev *p,$/;"	f	file:
+write_flash_block	pif.c	/^static int write_flash_block( struct jtdev *p, address_t addr,$/;"	f	file:
+write_ram_word	pif.c	/^int write_ram_word( struct jtdev *p, address_t addr,$/;"	f
+PIF_H_	pif.h	27;"	d
+ACCVIE_MASK	sim.c	72;"	d	file:
+ACCVIFG_MASK	sim.c	78;"	d	file:
+ARITH_BITS	sim.c	349;"	d	file:
+FCTL3_ADDR	sim.c	68;"	d	file:
+GIE_MASK	sim.c	75;"	d	file:
+HI_MASK_INTERRUPT_IRQ	sim.c	93;"	d	file:
+IE1_ADDR	sim.c	65;"	d	file:
+IFG1_ADDR	sim.c	67;"	d	file:
+INTERRUPT_ACCV	sim.c	/^	INTERRUPT_ACCV,		\/* Flash Access Violation *\/$/;"	e	enum:__anon7	file:
+INTERRUPT_MASK	sim.c	/^	INTERRUPT_MASK,		\/* All maskable interrupts *\/$/;"	e	enum:__anon7	file:
+INTERRUPT_NMI	sim.c	/^	INTERRUPT_NMI,		\/* NMI *\/$/;"	e	enum:__anon7	file:
+INTERRUPT_NONE	sim.c	/^	INTERRUPT_NONE,$/;"	e	enum:__anon7	file:
+INTERRUPT_OF	sim.c	/^	INTERRUPT_OF,		\/* Oscilalator Fault *\/$/;"	e	enum:__anon7	file:
+INTERRUPT_RST	sim.c	/^	INTERRUPT_RST, 		\/* RST *\/$/;"	e	enum:__anon7	file:
+INTERRUPT_TOTAL_NUM	sim.c	/^	INTERRUPT_TOTAL_NUM$/;"	e	enum:__anon7	file:
+MEM_GETB	sim.c	198;"	d	file:
+MEM_GETW	sim.c	200;"	d	file:
+MEM_IO_END	sim.c	40;"	d	file:
+MEM_SETB	sim.c	199;"	d	file:
+MEM_SETW	sim.c	203;"	d	file:
+MEM_SIZE	sim.c	39;"	d	file:
+NMIIE_MASK	sim.c	73;"	d	file:
+NMIIFG_MASK	sim.c	76;"	d	file:
+NO_INSTR	sim.c	91;"	d	file:
+NO_IRQ	sim.c	92;"	d	file:
+OFIE_MASK	sim.c	71;"	d	file:
+OFIFG_MASK	sim.c	77;"	d	file:
+WDTCTL_ADDR	sim.c	66;"	d	file:
+WDTNMI_MASK	sim.c	74;"	d	file:
+add_child	sim.c	/^void add_child(search_node *parent_node, search_node *new_node)$/;"	f
+base	sim.c	/^	struct device           base;$/;"	m	struct:sim_device	typeref:struct:sim_device::device	file:
+create_child_node	sim.c	/^void create_child_node(struct sim_device *dev, search_node *parent, $/;"	f
+create_node	sim.c	/^search_node *create_node(interrupt_t type, uint16_t instr_addr, int irq, $/;"	f
+current_insn	sim.c	/^	uint16_t                current_insn;$/;"	m	struct:sim_device	file:
+delete_prev_sib_subtree	sim.c	/^void delete_prev_sib_subtree(search_node *node)$/;"	f
+delete_subtree	sim.c	/^void delete_subtree(search_node *node)$/;"	f
+depth	sim.c	/^	int depth;$/;"	m	struct:search_node	file:
+device_sim	sim.c	/^const struct device_class device_sim = {$/;"	v	typeref:struct:device_class
+do_reset	sim.c	/^static void do_reset(struct sim_device *dev)$/;"	f	file:
+entry	sim.c	/^struct entry {$/;"	s	file:
+fetch_operand	sim.c	/^static int fetch_operand(struct sim_device *dev,$/;"	f	file:
+get_next_instr	sim.c	/^address_t get_next_instr(struct sim_device *dev)$/;"	f
+instr_addr	sim.c	/^	uint16_t instr_addr; \/* used only if this is not an interrupt *\/$/;"	m	struct:search_node	file:
+instr_after_jmp	sim.c	/^uint16_t instr_after_jmp(struct sim_device *dev, uint16_t ins)$/;"	f
+interrupt_t	sim.c	/^} interrupt_t;$/;"	t	typeref:enum:__anon7	file:
+irq	sim.c	/^	int irq;$/;"	m	struct:search_node	file:
+l_child	sim.c	/^	struct search_node *l_child;$/;"	m	struct:search_node	typeref:struct:search_node::search_node	file:
+memory	sim.c	/^	uint8_t                 memory[MEM_SIZE];$/;"	m	struct:sim_device	file:
+node	sim.c	/^  search_node *node;$/;"	m	struct:entry	file:
+parent	sim.c	/^	struct search_node *parent;$/;"	m	struct:search_node	typeref:struct:search_node::search_node	file:
+pop	sim.c	/^struct search_node *pop () {$/;"	f
+push	sim.c	/^void push( struct search_node *node ) {$/;"	f
+regs	sim.c	/^	uint16_t                regs[DEVICE_NUM_REGS];$/;"	m	struct:sim_device	file:
+running	sim.c	/^	int                     running;$/;"	m	struct:sim_device	file:
+saved_state	sim.c	/^	struct sim_device *saved_state;$/;"	m	struct:search_node	typeref:struct:search_node::sim_device	file:
+search_node	sim.c	/^typedef struct search_node {$/;"	s	file:
+search_node	sim.c	/^} search_node;$/;"	t	typeref:struct:search_node	file:
+sibling	sim.c	/^	struct search_node *sibling;$/;"	m	struct:search_node	typeref:struct:search_node::search_node	file:
+sim_ctl	sim.c	/^static int sim_ctl(device_t dev_base, device_ctl_t op)$/;"	f	file:
+sim_destroy	sim.c	/^static void sim_destroy(device_t dev_base)$/;"	f	file:
+sim_device	sim.c	/^struct sim_device {$/;"	s	file:
+sim_erase	sim.c	/^static int sim_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+sim_getregs	sim.c	/^static int sim_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+sim_intsc	sim.c	/^static int sim_intsc(device_t dev_base, address_t vector_addr,$/;"	f	file:
+sim_open	sim.c	/^static device_t sim_open(const struct device_args *args)$/;"	f	file:
+sim_poll	sim.c	/^static device_status_t sim_poll(device_t dev_base)$/;"	f	file:
+sim_readmem	sim.c	/^static int sim_readmem(device_t dev_base, address_t addr,$/;"	f	file:
+sim_search	sim.c	/^static int sim_search(device_t dev_base, address_t n, $/;"	f	file:
+sim_setregs	sim.c	/^static int sim_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+sim_writemem	sim.c	/^static int sim_writemem(device_t dev_base, address_t addr,$/;"	f	file:
+step_cpu	sim.c	/^static int step_cpu(struct sim_device *dev)$/;"	f	file:
+step_double	sim.c	/^static int step_double(struct sim_device *dev, uint16_t ins)$/;"	f	file:
+step_jump	sim.c	/^static int step_jump(struct sim_device *dev, uint16_t ins)$/;"	f	file:
+step_single	sim.c	/^static int step_single(struct sim_device *dev, uint16_t ins)$/;"	f	file:
+step_system	sim.c	/^static int step_system(struct sim_device *dev)$/;"	f	file:
+store_operand	sim.c	/^static int store_operand(struct sim_device *dev,$/;"	f	file:
+trigger_interrupt	sim.c	/^void trigger_interrupt(struct sim_device *dev, int irq)$/;"	f
+trigger_interrupt_set_flags	sim.c	/^void trigger_interrupt_set_flags(struct sim_device *dev, int irq, interrupt_t type)$/;"	f
+type	sim.c	/^	interrupt_t type;$/;"	m	struct:search_node	file:
+watchpoint_check	sim.c	/^static void watchpoint_check(struct sim_device *dev, uint16_t addr,$/;"	f	file:
+watchpoint_hit	sim.c	/^	int			watchpoint_hit;$/;"	m	struct:sim_device	file:
+SIM_H_	sim.h	20;"	d
+MID_BREAKPOINT	tilib.c	96;"	d	file:
+MID_CPU_STOPPED	tilib.c	100;"	d	file:
+MID_HALT_ANY	tilib.c	102;"	d	file:
+MID_SINGLE_STEP	tilib.c	95;"	d	file:
+MID_STATE	tilib.c	98;"	d	file:
+MID_STORAGE	tilib.c	97;"	d	file:
+MID_WARNING	tilib.c	99;"	d	file:
+MSP430_Close	tilib.c	/^	STATUS_T TIDLL (*MSP430_Close)(long vccOff);$/;"	m	struct:tilib_device	file:
+MSP430_Configure	tilib.c	/^	STATUS_T TIDLL (*MSP430_Configure)(long mode, long value);$/;"	m	struct:tilib_device	file:
+MSP430_EEM_Init	tilib.c	/^	STATUS_T TIDLL (*MSP430_EEM_Init)(DLL430_EVENTNOTIFY_FUNC callback,$/;"	m	struct:tilib_device	file:
+MSP430_EEM_SetBreakpoint	tilib.c	/^	STATUS_T TIDLL (*MSP430_EEM_SetBreakpoint)(uint16_t *pwBpHandle,$/;"	m	struct:tilib_device	file:
+MSP430_Erase	tilib.c	/^	STATUS_T TIDLL (*MSP430_Erase)(long type, long address, long length);$/;"	m	struct:tilib_device	file:
+MSP430_Error_Number	tilib.c	/^	STATUS_T TIDLL (*MSP430_Error_Number)(void);$/;"	m	struct:tilib_device	file:
+MSP430_Error_String	tilib.c	/^	const char *TIDLL (*MSP430_Error_String)(long errNumber);$/;"	m	struct:tilib_device	file:
+MSP430_FET_FwUpdate	tilib.c	/^	STATUS_T TIDLL (*MSP430_FET_FwUpdate)(char* lpszFileName,$/;"	m	struct:tilib_device	file:
+MSP430_GetFoundDevice	tilib.c	/^	STATUS_T TIDLL (*MSP430_GetFoundDevice)(char *FoundDevice,$/;"	m	struct:tilib_device	file:
+MSP430_GetNameOfUsbIf	tilib.c	/^	STATUS_T TIDLL (*MSP430_GetNameOfUsbIf)(long idx, char **name,$/;"	m	struct:tilib_device	file:
+MSP430_GetNumberOfUsbIfs	tilib.c	/^	STATUS_T TIDLL (*MSP430_GetNumberOfUsbIfs)(long* number);$/;"	m	struct:tilib_device	file:
+MSP430_Initialize	tilib.c	/^	STATUS_T TIDLL (*MSP430_Initialize)(char *port, long *version);$/;"	m	struct:tilib_device	file:
+MSP430_Memory	tilib.c	/^	STATUS_T TIDLL (*MSP430_Memory)(long address, char *buffer,$/;"	m	struct:tilib_device	file:
+MSP430_OpenDevice	tilib.c	/^	STATUS_T TIDLL (*MSP430_OpenDevice)(char *Device, char *Password,$/;"	m	struct:tilib_device	file:
+MSP430_Registers	tilib.c	/^	STATUS_T TIDLL (*MSP430_Registers)(long *registers, long mask,$/;"	m	struct:tilib_device	file:
+MSP430_Reset	tilib.c	/^	STATUS_T TIDLL (*MSP430_Reset)(long method, long execute,$/;"	m	struct:tilib_device	file:
+MSP430_Run	tilib.c	/^	STATUS_T TIDLL (*MSP430_Run)(long mode, long releaseJTAG);$/;"	m	struct:tilib_device	file:
+MSP430_State	tilib.c	/^	STATUS_T TIDLL (*MSP430_State)(long *state, long stop,$/;"	m	struct:tilib_device	file:
+MSP430_VCC	tilib.c	/^	STATUS_T TIDLL (*MSP430_VCC)(long voltage);$/;"	m	struct:tilib_device	file:
+TIDLL	tilib.c	33;"	d	file:
+TIDLL	tilib.c	36;"	d	file:
+active_fperm	tilib.c	/^	fperm_t			active_fperm;$/;"	m	struct:tilib_device	file:
+base	tilib.c	/^	struct device		base;$/;"	m	struct:tilib_device	typeref:struct:tilib_device::device	file:
+bp_handles	tilib.c	/^	uint16_t		bp_handles[DEVICE_MAX_BREAKPOINTS];$/;"	m	struct:tilib_device	file:
+device_tilib	tilib.c	/^const struct device_class device_tilib = {$/;"	v	typeref:struct:device_class
+do_findUif	tilib.c	/^static int do_findUif(struct tilib_device *dev)$/;"	f	file:
+do_fw_update	tilib.c	/^static int do_fw_update(struct tilib_device *dev, const char *filename)$/;"	f	file:
+do_halt	tilib.c	/^static int do_halt(struct tilib_device *dev)$/;"	f	file:
+do_init	tilib.c	/^static int do_init(struct tilib_device *dev, const struct device_args *args)$/;"	f	file:
+do_step	tilib.c	/^static int do_step(struct tilib_device *dev)$/;"	f	file:
+event_fetch	tilib.c	/^static uint32_t event_fetch(struct tilib_device *dev)$/;"	f	file:
+event_notify	tilib.c	/^static void event_notify(unsigned int msg_id, unsigned int w_param,$/;"	f	file:
+fw_progress	tilib.c	/^static void fw_progress(unsigned int msg_id, unsigned long w_param,$/;"	f	file:
+get_all_funcs	tilib.c	/^static int get_all_funcs(struct tilib_device *dev)$/;"	f	file:
+get_func	tilib.c	/^static void *get_func(dynload_handle_t hnd, const char *name)$/;"	f	file:
+hnd	tilib.c	/^	dynload_handle_t	hnd;$/;"	m	struct:tilib_device	file:
+load_break	tilib.c	/^static void load_break(BpParameter_t *param, address_t addr)$/;"	f	file:
+load_complex	tilib.c	/^static void load_complex(BpParameter_t *param, address_t addr,$/;"	f	file:
+mailbox	tilib.c	/^	uint32_t		mailbox;$/;"	m	struct:tilib_device	file:
+mb_lock	tilib.c	/^	thread_lock_t		mb_lock;$/;"	m	struct:tilib_device	file:
+my_message_ids	tilib.c	/^static const MessageID_t my_message_ids = {$/;"	v	file:
+refresh_bps	tilib.c	/^static int refresh_bps(struct tilib_device *dev)$/;"	f	file:
+refresh_fperm	tilib.c	/^static int refresh_fperm(struct tilib_device *dev)$/;"	f	file:
+report_error	tilib.c	/^static void report_error(struct tilib_device *dev, const char *what)$/;"	f	file:
+ti_erase_type	tilib.c	/^static long ti_erase_type(device_erase_type_t e)$/;"	f	file:
+tilib_ctl	tilib.c	/^static int tilib_ctl(device_t dev_base, device_ctl_t op)$/;"	f	file:
+tilib_destroy	tilib.c	/^static void tilib_destroy(device_t dev_base)$/;"	f	file:
+tilib_device	tilib.c	/^struct tilib_device {$/;"	s	file:
+tilib_erase	tilib.c	/^static int tilib_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+tilib_filename	tilib.c	/^static const char tilib_filename[] = "MSP430.DLL";$/;"	v	file:
+tilib_filename	tilib.c	/^static const char tilib_filename[] = "libmsp430.so";$/;"	v	file:
+tilib_getregs	tilib.c	/^static int tilib_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+tilib_open	tilib.c	/^static device_t tilib_open(const struct device_args *args)$/;"	f	file:
+tilib_poll	tilib.c	/^static device_status_t tilib_poll(device_t dev_base)$/;"	f	file:
+tilib_readmem	tilib.c	/^static int tilib_readmem(device_t dev_base, address_t addr,$/;"	f	file:
+tilib_setregs	tilib.c	/^static int tilib_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+tilib_writemem	tilib.c	/^static int tilib_writemem(device_t dev_base, address_t addr,$/;"	f	file:
+uifPath	tilib.c	/^	char			uifPath[1024];$/;"	m	struct:tilib_device	file:
+TILIB_H_	tilib.h	20;"	d
+BL_DATA_BLOCK_PROGRAMMED	tilib_defs.h	/^	BL_DATA_BLOCK_PROGRAMMED = 4,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_ERASE_FIRMWARE	tilib_defs.h	/^	BL_ERASE_FIRMWARE = 2,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_ERASE_INT_VECTORS	tilib_defs.h	/^	BL_ERASE_INT_VECTORS = 1,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_EXIT	tilib_defs.h	/^	BL_EXIT = 5,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_INIT	tilib_defs.h	/^	BL_INIT = 0,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_PROGRAM_FIRMWARE	tilib_defs.h	/^	BL_PROGRAM_FIRMWARE = 3,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_UPDATE_DONE	tilib_defs.h	/^	BL_UPDATE_DONE = 6,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_UPDATE_ERROR	tilib_defs.h	/^	BL_UPDATE_ERROR = 7,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_WAIT_FOR_TIMEOUT	tilib_defs.h	/^	BL_WAIT_FOR_TIMEOUT = 8$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BP_BRK	tilib_defs.h	/^	BP_BRK = 1,$/;"	e	enum:BpAction
+BP_BRK_STO	tilib_defs.h	/^	BP_BRK_STO = 3$/;"	e	enum:BpAction
+BP_CLEAR	tilib_defs.h	/^	BP_CLEAR = 0,$/;"	e	enum:BpMode
+BP_CODE	tilib_defs.h	/^	BP_CODE = 1,$/;"	e	enum:BpMode
+BP_COMPLEX	tilib_defs.h	/^	BP_COMPLEX = 3$/;"	e	enum:BpMode
+BP_COND	tilib_defs.h	/^	BP_COND = 1$/;"	e	enum:BpCondition
+BP_DMA	tilib_defs.h	/^	BP_DMA = 9,$/;"	e	enum:BpAccess
+BP_DONT_CARE	tilib_defs.h	/^	BP_DONT_CARE = 3,$/;"	e	enum:BpAccess
+BP_EQUAL	tilib_defs.h	/^	BP_EQUAL = 0,$/;"	e	enum:BpOperat
+BP_FETCH	tilib_defs.h	/^	BP_FETCH = 0,$/;"	e	enum:BpAccess
+BP_FETCH_HOLD	tilib_defs.h	/^	BP_FETCH_HOLD = 1,$/;"	e	enum:BpAccess
+BP_GREATER	tilib_defs.h	/^	BP_GREATER = 1,$/;"	e	enum:BpOperat
+BP_INSIDE	tilib_defs.h	/^	BP_INSIDE = 0,$/;"	e	enum:BpRangeAction
+BP_LOWER	tilib_defs.h	/^	BP_LOWER = 2,$/;"	e	enum:BpOperat
+BP_MAB	tilib_defs.h	/^	BP_MAB = 0,$/;"	e	enum:BpType
+BP_MDB	tilib_defs.h	/^	BP_MDB = 1,$/;"	e	enum:BpType
+BP_NONE	tilib_defs.h	/^	BP_NONE = 0,$/;"	e	enum:BpAction
+BP_NO_COND	tilib_defs.h	/^	BP_NO_COND = 0,$/;"	e	enum:BpCondition
+BP_NO_DMA	tilib_defs.h	/^	BP_NO_DMA = 10,$/;"	e	enum:BpAccess
+BP_NO_FETCH	tilib_defs.h	/^	BP_NO_FETCH = 2,$/;"	e	enum:BpAccess
+BP_NO_FETCH_NO_DMA	tilib_defs.h	/^	BP_NO_FETCH_NO_DMA = 8,$/;"	e	enum:BpAccess
+BP_NO_FETCH_READ	tilib_defs.h	/^	BP_NO_FETCH_READ = 4,$/;"	e	enum:BpAccess
+BP_NO_FETCH_READ_NO_DMA	tilib_defs.h	/^	BP_NO_FETCH_READ_NO_DMA = 12,$/;"	e	enum:BpAccess
+BP_NO_FETCH_WRITE	tilib_defs.h	/^	BP_NO_FETCH_WRITE = 5,$/;"	e	enum:BpAccess
+BP_OUTSIDE	tilib_defs.h	/^	BP_OUTSIDE = 1$/;"	e	enum:BpRangeAction
+BP_RANGE	tilib_defs.h	/^	BP_RANGE = 2,$/;"	e	enum:BpMode
+BP_READ	tilib_defs.h	/^	BP_READ = 6,$/;"	e	enum:BpAccess
+BP_READ_DMA	tilib_defs.h	/^	BP_READ_DMA = 14,$/;"	e	enum:BpAccess
+BP_READ_NO_DMA	tilib_defs.h	/^	BP_READ_NO_DMA = 13,$/;"	e	enum:BpAccess
+BP_REGISTER	tilib_defs.h	/^	BP_REGISTER = 2$/;"	e	enum:BpType
+BP_STO	tilib_defs.h	/^	BP_STO = 2,$/;"	e	enum:BpAction
+BP_UNEQUAL	tilib_defs.h	/^	BP_UNEQUAL = 3$/;"	e	enum:BpOperat
+BP_WRITE	tilib_defs.h	/^	BP_WRITE = 7,$/;"	e	enum:BpAccess
+BP_WRITE_DMA	tilib_defs.h	/^	BP_WRITE_DMA = 15$/;"	e	enum:BpAccess
+BP_WRITE_NO_DMA	tilib_defs.h	/^	BP_WRITE_NO_DMA = 11,$/;"	e	enum:BpAccess
+BREAKPOINT	tilib_defs.h	/^typedef struct BREAKPOINT {$/;"	s
+BREAKPOINT_HIT	tilib_defs.h	/^        BREAKPOINT_HIT = 3,$/;"	e	enum:STATE_MODES
+BYTE	tilib_defs.h	/^typedef uint8_t BYTE;$/;"	t
+BpAccess	tilib_defs.h	/^typedef enum BpAccess {$/;"	g
+BpAccess_t	tilib_defs.h	/^} BpAccess_t;$/;"	t	typeref:enum:BpAccess
+BpAction	tilib_defs.h	/^typedef enum BpAction {$/;"	g
+BpAction_t	tilib_defs.h	/^} BpAction_t;$/;"	t	typeref:enum:BpAction
+BpCondition	tilib_defs.h	/^typedef enum BpCondition {$/;"	g
+BpCondition_t	tilib_defs.h	/^} BpCondition_t;$/;"	t	typeref:enum:BpCondition
+BpMode	tilib_defs.h	/^typedef enum BpMode {$/;"	g
+BpMode_t	tilib_defs.h	/^} BpMode_t;$/;"	t	typeref:enum:BpMode
+BpOperat	tilib_defs.h	/^typedef enum BpOperat {$/;"	g
+BpOperat_t	tilib_defs.h	/^} BpOperat_t;$/;"	t	typeref:enum:BpOperat
+BpParameter_t	tilib_defs.h	/^} BpParameter_t;$/;"	t	typeref:struct:BREAKPOINT
+BpRangeAction	tilib_defs.h	/^typedef enum BpRangeAction {$/;"	g
+BpRangeAction_t	tilib_defs.h	/^} BpRangeAction_t;$/;"	t	typeref:enum:BpRangeAction
+BpType	tilib_defs.h	/^typedef enum BpType {$/;"	g
+BpType_t	tilib_defs.h	/^} BpType_t;$/;"	t	typeref:enum:BpType
+CHAR	tilib_defs.h	/^typedef char CHAR;$/;"	t
+CLK_CNTRL_MODE	tilib_defs.h	/^        CLK_CNTRL_MODE = 2,$/;"	e	enum:CONFIG_MODE
+CONFIG_MODE	tilib_defs.h	/^enum CONFIG_MODE {$/;"	g
+DEBUG_LPM_X	tilib_defs.h	/^	DEBUG_LPM_X = 14$/;"	e	enum:CONFIG_MODE
+DEVICE_CODE	tilib_defs.h	/^	DEVICE_CODE = 12,$/;"	e	enum:CONFIG_MODE
+DEVICE_T	tilib_defs.h	/^union DEVICE_T {$/;"	u
+DLL430_EVENTNOTIFY_FUNC	tilib_defs.h	/^typedef void (*DLL430_EVENTNOTIFY_FUNC)$/;"	t
+DLL430_FET_NOTIFY_FUNC	tilib_defs.h	/^typedef void (*DLL430_FET_NOTIFY_FUNC) (unsigned int MsgId,$/;"	t
+EDT_TRACE_MODE	tilib_defs.h	/^        EDT_TRACE_MODE = 7,$/;"	e	enum:CONFIG_MODE
+EMULATION_MODE	tilib_defs.h	/^        EMULATION_MODE = 1,$/;"	e	enum:CONFIG_MODE
+ERASE_ALL	tilib_defs.h	/^        ERASE_ALL = 2, \/**< Erase all MAIN and INFORMATION memory *\/$/;"	e	enum:ERASE_TYPE
+ERASE_MAIN	tilib_defs.h	/^        ERASE_MAIN = 1, \/**< Erase all MAIN memory *\/$/;"	e	enum:ERASE_TYPE
+ERASE_SEGMENT	tilib_defs.h	/^        ERASE_SEGMENT = 0, \/**< Erase a segment *\/$/;"	e	enum:ERASE_TYPE
+ERASE_TYPE	tilib_defs.h	/^enum ERASE_TYPE {$/;"	g
+FLASH_SWOP	tilib_defs.h	/^        FLASH_SWOP = 6,$/;"	e	enum:CONFIG_MODE
+FLASH_TEST_MODE	tilib_defs.h	/^        FLASH_TEST_MODE = 4,$/;"	e	enum:CONFIG_MODE
+FORCE_RESET	tilib_defs.h	/^	FORCE_RESET = (1 << 3)$/;"	e	enum:RESET_METHOD
+FREE_RUN	tilib_defs.h	/^        FREE_RUN = 1,$/;"	e	enum:RUN_MODES
+HasFramMemroy	tilib_defs.h	/^		WORD HasFramMemroy;$/;"	m	struct:DEVICE_T::__anon2
+INTERFACE_MODE	tilib_defs.h	/^        INTERFACE_MODE = 8,$/;"	e	enum:CONFIG_MODE
+LOCKED_FLASH_ACCESS	tilib_defs.h	/^        LOCKED_FLASH_ACCESS = 5,$/;"	e	enum:CONFIG_MODE
+LONG	tilib_defs.h	/^typedef long LONG;$/;"	t
+LPMX5_MODE	tilib_defs.h	/^        LPMX5_MODE = 4,$/;"	e	enum:STATE_MODES
+LPMX5_WAKEUP	tilib_defs.h	/^        LPMX5_WAKEUP = 5$/;"	e	enum:STATE_MODES
+MCLK_CNTRL_MODE	tilib_defs.h	/^        MCLK_CNTRL_MODE = 3,$/;"	e	enum:CONFIG_MODE
+MESSAGE_ID	tilib_defs.h	/^typedef struct MESSAGE_ID {$/;"	s
+MessageID_t	tilib_defs.h	/^} MessageID_t;$/;"	t	typeref:struct:MESSAGE_ID
+PUC_RESET	tilib_defs.h	/^	PUC_RESET   = (1 << 0), \/**< Power up clear (i.e., a "soft") reset *\/$/;"	e	enum:RESET_METHOD
+RAM_PRESERVE_MODE	tilib_defs.h	/^	RAM_PRESERVE_MODE = 10,$/;"	e	enum:CONFIG_MODE
+READ	tilib_defs.h	/^	READ = 1,$/;"	e	enum:READ_WRITE
+READ_WRITE	tilib_defs.h	/^enum READ_WRITE {$/;"	g
+RESET_METHOD	tilib_defs.h	/^enum RESET_METHOD {$/;"	g
+RST_RESET	tilib_defs.h	/^	RST_RESET   = (1 << 1), \/**< RST\/NMI (i.e., "hard") reset *\/$/;"	e	enum:RESET_METHOD
+RUNNING	tilib_defs.h	/^        RUNNING = 1,$/;"	e	enum:STATE_MODES
+RUN_MODES	tilib_defs.h	/^enum RUN_MODES {$/;"	g
+RUN_TO_BREAKPOINT	tilib_defs.h	/^        RUN_TO_BREAKPOINT = 3$/;"	e	enum:RUN_MODES
+SET_MDB_BEFORE_RUN	tilib_defs.h	/^        SET_MDB_BEFORE_RUN = 9,$/;"	e	enum:CONFIG_MODE
+SINGLE_STEP	tilib_defs.h	/^        SINGLE_STEP = 2,$/;"	e	enum:RUN_MODES
+SINGLE_STEP_COMPLETE	tilib_defs.h	/^        SINGLE_STEP_COMPLETE = 2,$/;"	e	enum:STATE_MODES
+STATE_MODES	tilib_defs.h	/^enum STATE_MODES {$/;"	g
+STATUS_T	tilib_defs.h	/^typedef long STATUS_T;$/;"	t
+STOPPED	tilib_defs.h	/^        STOPPED = 0,$/;"	e	enum:STATE_MODES
+TILIB_DEFS_H_	tilib_defs.h	20;"	d
+TrigerMask	tilib_defs.h	/^		WORD TrigerMask;$/;"	m	struct:DEVICE_T::__anon2
+ULONG	tilib_defs.h	/^typedef unsigned long ULONG;$/;"	t
+UNLOCK_BSL_MODE	tilib_defs.h	/^	UNLOCK_BSL_MODE =11,$/;"	e	enum:CONFIG_MODE
+UPDATE_STATUS_MESSAGES	tilib_defs.h	/^typedef enum UPDATE_STATUS_MESSAGES {$/;"	g
+UPDATE_STATUS_MESSAGES_t	tilib_defs.h	/^} UPDATE_STATUS_MESSAGES_t;$/;"	t	typeref:enum:UPDATE_STATUS_MESSAGES
+VCC_RESET	tilib_defs.h	/^	VCC_RESET   = (1 << 2), \/**< Cycle Vcc (i.e., a "power on") reset *\/$/;"	e	enum:RESET_METHOD
+VERIFICATION_MODE	tilib_defs.h	/^        VERIFICATION_MODE = 0,$/;"	e	enum:CONFIG_MODE
+WORD	tilib_defs.h	/^typedef uint16_t WORD;$/;"	t
+WRITE	tilib_defs.h	/^	WRITE = 0,$/;"	e	enum:READ_WRITE
+WRITE_EXTERNAL_MEMORY	tilib_defs.h	/^	WRITE_EXTERNAL_MEMORY = 13,$/;"	e	enum:CONFIG_MODE
+bpAccess	tilib_defs.h	/^	BpAccess_t        bpAccess;$/;"	m	struct:BREAKPOINT
+bpAction	tilib_defs.h	/^	BpAction_t        bpAction;$/;"	m	struct:BREAKPOINT
+bpCondAccess	tilib_defs.h	/^	BpAccess_t        bpCondAccess;$/;"	m	struct:BREAKPOINT
+bpCondOperat	tilib_defs.h	/^	BpOperat_t        bpCondOperat;$/;"	m	struct:BREAKPOINT
+bpCondition	tilib_defs.h	/^	BpCondition_t     bpCondition;$/;"	m	struct:BREAKPOINT
+bpMode	tilib_defs.h	/^	BpMode_t          bpMode;$/;"	m	struct:BREAKPOINT
+bpOperat	tilib_defs.h	/^	BpOperat_t        bpOperat;$/;"	m	struct:BREAKPOINT
+bpRangeAction	tilib_defs.h	/^	BpRangeAction_t   bpRangeAction;$/;"	m	struct:BREAKPOINT
+bpType	tilib_defs.h	/^	BpType_t          bpType;$/;"	m	struct:BREAKPOINT
+bslEnd	tilib_defs.h	/^		WORD  bslEnd;$/;"	m	struct:DEVICE_T::__anon2
+bslStart	tilib_defs.h	/^		WORD  bslStart;$/;"	m	struct:DEVICE_T::__anon2
+buffer	tilib_defs.h	/^	CHAR buffer[110];$/;"	m	union:DEVICE_T
+clockControl	tilib_defs.h	/^		WORD  clockControl;$/;"	m	struct:DEVICE_T::__anon2
+coreIpId	tilib_defs.h	/^		WORD  coreIpId;$/;"	m	struct:DEVICE_T::__anon2
+cpuArch	tilib_defs.h	/^		BYTE  cpuArch;$/;"	m	struct:DEVICE_T::__anon2
+deviceIdPtr	tilib_defs.h	/^		ULONG deviceIdPtr;$/;"	m	struct:DEVICE_T::__anon2
+eemVersion	tilib_defs.h	/^		WORD  eemVersion;$/;"	m	struct:DEVICE_T::__anon2
+emulation	tilib_defs.h	/^		WORD  emulation;$/;"	m	struct:DEVICE_T::__anon2
+endian	tilib_defs.h	/^		WORD  endian;$/;"	m	struct:DEVICE_T::__anon2
+hasTestVpp	tilib_defs.h	/^		WORD  hasTestVpp;$/;"	m	struct:DEVICE_T::__anon2
+id	tilib_defs.h	/^		WORD  id;$/;"	m	struct:DEVICE_T::__anon2
+infoEnd	tilib_defs.h	/^		WORD  infoEnd;$/;"	m	struct:DEVICE_T::__anon2
+infoStart	tilib_defs.h	/^		WORD  infoStart;$/;"	m	struct:DEVICE_T::__anon2
+jtagId	tilib_defs.h	/^		BYTE  jtagId;$/;"	m	struct:DEVICE_T::__anon2
+lAddrVal	tilib_defs.h	/^	LONG              lAddrVal;$/;"	m	struct:BREAKPOINT
+lCondMask	tilib_defs.h	/^	LONG              lCondMask;$/;"	m	struct:BREAKPOINT
+lCondMdbVal	tilib_defs.h	/^	ULONG             lCondMdbVal;$/;"	m	struct:BREAKPOINT
+lMask	tilib_defs.h	/^	LONG              lMask;$/;"	m	struct:BREAKPOINT
+lRangeEndAdVa	tilib_defs.h	/^	LONG              lRangeEndAdVa;$/;"	m	struct:BREAKPOINT
+lReg	tilib_defs.h	/^	LONG              lReg;$/;"	m	struct:BREAKPOINT
+lcdEnd	tilib_defs.h	/^		WORD  lcdEnd;$/;"	m	struct:DEVICE_T::__anon2
+lcdStart	tilib_defs.h	/^		WORD  lcdStart;$/;"	m	struct:DEVICE_T::__anon2
+mainEnd	tilib_defs.h	/^		ULONG mainEnd;$/;"	m	struct:DEVICE_T::__anon2
+mainStart	tilib_defs.h	/^		WORD  mainStart;$/;"	m	struct:DEVICE_T::__anon2
+nBreakpoints	tilib_defs.h	/^		WORD  nBreakpoints;$/;"	m	struct:DEVICE_T::__anon2
+nBreakpointsDma	tilib_defs.h	/^		WORD nBreakpointsDma;$/;"	m	struct:DEVICE_T::__anon2
+nBreakpointsOptions	tilib_defs.h	/^		WORD nBreakpointsOptions;$/;"	m	struct:DEVICE_T::__anon2
+nBreakpointsReadWrite	tilib_defs.h	/^		WORD nBreakpointsReadWrite;$/;"	m	struct:DEVICE_T::__anon2
+nCombinations	tilib_defs.h	/^		WORD  nCombinations;$/;"	m	struct:DEVICE_T::__anon2
+nCycleCounter	tilib_defs.h	/^		WORD nCycleCounter;$/;"	m	struct:DEVICE_T::__anon2
+nCycleCounterOperations	tilib_defs.h	/^		WORD nCycleCounterOperations;$/;"	m	struct:DEVICE_T::__anon2
+nRegTrigger	tilib_defs.h	/^		WORD  nRegTrigger;$/;"	m	struct:DEVICE_T::__anon2
+nRegTriggerOperations	tilib_defs.h	/^		WORD nRegTriggerOperations;$/;"	m	struct:DEVICE_T::__anon2
+nSequencer	tilib_defs.h	/^		WORD nSequencer;$/;"	m	struct:DEVICE_T::__anon2
+nStateStorage	tilib_defs.h	/^		WORD nStateStorage ;$/;"	m	struct:DEVICE_T::__anon2
+ram2End	tilib_defs.h	/^		WORD  ram2End;$/;"	m	struct:DEVICE_T::__anon2
+ram2Start	tilib_defs.h	/^		WORD  ram2Start;$/;"	m	struct:DEVICE_T::__anon2
+ramEnd	tilib_defs.h	/^		WORD  ramEnd;$/;"	m	struct:DEVICE_T::__anon2
+ramStart	tilib_defs.h	/^		WORD  ramStart;$/;"	m	struct:DEVICE_T::__anon2
+string	tilib_defs.h	/^		BYTE  string[32];$/;"	m	struct:DEVICE_T::__anon2
+uiMsgIdBreakpoint	tilib_defs.h	/^	ULONG	uiMsgIdBreakpoint;$/;"	m	struct:MESSAGE_ID
+uiMsgIdCPUStopped	tilib_defs.h	/^	ULONG	uiMsgIdCPUStopped;$/;"	m	struct:MESSAGE_ID
+uiMsgIdSingleStep	tilib_defs.h	/^	ULONG	uiMsgIdSingleStep;$/;"	m	struct:MESSAGE_ID
+uiMsgIdState	tilib_defs.h	/^	ULONG	uiMsgIdState;$/;"	m	struct:MESSAGE_ID
+uiMsgIdStorage	tilib_defs.h	/^	ULONG	uiMsgIdStorage;$/;"	m	struct:MESSAGE_ID
+uiMsgIdWarning	tilib_defs.h	/^	ULONG	uiMsgIdWarning;$/;"	m	struct:MESSAGE_ID
+vccMaxOp	tilib_defs.h	/^		WORD  vccMaxOp;$/;"	m	struct:DEVICE_T::__anon2
+vccMinOp	tilib_defs.h	/^		WORD  vccMinOp;$/;"	m	struct:DEVICE_T::__anon2
+wExtCombine	tilib_defs.h	/^	WORD              wExtCombine;$/;"	m	struct:BREAKPOINT
diff -ruN mspdebug-0.22/.tags mspdebug-0.22-new/.tags
--- mspdebug-0.22/.tags	1969-12-31 19:00:00.000000000 -0500
+++ mspdebug-0.22-new/.tags	2014-02-06 00:38:30.828430000 -0500
@@ -0,0 +1,4687 @@
+!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
+!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
+!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
+!_TAG_PROGRAM_NAME	Exuberant Ctags	//
+!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
+!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
+ACCVIE_MASK	drivers/sim.c	46;"	d	file:
+ACCVIFG_MASK	drivers/sim.c	52;"	d	file:
+ACK	drivers/jtdev.c	50;"	d	file:
+ALIASDB_H_	ui/aliasdb.h	20;"	d
+ALL_ONES	util/dis.c	28;"	d	file:
+APP_DEBUG	drivers/goodfet.c	30;"	d	file:
+APP_JTAG430	drivers/goodfet.c	29;"	d	file:
+ARITH_BITS	drivers/sim.c	306;"	d	file:
+ARRAY_LEN	util/util.h	25;"	d
+AT_BASE	formats/elf_format.h	943;"	d
+AT_BASE_PLATFORM	formats/elf_format.h	973;"	d
+AT_CLKTCK	formats/elf_format.h	951;"	d
+AT_DCACHEBSIZE	formats/elf_format.h	963;"	d
+AT_EGID	formats/elf_format.h	950;"	d
+AT_ENTRY	formats/elf_format.h	945;"	d
+AT_EUID	formats/elf_format.h	948;"	d
+AT_EXECFD	formats/elf_format.h	938;"	d
+AT_EXECFN	formats/elf_format.h	977;"	d
+AT_FLAGS	formats/elf_format.h	944;"	d
+AT_FPUCW	formats/elf_format.h	960;"	d
+AT_GID	formats/elf_format.h	949;"	d
+AT_HWCAP	formats/elf_format.h	955;"	d
+AT_ICACHEBSIZE	formats/elf_format.h	964;"	d
+AT_IGNORE	formats/elf_format.h	937;"	d
+AT_IGNOREPPC	formats/elf_format.h	969;"	d
+AT_L1D_CACHESHAPE	formats/elf_format.h	987;"	d
+AT_L1I_CACHESHAPE	formats/elf_format.h	986;"	d
+AT_L2_CACHESHAPE	formats/elf_format.h	988;"	d
+AT_L3_CACHESHAPE	formats/elf_format.h	989;"	d
+AT_NOTELF	formats/elf_format.h	946;"	d
+AT_NULL	formats/elf_format.h	936;"	d
+AT_PAGESZ	formats/elf_format.h	942;"	d
+AT_PHDR	formats/elf_format.h	939;"	d
+AT_PHENT	formats/elf_format.h	940;"	d
+AT_PHNUM	formats/elf_format.h	941;"	d
+AT_PLATFORM	formats/elf_format.h	954;"	d
+AT_RANDOM	formats/elf_format.h	975;"	d
+AT_SECURE	formats/elf_format.h	971;"	d
+AT_SYSINFO	formats/elf_format.h	981;"	d
+AT_SYSINFO_EHDR	formats/elf_format.h	982;"	d
+AT_UCACHEBSIZE	formats/elf_format.h	965;"	d
+AT_UID	formats/elf_format.h	947;"	d
+AUTOFEED	drivers/jtdev.c	55;"	d	file:
+B460800	util/sport.c	41;"	d	file:
+B500000	util/sport.c	45;"	d	file:
+BINARY	Makefile	/^    BINARY = mspdebug$/;"	m
+BINARY	Makefile	/^    BINARY = mspdebug.exe$/;"	m
+BINDIR	Makefile	/^BINDIR = ${PREFIX}\/bin\/$/;"	m
+BINFILE_HAS_SYMS	formats/binfile.h	37;"	d
+BINFILE_HAS_TEXT	formats/binfile.h	38;"	d
+BINFILE_H_	formats/binfile.h	20;"	d
+BL_DATA_BLOCK_PROGRAMMED	drivers/tilib_defs.h	/^	BL_DATA_BLOCK_PROGRAMMED = 4,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_ERASE_FIRMWARE	drivers/tilib_defs.h	/^	BL_ERASE_FIRMWARE = 2,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_ERASE_INT_VECTORS	drivers/tilib_defs.h	/^	BL_ERASE_INT_VECTORS = 1,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_EXIT	drivers/tilib_defs.h	/^	BL_EXIT = 5,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_INIT	drivers/tilib_defs.h	/^	BL_INIT = 0,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_PROGRAM_FIRMWARE	drivers/tilib_defs.h	/^	BL_PROGRAM_FIRMWARE = 3,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_UPDATE_DONE	drivers/tilib_defs.h	/^	BL_UPDATE_DONE = 6,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_UPDATE_ERROR	drivers/tilib_defs.h	/^	BL_UPDATE_ERROR = 7,$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BL_WAIT_FOR_TIMEOUT	drivers/tilib_defs.h	/^	BL_WAIT_FOR_TIMEOUT = 8$/;"	e	enum:UPDATE_STATUS_MESSAGES
+BP_BRK	drivers/tilib_defs.h	/^	BP_BRK = 1,$/;"	e	enum:BpAction
+BP_BRK_STO	drivers/tilib_defs.h	/^	BP_BRK_STO = 3$/;"	e	enum:BpAction
+BP_CLEAR	drivers/tilib_defs.h	/^	BP_CLEAR = 0,$/;"	e	enum:BpMode
+BP_CODE	drivers/tilib_defs.h	/^	BP_CODE = 1,$/;"	e	enum:BpMode
+BP_COMPLEX	drivers/tilib_defs.h	/^	BP_COMPLEX = 3$/;"	e	enum:BpMode
+BP_COND	drivers/tilib_defs.h	/^	BP_COND = 1$/;"	e	enum:BpCondition
+BP_DMA	drivers/tilib_defs.h	/^	BP_DMA = 9,$/;"	e	enum:BpAccess
+BP_DONT_CARE	drivers/tilib_defs.h	/^	BP_DONT_CARE = 3,$/;"	e	enum:BpAccess
+BP_EQUAL	drivers/tilib_defs.h	/^	BP_EQUAL = 0,$/;"	e	enum:BpOperat
+BP_FETCH	drivers/tilib_defs.h	/^	BP_FETCH = 0,$/;"	e	enum:BpAccess
+BP_FETCH_HOLD	drivers/tilib_defs.h	/^	BP_FETCH_HOLD = 1,$/;"	e	enum:BpAccess
+BP_GREATER	drivers/tilib_defs.h	/^	BP_GREATER = 1,$/;"	e	enum:BpOperat
+BP_INSIDE	drivers/tilib_defs.h	/^	BP_INSIDE = 0,$/;"	e	enum:BpRangeAction
+BP_LOWER	drivers/tilib_defs.h	/^	BP_LOWER = 2,$/;"	e	enum:BpOperat
+BP_MAB	drivers/tilib_defs.h	/^	BP_MAB = 0,$/;"	e	enum:BpType
+BP_MDB	drivers/tilib_defs.h	/^	BP_MDB = 1,$/;"	e	enum:BpType
+BP_NONE	drivers/tilib_defs.h	/^	BP_NONE = 0,$/;"	e	enum:BpAction
+BP_NO_COND	drivers/tilib_defs.h	/^	BP_NO_COND = 0,$/;"	e	enum:BpCondition
+BP_NO_DMA	drivers/tilib_defs.h	/^	BP_NO_DMA = 10,$/;"	e	enum:BpAccess
+BP_NO_FETCH	drivers/tilib_defs.h	/^	BP_NO_FETCH = 2,$/;"	e	enum:BpAccess
+BP_NO_FETCH_NO_DMA	drivers/tilib_defs.h	/^	BP_NO_FETCH_NO_DMA = 8,$/;"	e	enum:BpAccess
+BP_NO_FETCH_READ	drivers/tilib_defs.h	/^	BP_NO_FETCH_READ = 4,$/;"	e	enum:BpAccess
+BP_NO_FETCH_READ_NO_DMA	drivers/tilib_defs.h	/^	BP_NO_FETCH_READ_NO_DMA = 12,$/;"	e	enum:BpAccess
+BP_NO_FETCH_WRITE	drivers/tilib_defs.h	/^	BP_NO_FETCH_WRITE = 5,$/;"	e	enum:BpAccess
+BP_OUTSIDE	drivers/tilib_defs.h	/^	BP_OUTSIDE = 1$/;"	e	enum:BpRangeAction
+BP_RANGE	drivers/tilib_defs.h	/^	BP_RANGE = 2,$/;"	e	enum:BpMode
+BP_READ	drivers/tilib_defs.h	/^	BP_READ = 6,$/;"	e	enum:BpAccess
+BP_READ_DMA	drivers/tilib_defs.h	/^	BP_READ_DMA = 14,$/;"	e	enum:BpAccess
+BP_READ_NO_DMA	drivers/tilib_defs.h	/^	BP_READ_NO_DMA = 13,$/;"	e	enum:BpAccess
+BP_REGISTER	drivers/tilib_defs.h	/^	BP_REGISTER = 2$/;"	e	enum:BpType
+BP_STO	drivers/tilib_defs.h	/^	BP_STO = 2,$/;"	e	enum:BpAction
+BP_UNEQUAL	drivers/tilib_defs.h	/^	BP_UNEQUAL = 3$/;"	e	enum:BpOperat
+BP_WRITE	drivers/tilib_defs.h	/^	BP_WRITE = 7,$/;"	e	enum:BpAccess
+BP_WRITE_DMA	drivers/tilib_defs.h	/^	BP_WRITE_DMA = 15$/;"	e	enum:BpAccess
+BP_WRITE_NO_DMA	drivers/tilib_defs.h	/^	BP_WRITE_NO_DMA = 11,$/;"	e	enum:BpAccess
+BREAKPOINT	drivers/tilib_defs.h	/^typedef struct BREAKPOINT {$/;"	s
+BREAKPOINT_HIT	drivers/tilib_defs.h	/^        BREAKPOINT_HIT = 3,$/;"	e	enum:STATE_MODES
+BSL_H_	drivers/bsl.h	20;"	d
+BTREE_CLEAR	util/btree.h	/^	BTREE_CLEAR,    \/* clear the cursor *\/$/;"	e	enum:__anon60
+BTREE_EXACT	util/btree.h	/^	BTREE_EXACT,    \/* find the exact item *\/$/;"	e	enum:__anon60
+BTREE_FIRST	util/btree.h	/^	BTREE_FIRST,    \/* find the first item in the tree *\/$/;"	e	enum:__anon60
+BTREE_H_	util/btree.h	20;"	d
+BTREE_LE	util/btree.h	/^	BTREE_LE,       \/* find the largest item <= the key *\/$/;"	e	enum:__anon60
+BTREE_NEXT	util/btree.h	/^	BTREE_NEXT,     \/* find the next item after the cursor *\/$/;"	e	enum:__anon60
+BTREE_READ	util/btree.h	/^	BTREE_READ      \/* fetch the current record without moving *\/$/;"	e	enum:__anon60
+BUSY	drivers/jtdev.c	51;"	d	file:
+BYTE	drivers/tilib_defs.h	/^typedef uint8_t BYTE;$/;"	t
+BpAccess	drivers/tilib_defs.h	/^typedef enum BpAccess {$/;"	g
+BpAccess_t	drivers/tilib_defs.h	/^} BpAccess_t;$/;"	t	typeref:enum:BpAccess
+BpAction	drivers/tilib_defs.h	/^typedef enum BpAction {$/;"	g
+BpAction_t	drivers/tilib_defs.h	/^} BpAction_t;$/;"	t	typeref:enum:BpAction
+BpCondition	drivers/tilib_defs.h	/^typedef enum BpCondition {$/;"	g
+BpCondition_t	drivers/tilib_defs.h	/^} BpCondition_t;$/;"	t	typeref:enum:BpCondition
+BpMode	drivers/tilib_defs.h	/^typedef enum BpMode {$/;"	g
+BpMode_t	drivers/tilib_defs.h	/^} BpMode_t;$/;"	t	typeref:enum:BpMode
+BpOperat	drivers/tilib_defs.h	/^typedef enum BpOperat {$/;"	g
+BpOperat_t	drivers/tilib_defs.h	/^} BpOperat_t;$/;"	t	typeref:enum:BpOperat
+BpParameter_t	drivers/tilib_defs.h	/^} BpParameter_t;$/;"	t	typeref:struct:BREAKPOINT
+BpRangeAction	drivers/tilib_defs.h	/^typedef enum BpRangeAction {$/;"	g
+BpRangeAction_t	drivers/tilib_defs.h	/^} BpRangeAction_t;$/;"	t	typeref:enum:BpRangeAction
+BpType	drivers/tilib_defs.h	/^typedef enum BpType {$/;"	g
+BpType_t	drivers/tilib_defs.h	/^} BpType_t;$/;"	t	typeref:enum:BpType
+CAP	simio/simio_timer.c	46;"	d	file:
+CC	Makefile	/^CC ?= gcc$/;"	m
+CCI	simio/simio_timer.c	51;"	d	file:
+CCIE	simio/simio_timer.c	50;"	d	file:
+CCIFG	simio/simio_timer.c	54;"	d	file:
+CCIS0	simio/simio_timer.c	43;"	d	file:
+CCIS1	simio/simio_timer.c	42;"	d	file:
+CDC_ACM_H_	transport/cdc_acm.h	21;"	d
+CDC_CTRL_DTR	transport/cdc_acm.c	58;"	d	file:
+CDC_CTRL_RTS	transport/cdc_acm.c	59;"	d	file:
+CDC_INTERFACE_CLASS	transport/cdc_acm.c	48;"	d	file:
+CDC_REQTYPE_HOST_TO_DEVICE	transport/cdc_acm.c	53;"	d	file:
+CDC_SET_CONTROL	transport/cdc_acm.c	54;"	d	file:
+CDC_SET_LINE_CODING	transport/cdc_acm.c	55;"	d	file:
+CG_EDGE_FROM	ui/rtools.c	531;"	d	file:
+CG_EDGE_TO	ui/rtools.c	532;"	d	file:
+CG_NODE	ui/rtools.c	530;"	d	file:
+CHAR	drivers/tilib_defs.h	/^typedef char CHAR;$/;"	t
+CLK_CNTRL_MODE	drivers/tilib_defs.h	/^        CLK_CNTRL_MODE = 2,$/;"	e	enum:CONFIG_MODE
+CM0	simio/simio_timer.c	41;"	d	file:
+CM1	simio/simio_timer.c	40;"	d	file:
+CMDDB_H_	ui/cmddb.h	20;"	d
+CMD_ERASE	drivers/bsl.c	199;"	d	file:
+CMD_RESET	drivers/bsl.c	201;"	d	file:
+CMD_RX_DATA	drivers/bsl.c	200;"	d	file:
+CMD_TX_DATA	drivers/bsl.c	198;"	d	file:
+COFF_H_	formats/coff.h	20;"	d
+COMPORT_H_	transport/comport.h	20;"	d
+CONFIG_CFLAGS	Makefile	/^CONFIG_CFLAGS = -DLIB_DIR=\\"$(LIBDIR)\\"$/;"	m
+CONFIG_MODE	drivers/tilib_defs.h	/^enum CONFIG_MODE {$/;"	g
+COPY_OFFSET	drivers/obl.c	29;"	d	file:
+COPY_VALID_ADDR	drivers/obl.c	30;"	d	file:
+COV	simio/simio_timer.c	53;"	d	file:
+CP210X_CLOCK	transport/cp210x.c	49;"	d	file:
+CP210X_CTS	transport/cp210x.c	64;"	d	file:
+CP210X_DCD	transport/cp210x.c	67;"	d	file:
+CP210X_DSR	transport/cp210x.c	65;"	d	file:
+CP210X_DTR	transport/cp210x.c	62;"	d	file:
+CP210X_H_	transport/cp210x.h	21;"	d
+CP210X_IFC_ENABLE	transport/cp210x.c	57;"	d	file:
+CP210X_RING	transport/cp210x.c	66;"	d	file:
+CP210X_RTS	transport/cp210x.c	63;"	d	file:
+CP210X_SET_BAUDDIV	transport/cp210x.c	58;"	d	file:
+CP210X_SET_MHS	transport/cp210x.c	59;"	d	file:
+CP210X_WRITE_DTR	transport/cp210x.c	68;"	d	file:
+CP210X_WRITE_RTS	transport/cp210x.c	69;"	d	file:
+CP210x_REQTYPE_HOST_TO_DEVICE	transport/cp210x.c	55;"	d	file:
+CRC_CHECK	drivers/flash_bsl.c	95;"	d	file:
+CRC_INIT	drivers/flash_bsl.c	46;"	d	file:
+CTRLC_H_	util/ctrlc.h	20;"	d
+C_ARG	formats/coff.c	77;"	d	file:
+C_AUTO	formats/coff.c	69;"	d	file:
+C_BLOCK	formats/coff.c	91;"	d	file:
+C_BREAKPOINT	drivers/fet_core.c	78;"	d	file:
+C_CLOSE	drivers/fet_core.c	64;"	d	file:
+C_CMM_CTRL	drivers/fet_core.c	105;"	d	file:
+C_CMM_PARAM	drivers/fet_core.c	104;"	d	file:
+C_CMM_READ	drivers/fet_core.c	106;"	d	file:
+C_CONFIGURE	drivers/fet_core.c	67;"	d	file:
+C_DEVICE	drivers/fet_core.c	66;"	d	file:
+C_EEMCLOSE	drivers/fet_core.c	89;"	d	file:
+C_EEMOPEN	drivers/fet_core.c	85;"	d	file:
+C_EEMREADREGISTER	drivers/fet_core.c	86;"	d	file:
+C_EEMREADREGISTERTEST	drivers/fet_core.c	87;"	d	file:
+C_EEMWRITEREGISTER	drivers/fet_core.c	88;"	d	file:
+C_ENTAG	formats/coff.c	83;"	d	file:
+C_ENTERBOOTLOADER	drivers/fet_core.c	98;"	d	file:
+C_EOS	formats/coff.c	93;"	d	file:
+C_ERASE	drivers/fet_core.c	74;"	d	file:
+C_ERASECHECK	drivers/fet_core.c	84;"	d	file:
+C_ERRORNUMBER	drivers/fet_core.c	90;"	d	file:
+C_EXT	formats/coff.c	70;"	d	file:
+C_EXTLAB	formats/coff.c	89;"	d	file:
+C_EXTREF	formats/coff.c	73;"	d	file:
+C_FASTFLASHER	drivers/fet_core.c	77;"	d	file:
+C_FASTVERIFYMEMORY	drivers/fet_core.c	83;"	d	file:
+C_FCN	formats/coff.c	92;"	d	file:
+C_FETRESET	drivers/fet_core.c	95;"	d	file:
+C_FETSELFTEST	drivers/fet_core.c	93;"	d	file:
+C_FETSETSIGNALS	drivers/fet_core.c	94;"	d	file:
+C_FIELD	formats/coff.c	86;"	d	file:
+C_FILE	formats/coff.c	94;"	d	file:
+C_GETCURVCCT	drivers/fet_core.c	91;"	d	file:
+C_GETEXTVOLTAGE	drivers/fet_core.c	92;"	d	file:
+C_IDENT1	drivers/fet_core.c	100;"	d	file:
+C_IDENT2	drivers/fet_core.c	101;"	d	file:
+C_IDENT3	drivers/fet_core.c	102;"	d	file:
+C_IDENTIFY	drivers/fet_core.c	65;"	d	file:
+C_INITIALIZE	drivers/fet_core.c	63;"	d	file:
+C_LABEL	formats/coff.c	74;"	d	file:
+C_LINE	formats/coff.c	95;"	d	file:
+C_MOE	formats/coff.c	84;"	d	file:
+C_MOS	formats/coff.c	76;"	d	file:
+C_MOU	formats/coff.c	79;"	d	file:
+C_NULL	formats/coff.c	68;"	d	file:
+C_READI2C	drivers/fet_core.c	96;"	d	file:
+C_READMEMORY	drivers/fet_core.c	75;"	d	file:
+C_READREGISTER	drivers/fet_core.c	72;"	d	file:
+C_READREGISTERS	drivers/fet_core.c	70;"	d	file:
+C_REG	formats/coff.c	72;"	d	file:
+C_REGPARM	formats/coff.c	85;"	d	file:
+C_RESET	drivers/fet_core.c	69;"	d	file:
+C_RUN	drivers/fet_core.c	79;"	d	file:
+C_SECURE	drivers/fet_core.c	81;"	d	file:
+C_STAT	formats/coff.c	71;"	d	file:
+C_STATE	drivers/fet_core.c	80;"	d	file:
+C_STATLAB	formats/coff.c	88;"	d	file:
+C_STRTAG	formats/coff.c	78;"	d	file:
+C_TPDEF	formats/coff.c	81;"	d	file:
+C_UEXT	formats/coff.c	87;"	d	file:
+C_ULABEL	formats/coff.c	75;"	d	file:
+C_UNTAG	formats/coff.c	80;"	d	file:
+C_USTATIC	formats/coff.c	82;"	d	file:
+C_VARARG	formats/coff.c	90;"	d	file:
+C_VCC	drivers/fet_core.c	68;"	d	file:
+C_VERIFYMEMORY	drivers/fet_core.c	82;"	d	file:
+C_WRITEI2C	drivers/fet_core.c	97;"	d	file:
+C_WRITEMEMORY	drivers/fet_core.c	76;"	d	file:
+C_WRITEREGISTER	drivers/fet_core.c	73;"	d	file:
+C_WRITEREGISTERS	drivers/fet_core.c	71;"	d	file:
+DATA0	drivers/jtdev.c	37;"	d	file:
+DATA1	drivers/jtdev.c	38;"	d	file:
+DATA2	drivers/jtdev.c	39;"	d	file:
+DATA3	drivers/jtdev.c	40;"	d	file:
+DATA4	drivers/jtdev.c	41;"	d	file:
+DATA5	drivers/jtdev.c	42;"	d	file:
+DATA6	drivers/jtdev.c	43;"	d	file:
+DATA7	drivers/jtdev.c	44;"	d	file:
+DATA_ACK	drivers/bsl.c	44;"	d	file:
+DATA_HDR	drivers/bsl.c	43;"	d	file:
+DATA_NAK	drivers/bsl.c	45;"	d	file:
+DEBUG_LPM_X	drivers/tilib_defs.h	/^	DEBUG_LPM_X = 14$/;"	e	enum:CONFIG_MODE
+DEFAULT_HISTORY	simio/simio_tracer.c	29;"	d	file:
+DEMANGLE_H_	util/demangle.h	20;"	d
+DEVCMD_H_	ui/devcmd.h	20;"	d
+DEVICELIST_H_	drivers/devicelist.h	21;"	d
+DEVICE_BPTYPE_BREAK	drivers/device.h	/^	DEVICE_BPTYPE_BREAK,$/;"	e	enum:__anon49
+DEVICE_BPTYPE_READ	drivers/device.h	/^	DEVICE_BPTYPE_READ,$/;"	e	enum:__anon49
+DEVICE_BPTYPE_WATCH	drivers/device.h	/^	DEVICE_BPTYPE_WATCH,$/;"	e	enum:__anon49
+DEVICE_BPTYPE_WRITE	drivers/device.h	/^	DEVICE_BPTYPE_WRITE$/;"	e	enum:__anon49
+DEVICE_BP_DIRTY	drivers/device.h	53;"	d
+DEVICE_BP_ENABLED	drivers/device.h	52;"	d
+DEVICE_CODE	drivers/tilib_defs.h	/^	DEVICE_CODE = 12,$/;"	e	enum:CONFIG_MODE
+DEVICE_CTL_HALT	drivers/device.h	/^	DEVICE_CTL_HALT,$/;"	e	enum:__anon46
+DEVICE_CTL_RESET	drivers/device.h	/^	DEVICE_CTL_RESET,$/;"	e	enum:__anon46
+DEVICE_CTL_RUN	drivers/device.h	/^	DEVICE_CTL_RUN,$/;"	e	enum:__anon46
+DEVICE_CTL_STEP	drivers/device.h	/^	DEVICE_CTL_STEP$/;"	e	enum:__anon46
+DEVICE_ERASE_ALL	drivers/device.h	/^	DEVICE_ERASE_ALL,$/;"	e	enum:__anon48
+DEVICE_ERASE_MAIN	drivers/device.h	/^	DEVICE_ERASE_MAIN,$/;"	e	enum:__anon48
+DEVICE_ERASE_SEGMENT	drivers/device.h	/^	DEVICE_ERASE_SEGMENT$/;"	e	enum:__anon48
+DEVICE_FLAG_DO_FWUPDATE	drivers/device.h	72;"	d
+DEVICE_FLAG_FORCE_RESET	drivers/device.h	71;"	d
+DEVICE_FLAG_JTAG	drivers/device.h	68;"	d
+DEVICE_FLAG_LONG_PW	drivers/device.h	69;"	d
+DEVICE_FLAG_SKIP_CLOSE	drivers/device.h	73;"	d
+DEVICE_FLAG_TTY	drivers/device.h	70;"	d
+DEVICE_H_	drivers/device.h	20;"	d
+DEVICE_MAX_BREAKPOINTS	drivers/device.h	50;"	d
+DEVICE_NUM_REGS	drivers/device.h	49;"	d
+DEVICE_STATUS_ERROR	drivers/device.h	/^	DEVICE_STATUS_ERROR$/;"	e	enum:__anon47
+DEVICE_STATUS_HALTED	drivers/device.h	/^	DEVICE_STATUS_HALTED,$/;"	e	enum:__anon47
+DEVICE_STATUS_INTR	drivers/device.h	/^	DEVICE_STATUS_INTR,$/;"	e	enum:__anon47
+DEVICE_STATUS_RUNNING	drivers/device.h	/^	DEVICE_STATUS_RUNNING,$/;"	e	enum:__anon47
+DEVICE_T	drivers/tilib_defs.h	/^union DEVICE_T {$/;"	u
+DF_1_CONFALT	formats/elf_format.h	771;"	d
+DF_1_DIRECT	formats/elf_format.h	766;"	d
+DF_1_DISPRELDNE	formats/elf_format.h	773;"	d
+DF_1_DISPRELPND	formats/elf_format.h	774;"	d
+DF_1_ENDFILTEE	formats/elf_format.h	772;"	d
+DF_1_GLOBAL	formats/elf_format.h	759;"	d
+DF_1_GROUP	formats/elf_format.h	760;"	d
+DF_1_INITFIRST	formats/elf_format.h	763;"	d
+DF_1_INTERPOSE	formats/elf_format.h	768;"	d
+DF_1_LOADFLTR	formats/elf_format.h	762;"	d
+DF_1_NODEFLIB	formats/elf_format.h	769;"	d
+DF_1_NODELETE	formats/elf_format.h	761;"	d
+DF_1_NODUMP	formats/elf_format.h	770;"	d
+DF_1_NOOPEN	formats/elf_format.h	764;"	d
+DF_1_NOW	formats/elf_format.h	758;"	d
+DF_1_ORIGIN	formats/elf_format.h	765;"	d
+DF_1_TRANS	formats/elf_format.h	767;"	d
+DF_BIND_NOW	formats/elf_format.h	753;"	d
+DF_ORIGIN	formats/elf_format.h	750;"	d
+DF_P1_GROUPPERM	formats/elf_format.h	782;"	d
+DF_P1_LAZYLOAD	formats/elf_format.h	781;"	d
+DF_STATIC_TLS	formats/elf_format.h	754;"	d
+DF_SYMBOLIC	formats/elf_format.h	751;"	d
+DF_TEXTREL	formats/elf_format.h	752;"	d
+DLL430_EVENTNOTIFY_FUNC	drivers/tilib_defs.h	/^typedef void (*DLL430_EVENTNOTIFY_FUNC)$/;"	t
+DLL430_FET_NOTIFY_FUNC	drivers/tilib_defs.h	/^typedef void (*DLL430_FET_NOTIFY_FUNC) (unsigned int MsgId,$/;"	t
+DTF_1_CONFEXP	formats/elf_format.h	778;"	d
+DTF_1_PARINIT	formats/elf_format.h	777;"	d
+DT_ADDRNUM	formats/elf_format.h	722;"	d
+DT_ADDRRNGHI	formats/elf_format.h	720;"	d
+DT_ADDRRNGLO	formats/elf_format.h	708;"	d
+DT_ADDRTAGIDX	formats/elf_format.h	721;"	d
+DT_ALPHA_NUM	formats/elf_format.h	1980;"	d
+DT_ALPHA_PLTRO	formats/elf_format.h	1979;"	d
+DT_AUDIT	formats/elf_format.h	716;"	d
+DT_AUXILIARY	formats/elf_format.h	744;"	d
+DT_BIND_NOW	formats/elf_format.h	666;"	d
+DT_CC430F5123	drivers/devicelist.h	/^	DT_CC430F5123,$/;"	e	enum:__anon44
+DT_CC430F5125	drivers/devicelist.h	/^	DT_CC430F5125,$/;"	e	enum:__anon44
+DT_CC430F5133	drivers/devicelist.h	/^	DT_CC430F5133,$/;"	e	enum:__anon44
+DT_CC430F5135	drivers/devicelist.h	/^	DT_CC430F5135,$/;"	e	enum:__anon44
+DT_CC430F5137	drivers/devicelist.h	/^	DT_CC430F5137,$/;"	e	enum:__anon44
+DT_CC430F5143	drivers/devicelist.h	/^	DT_CC430F5143,$/;"	e	enum:__anon44
+DT_CC430F5145	drivers/devicelist.h	/^	DT_CC430F5145,$/;"	e	enum:__anon44
+DT_CC430F5147	drivers/devicelist.h	/^	DT_CC430F5147,$/;"	e	enum:__anon44
+DT_CC430F6125	drivers/devicelist.h	/^	DT_CC430F6125,$/;"	e	enum:__anon44
+DT_CC430F6126	drivers/devicelist.h	/^	DT_CC430F6126,$/;"	e	enum:__anon44
+DT_CC430F6127	drivers/devicelist.h	/^	DT_CC430F6127,$/;"	e	enum:__anon44
+DT_CC430F6135	drivers/devicelist.h	/^	DT_CC430F6135,$/;"	e	enum:__anon44
+DT_CC430F6137	drivers/devicelist.h	/^	DT_CC430F6137,$/;"	e	enum:__anon44
+DT_CC430F6143	drivers/devicelist.h	/^	DT_CC430F6143,$/;"	e	enum:__anon44
+DT_CC430F6145	drivers/devicelist.h	/^	DT_CC430F6145,$/;"	e	enum:__anon44
+DT_CC430F6147	drivers/devicelist.h	/^	DT_CC430F6147,$/;"	e	enum:__anon44
+DT_CHECKSUM	formats/elf_format.h	690;"	d
+DT_CONFIG	formats/elf_format.h	714;"	d
+DT_DEBUG	formats/elf_format.h	663;"	d
+DT_DEPAUDIT	formats/elf_format.h	715;"	d
+DT_ENCODING	formats/elf_format.h	673;"	d
+DT_END	drivers/devicelist.h	/^	DT_END$/;"	e	enum:__anon44
+DT_EXTRANUM	formats/elf_format.h	747;"	d
+DT_EXTRATAGIDX	formats/elf_format.h	746;"	d
+DT_FEATURE_1	formats/elf_format.h	694;"	d
+DT_FILTER	formats/elf_format.h	745;"	d
+DT_FINI	formats/elf_format.h	655;"	d
+DT_FINI_ARRAY	formats/elf_format.h	668;"	d
+DT_FINI_ARRAYSZ	formats/elf_format.h	670;"	d
+DT_FLAGS	formats/elf_format.h	672;"	d
+DT_FLAGS_1	formats/elf_format.h	732;"	d
+DT_GNU_CONFLICT	formats/elf_format.h	712;"	d
+DT_GNU_CONFLICTSZ	formats/elf_format.h	688;"	d
+DT_GNU_HASH	formats/elf_format.h	709;"	d
+DT_GNU_LIBLIST	formats/elf_format.h	713;"	d
+DT_GNU_LIBLISTSZ	formats/elf_format.h	689;"	d
+DT_GNU_PRELINKED	formats/elf_format.h	687;"	d
+DT_HASH	formats/elf_format.h	646;"	d
+DT_HIOS	formats/elf_format.h	678;"	d
+DT_HIPROC	formats/elf_format.h	680;"	d
+DT_IA_64_NUM	formats/elf_format.h	2379;"	d
+DT_IA_64_PLT_RESERVE	formats/elf_format.h	2378;"	d
+DT_INIT	formats/elf_format.h	654;"	d
+DT_INIT_ARRAY	formats/elf_format.h	667;"	d
+DT_INIT_ARRAYSZ	formats/elf_format.h	669;"	d
+DT_JMPREL	formats/elf_format.h	665;"	d
+DT_LOOS	formats/elf_format.h	677;"	d
+DT_LOPROC	formats/elf_format.h	679;"	d
+DT_MIPS_AUX_DYNAMIC	formats/elf_format.h	1656;"	d
+DT_MIPS_BASE_ADDRESS	formats/elf_format.h	1610;"	d
+DT_MIPS_COMPACT_SIZE	formats/elf_format.h	1654;"	d
+DT_MIPS_CONFLICT	formats/elf_format.h	1612;"	d
+DT_MIPS_CONFLICTNO	formats/elf_format.h	1615;"	d
+DT_MIPS_CXX_FLAGS	formats/elf_format.h	1639;"	d
+DT_MIPS_DELTA_CLASS	formats/elf_format.h	1622;"	d
+DT_MIPS_DELTA_CLASSSYM	formats/elf_format.h	1635;"	d
+DT_MIPS_DELTA_CLASSSYM_NO	formats/elf_format.h	1637;"	d
+DT_MIPS_DELTA_CLASS_NO	formats/elf_format.h	1623;"	d
+DT_MIPS_DELTA_INSTANCE	formats/elf_format.h	1625;"	d
+DT_MIPS_DELTA_INSTANCE_NO	formats/elf_format.h	1626;"	d
+DT_MIPS_DELTA_RELOC	formats/elf_format.h	1628;"	d
+DT_MIPS_DELTA_RELOC_NO	formats/elf_format.h	1629;"	d
+DT_MIPS_DELTA_SYM	formats/elf_format.h	1631;"	d
+DT_MIPS_DELTA_SYM_NO	formats/elf_format.h	1633;"	d
+DT_MIPS_DYNSTR_ALIGN	formats/elf_format.h	1648;"	d
+DT_MIPS_FLAGS	formats/elf_format.h	1609;"	d
+DT_MIPS_GOTSYM	formats/elf_format.h	1619;"	d
+DT_MIPS_GP_VALUE	formats/elf_format.h	1655;"	d
+DT_MIPS_HIDDEN_GOTIDX	formats/elf_format.h	1644;"	d
+DT_MIPS_HIPAGENO	formats/elf_format.h	1620;"	d
+DT_MIPS_ICHECKSUM	formats/elf_format.h	1607;"	d
+DT_MIPS_INTERFACE	formats/elf_format.h	1647;"	d
+DT_MIPS_INTERFACE_SIZE	formats/elf_format.h	1649;"	d
+DT_MIPS_IVERSION	formats/elf_format.h	1608;"	d
+DT_MIPS_LIBLIST	formats/elf_format.h	1613;"	d
+DT_MIPS_LIBLISTNO	formats/elf_format.h	1616;"	d
+DT_MIPS_LOCALPAGE_GOTIDX	formats/elf_format.h	1642;"	d
+DT_MIPS_LOCAL_GOTIDX	formats/elf_format.h	1643;"	d
+DT_MIPS_LOCAL_GOTNO	formats/elf_format.h	1614;"	d
+DT_MIPS_MSYM	formats/elf_format.h	1611;"	d
+DT_MIPS_NUM	formats/elf_format.h	1663;"	d
+DT_MIPS_OPTIONS	formats/elf_format.h	1646;"	d
+DT_MIPS_PERF_SUFFIX	formats/elf_format.h	1652;"	d
+DT_MIPS_PIXIE_INIT	formats/elf_format.h	1640;"	d
+DT_MIPS_PLTGOT	formats/elf_format.h	1658;"	d
+DT_MIPS_PROTECTED_GOTIDX	formats/elf_format.h	1645;"	d
+DT_MIPS_RLD_MAP	formats/elf_format.h	1621;"	d
+DT_MIPS_RLD_TEXT_RESOLVE_ADDR	formats/elf_format.h	1650;"	d
+DT_MIPS_RLD_VERSION	formats/elf_format.h	1605;"	d
+DT_MIPS_RWPLT	formats/elf_format.h	1662;"	d
+DT_MIPS_SYMBOL_LIB	formats/elf_format.h	1641;"	d
+DT_MIPS_SYMTABNO	formats/elf_format.h	1617;"	d
+DT_MIPS_TIME_STAMP	formats/elf_format.h	1606;"	d
+DT_MIPS_UNREFEXTNO	formats/elf_format.h	1618;"	d
+DT_MOVEENT	formats/elf_format.h	692;"	d
+DT_MOVESZ	formats/elf_format.h	693;"	d
+DT_MOVETAB	formats/elf_format.h	718;"	d
+DT_MSP430AFE220	drivers/devicelist.h	/^	DT_MSP430AFE220,$/;"	e	enum:__anon44
+DT_MSP430AFE221	drivers/devicelist.h	/^	DT_MSP430AFE221,$/;"	e	enum:__anon44
+DT_MSP430AFE222	drivers/devicelist.h	/^	DT_MSP430AFE222,$/;"	e	enum:__anon44
+DT_MSP430AFE223	drivers/devicelist.h	/^	DT_MSP430AFE223,$/;"	e	enum:__anon44
+DT_MSP430AFE230	drivers/devicelist.h	/^	DT_MSP430AFE230,$/;"	e	enum:__anon44
+DT_MSP430AFE231	drivers/devicelist.h	/^	DT_MSP430AFE231,$/;"	e	enum:__anon44
+DT_MSP430AFE232	drivers/devicelist.h	/^	DT_MSP430AFE232,$/;"	e	enum:__anon44
+DT_MSP430AFE233	drivers/devicelist.h	/^	DT_MSP430AFE233,$/;"	e	enum:__anon44
+DT_MSP430AFE250	drivers/devicelist.h	/^	DT_MSP430AFE250,$/;"	e	enum:__anon44
+DT_MSP430AFE251	drivers/devicelist.h	/^	DT_MSP430AFE251,$/;"	e	enum:__anon44
+DT_MSP430AFE252	drivers/devicelist.h	/^	DT_MSP430AFE252,$/;"	e	enum:__anon44
+DT_MSP430AFE253	drivers/devicelist.h	/^	DT_MSP430AFE253,$/;"	e	enum:__anon44
+DT_MSP430F11x1	drivers/devicelist.h	/^	DT_MSP430F11x1,$/;"	e	enum:__anon44
+DT_MSP430F11x1A	drivers/devicelist.h	/^	DT_MSP430F11x1A,$/;"	e	enum:__anon44
+DT_MSP430F11x1D	drivers/devicelist.h	/^	DT_MSP430F11x1D,$/;"	e	enum:__anon44
+DT_MSP430F11x2	drivers/devicelist.h	/^	DT_MSP430F11x2,$/;"	e	enum:__anon44
+DT_MSP430F12x	drivers/devicelist.h	/^	DT_MSP430F12x,$/;"	e	enum:__anon44
+DT_MSP430F12x2	drivers/devicelist.h	/^	DT_MSP430F12x2,$/;"	e	enum:__anon44
+DT_MSP430F12x2C	drivers/devicelist.h	/^	DT_MSP430F12x2C,$/;"	e	enum:__anon44
+DT_MSP430F12x2New	drivers/devicelist.h	/^	DT_MSP430F12x2New,$/;"	e	enum:__anon44
+DT_MSP430F133	drivers/devicelist.h	/^	DT_MSP430F133,$/;"	e	enum:__anon44
+DT_MSP430F135	drivers/devicelist.h	/^	DT_MSP430F135,$/;"	e	enum:__anon44
+DT_MSP430F147	drivers/devicelist.h	/^	DT_MSP430F147,$/;"	e	enum:__anon44
+DT_MSP430F148	drivers/devicelist.h	/^	DT_MSP430F148,$/;"	e	enum:__anon44
+DT_MSP430F149	drivers/devicelist.h	/^	DT_MSP430F149,$/;"	e	enum:__anon44
+DT_MSP430F155	drivers/devicelist.h	/^	DT_MSP430F155,$/;"	e	enum:__anon44
+DT_MSP430F156	drivers/devicelist.h	/^	DT_MSP430F156,$/;"	e	enum:__anon44
+DT_MSP430F157	drivers/devicelist.h	/^	DT_MSP430F157,$/;"	e	enum:__anon44
+DT_MSP430F1610	drivers/devicelist.h	/^	DT_MSP430F1610,$/;"	e	enum:__anon44
+DT_MSP430F1611	drivers/devicelist.h	/^	DT_MSP430F1611,$/;"	e	enum:__anon44
+DT_MSP430F1612	drivers/devicelist.h	/^	DT_MSP430F1612,$/;"	e	enum:__anon44
+DT_MSP430F167	drivers/devicelist.h	/^	DT_MSP430F167,$/;"	e	enum:__anon44
+DT_MSP430F168	drivers/devicelist.h	/^	DT_MSP430F168,$/;"	e	enum:__anon44
+DT_MSP430F169	drivers/devicelist.h	/^	DT_MSP430F169,$/;"	e	enum:__anon44
+DT_MSP430F20x1	drivers/devicelist.h	/^	DT_MSP430F20x1,$/;"	e	enum:__anon44
+DT_MSP430F20x2	drivers/devicelist.h	/^	DT_MSP430F20x2,$/;"	e	enum:__anon44
+DT_MSP430F20x3	drivers/devicelist.h	/^	DT_MSP430F20x3,$/;"	e	enum:__anon44
+DT_MSP430F2112	drivers/devicelist.h	/^	DT_MSP430F2112,$/;"	e	enum:__anon44
+DT_MSP430F2122	drivers/devicelist.h	/^	DT_MSP430F2122,$/;"	e	enum:__anon44
+DT_MSP430F2132	drivers/devicelist.h	/^	DT_MSP430F2132,$/;"	e	enum:__anon44
+DT_MSP430F21x1	drivers/devicelist.h	/^	DT_MSP430F21x1,$/;"	e	enum:__anon44
+DT_MSP430F2232	drivers/devicelist.h	/^	DT_MSP430F2232,$/;"	e	enum:__anon44
+DT_MSP430F2234	drivers/devicelist.h	/^	DT_MSP430F2234,$/;"	e	enum:__anon44
+DT_MSP430F2252	drivers/devicelist.h	/^	DT_MSP430F2252,$/;"	e	enum:__anon44
+DT_MSP430F2254	drivers/devicelist.h	/^	DT_MSP430F2254,$/;"	e	enum:__anon44
+DT_MSP430F2272	drivers/devicelist.h	/^	DT_MSP430F2272,$/;"	e	enum:__anon44
+DT_MSP430F2274	drivers/devicelist.h	/^	DT_MSP430F2274,$/;"	e	enum:__anon44
+DT_MSP430F233	drivers/devicelist.h	/^	DT_MSP430F233,$/;"	e	enum:__anon44
+DT_MSP430F2330	drivers/devicelist.h	/^	DT_MSP430F2330,$/;"	e	enum:__anon44
+DT_MSP430F235	drivers/devicelist.h	/^	DT_MSP430F235,$/;"	e	enum:__anon44
+DT_MSP430F2350	drivers/devicelist.h	/^	DT_MSP430F2350,$/;"	e	enum:__anon44
+DT_MSP430F2370	drivers/devicelist.h	/^	DT_MSP430F2370,$/;"	e	enum:__anon44
+DT_MSP430F2410	drivers/devicelist.h	/^	DT_MSP430F2410,$/;"	e	enum:__anon44
+DT_MSP430F2418	drivers/devicelist.h	/^	DT_MSP430F2418,$/;"	e	enum:__anon44
+DT_MSP430F2419	drivers/devicelist.h	/^	DT_MSP430F2419,$/;"	e	enum:__anon44
+DT_MSP430F247	drivers/devicelist.h	/^	DT_MSP430F247,$/;"	e	enum:__anon44
+DT_MSP430F2471	drivers/devicelist.h	/^	DT_MSP430F2471,$/;"	e	enum:__anon44
+DT_MSP430F248	drivers/devicelist.h	/^	DT_MSP430F248,$/;"	e	enum:__anon44
+DT_MSP430F2481	drivers/devicelist.h	/^	DT_MSP430F2481,$/;"	e	enum:__anon44
+DT_MSP430F249	drivers/devicelist.h	/^	DT_MSP430F249,$/;"	e	enum:__anon44
+DT_MSP430F2491	drivers/devicelist.h	/^	DT_MSP430F2491,$/;"	e	enum:__anon44
+DT_MSP430F2618	drivers/devicelist.h	/^	DT_MSP430F2618,$/;"	e	enum:__anon44
+DT_MSP430F2619	drivers/devicelist.h	/^	DT_MSP430F2619,$/;"	e	enum:__anon44
+DT_MSP430F4132	drivers/devicelist.h	/^	DT_MSP430F4132,$/;"	e	enum:__anon44
+DT_MSP430F413P	drivers/devicelist.h	/^	DT_MSP430F413P,$/;"	e	enum:__anon44
+DT_MSP430F4152	drivers/devicelist.h	/^	DT_MSP430F4152,$/;"	e	enum:__anon44
+DT_MSP430F41xC	drivers/devicelist.h	/^	DT_MSP430F41xC,$/;"	e	enum:__anon44
+DT_MSP430F423	drivers/devicelist.h	/^	DT_MSP430F423,$/;"	e	enum:__anon44
+DT_MSP430F4230	drivers/devicelist.h	/^	DT_MSP430F4230,$/;"	e	enum:__anon44
+DT_MSP430F423A	drivers/devicelist.h	/^	DT_MSP430F423A,$/;"	e	enum:__anon44
+DT_MSP430F425	drivers/devicelist.h	/^	DT_MSP430F425,$/;"	e	enum:__anon44
+DT_MSP430F4250	drivers/devicelist.h	/^	DT_MSP430F4250,$/;"	e	enum:__anon44
+DT_MSP430F425A	drivers/devicelist.h	/^	DT_MSP430F425A,$/;"	e	enum:__anon44
+DT_MSP430F427	drivers/devicelist.h	/^	DT_MSP430F427,$/;"	e	enum:__anon44
+DT_MSP430F427A	drivers/devicelist.h	/^	DT_MSP430F427A,$/;"	e	enum:__anon44
+DT_MSP430F42x0	drivers/devicelist.h	/^	DT_MSP430F42x0,$/;"	e	enum:__anon44
+DT_MSP430F43x	drivers/devicelist.h	/^	DT_MSP430F43x,$/;"	e	enum:__anon44
+DT_MSP430F44x	drivers/devicelist.h	/^	DT_MSP430F44x,$/;"	e	enum:__anon44
+DT_MSP430F47166	drivers/devicelist.h	/^	DT_MSP430F47166,$/;"	e	enum:__anon44
+DT_MSP430F47167	drivers/devicelist.h	/^	DT_MSP430F47167,$/;"	e	enum:__anon44
+DT_MSP430F47176	drivers/devicelist.h	/^	DT_MSP430F47176,$/;"	e	enum:__anon44
+DT_MSP430F47177	drivers/devicelist.h	/^	DT_MSP430F47177,$/;"	e	enum:__anon44
+DT_MSP430F47186	drivers/devicelist.h	/^	DT_MSP430F47186,$/;"	e	enum:__anon44
+DT_MSP430F47187	drivers/devicelist.h	/^	DT_MSP430F47187,$/;"	e	enum:__anon44
+DT_MSP430F47196	drivers/devicelist.h	/^	DT_MSP430F47196,$/;"	e	enum:__anon44
+DT_MSP430F47197	drivers/devicelist.h	/^	DT_MSP430F47197,$/;"	e	enum:__anon44
+DT_MSP430F477	drivers/devicelist.h	/^	DT_MSP430F477,$/;"	e	enum:__anon44
+DT_MSP430F478	drivers/devicelist.h	/^	DT_MSP430F478,$/;"	e	enum:__anon44
+DT_MSP430F4783	drivers/devicelist.h	/^	DT_MSP430F4783,$/;"	e	enum:__anon44
+DT_MSP430F4784	drivers/devicelist.h	/^	DT_MSP430F4784,$/;"	e	enum:__anon44
+DT_MSP430F479	drivers/devicelist.h	/^	DT_MSP430F479,$/;"	e	enum:__anon44
+DT_MSP430F4793	drivers/devicelist.h	/^	DT_MSP430F4793,$/;"	e	enum:__anon44
+DT_MSP430F4794	drivers/devicelist.h	/^	DT_MSP430F4794,$/;"	e	enum:__anon44
+DT_MSP430F5131	drivers/devicelist.h	/^	DT_MSP430F5131,$/;"	e	enum:__anon44
+DT_MSP430F5132	drivers/devicelist.h	/^	DT_MSP430F5132,$/;"	e	enum:__anon44
+DT_MSP430F5151	drivers/devicelist.h	/^	DT_MSP430F5151,$/;"	e	enum:__anon44
+DT_MSP430F5152	drivers/devicelist.h	/^	DT_MSP430F5152,$/;"	e	enum:__anon44
+DT_MSP430F5171	drivers/devicelist.h	/^	DT_MSP430F5171,$/;"	e	enum:__anon44
+DT_MSP430F5172	drivers/devicelist.h	/^	DT_MSP430F5172,$/;"	e	enum:__anon44
+DT_MSP430F5212	drivers/devicelist.h	/^	DT_MSP430F5212,$/;"	e	enum:__anon44
+DT_MSP430F5213	drivers/devicelist.h	/^	DT_MSP430F5213,$/;"	e	enum:__anon44
+DT_MSP430F5214	drivers/devicelist.h	/^	DT_MSP430F5214,$/;"	e	enum:__anon44
+DT_MSP430F5217	drivers/devicelist.h	/^	DT_MSP430F5217,$/;"	e	enum:__anon44
+DT_MSP430F5218	drivers/devicelist.h	/^	DT_MSP430F5218,$/;"	e	enum:__anon44
+DT_MSP430F5219	drivers/devicelist.h	/^	DT_MSP430F5219,$/;"	e	enum:__anon44
+DT_MSP430F5222	drivers/devicelist.h	/^	DT_MSP430F5222,$/;"	e	enum:__anon44
+DT_MSP430F5223	drivers/devicelist.h	/^	DT_MSP430F5223,$/;"	e	enum:__anon44
+DT_MSP430F5224	drivers/devicelist.h	/^	DT_MSP430F5224,$/;"	e	enum:__anon44
+DT_MSP430F5227	drivers/devicelist.h	/^	DT_MSP430F5227,$/;"	e	enum:__anon44
+DT_MSP430F5228	drivers/devicelist.h	/^	DT_MSP430F5228,$/;"	e	enum:__anon44
+DT_MSP430F5229	drivers/devicelist.h	/^	DT_MSP430F5229,$/;"	e	enum:__anon44
+DT_MSP430F5304	drivers/devicelist.h	/^	DT_MSP430F5304,$/;"	e	enum:__anon44
+DT_MSP430F5308	drivers/devicelist.h	/^	DT_MSP430F5308,$/;"	e	enum:__anon44
+DT_MSP430F5309	drivers/devicelist.h	/^	DT_MSP430F5309,$/;"	e	enum:__anon44
+DT_MSP430F5310	drivers/devicelist.h	/^	DT_MSP430F5310,$/;"	e	enum:__anon44
+DT_MSP430F5324	drivers/devicelist.h	/^	DT_MSP430F5324,$/;"	e	enum:__anon44
+DT_MSP430F5325	drivers/devicelist.h	/^	DT_MSP430F5325,$/;"	e	enum:__anon44
+DT_MSP430F5326	drivers/devicelist.h	/^	DT_MSP430F5326,$/;"	e	enum:__anon44
+DT_MSP430F5327	drivers/devicelist.h	/^	DT_MSP430F5327,$/;"	e	enum:__anon44
+DT_MSP430F5328	drivers/devicelist.h	/^	DT_MSP430F5328,$/;"	e	enum:__anon44
+DT_MSP430F5329	drivers/devicelist.h	/^	DT_MSP430F5329,$/;"	e	enum:__anon44
+DT_MSP430F5333	drivers/devicelist.h	/^	DT_MSP430F5333,$/;"	e	enum:__anon44
+DT_MSP430F5335	drivers/devicelist.h	/^	DT_MSP430F5335,$/;"	e	enum:__anon44
+DT_MSP430F5336	drivers/devicelist.h	/^	DT_MSP430F5336,$/;"	e	enum:__anon44
+DT_MSP430F5338	drivers/devicelist.h	/^	DT_MSP430F5338,$/;"	e	enum:__anon44
+DT_MSP430F5340	drivers/devicelist.h	/^	DT_MSP430F5340,$/;"	e	enum:__anon44
+DT_MSP430F5341	drivers/devicelist.h	/^	DT_MSP430F5341,$/;"	e	enum:__anon44
+DT_MSP430F5342	drivers/devicelist.h	/^	DT_MSP430F5342,$/;"	e	enum:__anon44
+DT_MSP430F5357	drivers/devicelist.h	/^	DT_MSP430F5357,$/;"	e	enum:__anon44
+DT_MSP430F5358	drivers/devicelist.h	/^	DT_MSP430F5358,$/;"	e	enum:__anon44
+DT_MSP430F5359	drivers/devicelist.h	/^	DT_MSP430F5359,$/;"	e	enum:__anon44
+DT_MSP430F5418	drivers/devicelist.h	/^	DT_MSP430F5418,$/;"	e	enum:__anon44
+DT_MSP430F5418A	drivers/devicelist.h	/^	DT_MSP430F5418A,$/;"	e	enum:__anon44
+DT_MSP430F5419	drivers/devicelist.h	/^	DT_MSP430F5419,$/;"	e	enum:__anon44
+DT_MSP430F5419A	drivers/devicelist.h	/^	DT_MSP430F5419A,$/;"	e	enum:__anon44
+DT_MSP430F5435	drivers/devicelist.h	/^	DT_MSP430F5435,$/;"	e	enum:__anon44
+DT_MSP430F5435A	drivers/devicelist.h	/^	DT_MSP430F5435A,$/;"	e	enum:__anon44
+DT_MSP430F5436	drivers/devicelist.h	/^	DT_MSP430F5436,$/;"	e	enum:__anon44
+DT_MSP430F5436A	drivers/devicelist.h	/^	DT_MSP430F5436A,$/;"	e	enum:__anon44
+DT_MSP430F5437	drivers/devicelist.h	/^	DT_MSP430F5437,$/;"	e	enum:__anon44
+DT_MSP430F5437A	drivers/devicelist.h	/^	DT_MSP430F5437A,$/;"	e	enum:__anon44
+DT_MSP430F5438	drivers/devicelist.h	/^	DT_MSP430F5438,$/;"	e	enum:__anon44
+DT_MSP430F5438A	drivers/devicelist.h	/^	DT_MSP430F5438A,$/;"	e	enum:__anon44
+DT_MSP430F5500	drivers/devicelist.h	/^	DT_MSP430F5500,$/;"	e	enum:__anon44
+DT_MSP430F5501	drivers/devicelist.h	/^	DT_MSP430F5501,$/;"	e	enum:__anon44
+DT_MSP430F5502	drivers/devicelist.h	/^	DT_MSP430F5502,$/;"	e	enum:__anon44
+DT_MSP430F5503	drivers/devicelist.h	/^	DT_MSP430F5503,$/;"	e	enum:__anon44
+DT_MSP430F5504	drivers/devicelist.h	/^	DT_MSP430F5504,$/;"	e	enum:__anon44
+DT_MSP430F5505	drivers/devicelist.h	/^	DT_MSP430F5505,$/;"	e	enum:__anon44
+DT_MSP430F5506	drivers/devicelist.h	/^	DT_MSP430F5506,$/;"	e	enum:__anon44
+DT_MSP430F5507	drivers/devicelist.h	/^	DT_MSP430F5507,$/;"	e	enum:__anon44
+DT_MSP430F5508	drivers/devicelist.h	/^	DT_MSP430F5508,$/;"	e	enum:__anon44
+DT_MSP430F5509	drivers/devicelist.h	/^	DT_MSP430F5509,$/;"	e	enum:__anon44
+DT_MSP430F5510	drivers/devicelist.h	/^	DT_MSP430F5510,$/;"	e	enum:__anon44
+DT_MSP430F5513	drivers/devicelist.h	/^	DT_MSP430F5513,$/;"	e	enum:__anon44
+DT_MSP430F5514	drivers/devicelist.h	/^	DT_MSP430F5514,$/;"	e	enum:__anon44
+DT_MSP430F5515	drivers/devicelist.h	/^	DT_MSP430F5515,$/;"	e	enum:__anon44
+DT_MSP430F5517	drivers/devicelist.h	/^	DT_MSP430F5517,$/;"	e	enum:__anon44
+DT_MSP430F5519	drivers/devicelist.h	/^	DT_MSP430F5519,$/;"	e	enum:__anon44
+DT_MSP430F5521	drivers/devicelist.h	/^	DT_MSP430F5521,$/;"	e	enum:__anon44
+DT_MSP430F5522	drivers/devicelist.h	/^	DT_MSP430F5522,$/;"	e	enum:__anon44
+DT_MSP430F5524	drivers/devicelist.h	/^	DT_MSP430F5524,$/;"	e	enum:__anon44
+DT_MSP430F5525	drivers/devicelist.h	/^	DT_MSP430F5525,$/;"	e	enum:__anon44
+DT_MSP430F5526	drivers/devicelist.h	/^	DT_MSP430F5526,$/;"	e	enum:__anon44
+DT_MSP430F5527	drivers/devicelist.h	/^	DT_MSP430F5527,$/;"	e	enum:__anon44
+DT_MSP430F5528	drivers/devicelist.h	/^	DT_MSP430F5528,$/;"	e	enum:__anon44
+DT_MSP430F5529	drivers/devicelist.h	/^	DT_MSP430F5529,$/;"	e	enum:__anon44
+DT_MSP430F5630	drivers/devicelist.h	/^	DT_MSP430F5630,$/;"	e	enum:__anon44
+DT_MSP430F5631	drivers/devicelist.h	/^	DT_MSP430F5631,$/;"	e	enum:__anon44
+DT_MSP430F5632	drivers/devicelist.h	/^	DT_MSP430F5632,$/;"	e	enum:__anon44
+DT_MSP430F5633	drivers/devicelist.h	/^	DT_MSP430F5633,$/;"	e	enum:__anon44
+DT_MSP430F5634	drivers/devicelist.h	/^	DT_MSP430F5634,$/;"	e	enum:__anon44
+DT_MSP430F5635	drivers/devicelist.h	/^	DT_MSP430F5635,$/;"	e	enum:__anon44
+DT_MSP430F5636	drivers/devicelist.h	/^	DT_MSP430F5636,$/;"	e	enum:__anon44
+DT_MSP430F5637	drivers/devicelist.h	/^	DT_MSP430F5637,$/;"	e	enum:__anon44
+DT_MSP430F5638	drivers/devicelist.h	/^	DT_MSP430F5638,$/;"	e	enum:__anon44
+DT_MSP430F5658	drivers/devicelist.h	/^	DT_MSP430F5658,$/;"	e	enum:__anon44
+DT_MSP430F5659	drivers/devicelist.h	/^	DT_MSP430F5659,$/;"	e	enum:__anon44
+DT_MSP430F6433	drivers/devicelist.h	/^	DT_MSP430F6433,$/;"	e	enum:__anon44
+DT_MSP430F6435	drivers/devicelist.h	/^	DT_MSP430F6435,$/;"	e	enum:__anon44
+DT_MSP430F6436	drivers/devicelist.h	/^	DT_MSP430F6436,$/;"	e	enum:__anon44
+DT_MSP430F6438	drivers/devicelist.h	/^	DT_MSP430F6438,$/;"	e	enum:__anon44
+DT_MSP430F6457	drivers/devicelist.h	/^	DT_MSP430F6457,$/;"	e	enum:__anon44
+DT_MSP430F6458	drivers/devicelist.h	/^	DT_MSP430F6458,$/;"	e	enum:__anon44
+DT_MSP430F6459	drivers/devicelist.h	/^	DT_MSP430F6459,$/;"	e	enum:__anon44
+DT_MSP430F6630	drivers/devicelist.h	/^	DT_MSP430F6630,$/;"	e	enum:__anon44
+DT_MSP430F6631	drivers/devicelist.h	/^	DT_MSP430F6631,$/;"	e	enum:__anon44
+DT_MSP430F6632	drivers/devicelist.h	/^	DT_MSP430F6632,$/;"	e	enum:__anon44
+DT_MSP430F6633	drivers/devicelist.h	/^	DT_MSP430F6633,$/;"	e	enum:__anon44
+DT_MSP430F6634	drivers/devicelist.h	/^	DT_MSP430F6634,$/;"	e	enum:__anon44
+DT_MSP430F6635	drivers/devicelist.h	/^	DT_MSP430F6635,$/;"	e	enum:__anon44
+DT_MSP430F6636	drivers/devicelist.h	/^	DT_MSP430F6636,$/;"	e	enum:__anon44
+DT_MSP430F6637	drivers/devicelist.h	/^	DT_MSP430F6637,$/;"	e	enum:__anon44
+DT_MSP430F6638	drivers/devicelist.h	/^	DT_MSP430F6638,$/;"	e	enum:__anon44
+DT_MSP430F6658	drivers/devicelist.h	/^	DT_MSP430F6658,$/;"	e	enum:__anon44
+DT_MSP430F6659	drivers/devicelist.h	/^	DT_MSP430F6659,$/;"	e	enum:__anon44
+DT_MSP430F6700	drivers/devicelist.h	/^	DT_MSP430F6700,$/;"	e	enum:__anon44
+DT_MSP430F6701	drivers/devicelist.h	/^	DT_MSP430F6701,$/;"	e	enum:__anon44
+DT_MSP430F6702	drivers/devicelist.h	/^	DT_MSP430F6702,$/;"	e	enum:__anon44
+DT_MSP430F6703	drivers/devicelist.h	/^	DT_MSP430F6703,$/;"	e	enum:__anon44
+DT_MSP430F6720	drivers/devicelist.h	/^	DT_MSP430F6720,$/;"	e	enum:__anon44
+DT_MSP430F6721	drivers/devicelist.h	/^	DT_MSP430F6721,$/;"	e	enum:__anon44
+DT_MSP430F6722	drivers/devicelist.h	/^	DT_MSP430F6722,$/;"	e	enum:__anon44
+DT_MSP430F6723	drivers/devicelist.h	/^	DT_MSP430F6723,$/;"	e	enum:__anon44
+DT_MSP430F6724	drivers/devicelist.h	/^	DT_MSP430F6724,$/;"	e	enum:__anon44
+DT_MSP430F6725	drivers/devicelist.h	/^	DT_MSP430F6725,$/;"	e	enum:__anon44
+DT_MSP430F6726	drivers/devicelist.h	/^	DT_MSP430F6726,$/;"	e	enum:__anon44
+DT_MSP430F6730	drivers/devicelist.h	/^	DT_MSP430F6730,$/;"	e	enum:__anon44
+DT_MSP430F6731	drivers/devicelist.h	/^	DT_MSP430F6731,$/;"	e	enum:__anon44
+DT_MSP430F6732	drivers/devicelist.h	/^	DT_MSP430F6732,$/;"	e	enum:__anon44
+DT_MSP430F6733	drivers/devicelist.h	/^	DT_MSP430F6733,$/;"	e	enum:__anon44
+DT_MSP430F6734	drivers/devicelist.h	/^	DT_MSP430F6734,$/;"	e	enum:__anon44
+DT_MSP430F6735	drivers/devicelist.h	/^	DT_MSP430F6735,$/;"	e	enum:__anon44
+DT_MSP430F6736	drivers/devicelist.h	/^	DT_MSP430F6736,$/;"	e	enum:__anon44
+DT_MSP430FE423	drivers/devicelist.h	/^	DT_MSP430FE423,$/;"	e	enum:__anon44
+DT_MSP430FE4232	drivers/devicelist.h	/^	DT_MSP430FE4232,$/;"	e	enum:__anon44
+DT_MSP430FE423A	drivers/devicelist.h	/^	DT_MSP430FE423A,$/;"	e	enum:__anon44
+DT_MSP430FE425	drivers/devicelist.h	/^	DT_MSP430FE425,$/;"	e	enum:__anon44
+DT_MSP430FE425A	drivers/devicelist.h	/^	DT_MSP430FE425A,$/;"	e	enum:__anon44
+DT_MSP430FE427	drivers/devicelist.h	/^	DT_MSP430FE427,$/;"	e	enum:__anon44
+DT_MSP430FE4272	drivers/devicelist.h	/^	DT_MSP430FE4272,$/;"	e	enum:__anon44
+DT_MSP430FE427A	drivers/devicelist.h	/^	DT_MSP430FE427A,$/;"	e	enum:__anon44
+DT_MSP430FE42x2	drivers/devicelist.h	/^	DT_MSP430FE42x2,$/;"	e	enum:__anon44
+DT_MSP430FG4250	drivers/devicelist.h	/^	DT_MSP430FG4250,$/;"	e	enum:__anon44
+DT_MSP430FG42x0	drivers/devicelist.h	/^	DT_MSP430FG42x0,$/;"	e	enum:__anon44
+DT_MSP430FG43x	drivers/devicelist.h	/^	DT_MSP430FG43x,$/;"	e	enum:__anon44
+DT_MSP430FG4618	drivers/devicelist.h	/^	DT_MSP430FG4618,$/;"	e	enum:__anon44
+DT_MSP430FG4619	drivers/devicelist.h	/^	DT_MSP430FG4619,$/;"	e	enum:__anon44
+DT_MSP430FG477	drivers/devicelist.h	/^	DT_MSP430FG477,$/;"	e	enum:__anon44
+DT_MSP430FG478	drivers/devicelist.h	/^	DT_MSP430FG478,$/;"	e	enum:__anon44
+DT_MSP430FG479	drivers/devicelist.h	/^	DT_MSP430FG479,$/;"	e	enum:__anon44
+DT_MSP430FR5720	drivers/devicelist.h	/^	DT_MSP430FR5720,$/;"	e	enum:__anon44
+DT_MSP430FR5721	drivers/devicelist.h	/^	DT_MSP430FR5721,$/;"	e	enum:__anon44
+DT_MSP430FR5722	drivers/devicelist.h	/^	DT_MSP430FR5722,$/;"	e	enum:__anon44
+DT_MSP430FR5723	drivers/devicelist.h	/^	DT_MSP430FR5723,$/;"	e	enum:__anon44
+DT_MSP430FR5724	drivers/devicelist.h	/^	DT_MSP430FR5724,$/;"	e	enum:__anon44
+DT_MSP430FR5725	drivers/devicelist.h	/^	DT_MSP430FR5725,$/;"	e	enum:__anon44
+DT_MSP430FR5726	drivers/devicelist.h	/^	DT_MSP430FR5726,$/;"	e	enum:__anon44
+DT_MSP430FR5727	drivers/devicelist.h	/^	DT_MSP430FR5727,$/;"	e	enum:__anon44
+DT_MSP430FR5728	drivers/devicelist.h	/^	DT_MSP430FR5728,$/;"	e	enum:__anon44
+DT_MSP430FR5729	drivers/devicelist.h	/^	DT_MSP430FR5729,$/;"	e	enum:__anon44
+DT_MSP430FR5730	drivers/devicelist.h	/^	DT_MSP430FR5730,$/;"	e	enum:__anon44
+DT_MSP430FR5731	drivers/devicelist.h	/^	DT_MSP430FR5731,$/;"	e	enum:__anon44
+DT_MSP430FR5732	drivers/devicelist.h	/^	DT_MSP430FR5732,$/;"	e	enum:__anon44
+DT_MSP430FR5733	drivers/devicelist.h	/^	DT_MSP430FR5733,$/;"	e	enum:__anon44
+DT_MSP430FR5734	drivers/devicelist.h	/^	DT_MSP430FR5734,$/;"	e	enum:__anon44
+DT_MSP430FR5735	drivers/devicelist.h	/^	DT_MSP430FR5735,$/;"	e	enum:__anon44
+DT_MSP430FR5736	drivers/devicelist.h	/^	DT_MSP430FR5736,$/;"	e	enum:__anon44
+DT_MSP430FR5737	drivers/devicelist.h	/^	DT_MSP430FR5737,$/;"	e	enum:__anon44
+DT_MSP430FR5738	drivers/devicelist.h	/^	DT_MSP430FR5738,$/;"	e	enum:__anon44
+DT_MSP430FR5739	drivers/devicelist.h	/^	DT_MSP430FR5739,$/;"	e	enum:__anon44
+DT_MSP430FR5969	drivers/devicelist.h	/^	DT_MSP430FR5969,$/;"	e	enum:__anon44
+DT_MSP430FW429	drivers/devicelist.h	/^	DT_MSP430FW429,$/;"	e	enum:__anon44
+DT_MSP430FW42x	drivers/devicelist.h	/^	DT_MSP430FW42x,$/;"	e	enum:__anon44
+DT_MSP430G2452	drivers/devicelist.h	/^	DT_MSP430G2452,$/;"	e	enum:__anon44
+DT_MSP430G2553	drivers/devicelist.h	/^	DT_MSP430G2553,$/;"	e	enum:__anon44
+DT_MSP430L092	drivers/devicelist.h	/^	DT_MSP430L092,$/;"	e	enum:__anon44
+DT_NEEDED	formats/elf_format.h	643;"	d
+DT_NULL	formats/elf_format.h	642;"	d
+DT_NUM	formats/elf_format.h	676;"	d
+DT_PLTGOT	formats/elf_format.h	645;"	d
+DT_PLTPAD	formats/elf_format.h	717;"	d
+DT_PLTPADSZ	formats/elf_format.h	691;"	d
+DT_PLTREL	formats/elf_format.h	662;"	d
+DT_PLTRELSZ	formats/elf_format.h	644;"	d
+DT_PMS430F16x	drivers/devicelist.h	/^	DT_PMS430F16x,$/;"	e	enum:__anon44
+DT_POSFLAG_1	formats/elf_format.h	695;"	d
+DT_PPC64_GLINK	formats/elf_format.h	2226;"	d
+DT_PPC64_NUM	formats/elf_format.h	2229;"	d
+DT_PPC64_OPD	formats/elf_format.h	2227;"	d
+DT_PPC64_OPDSZ	formats/elf_format.h	2228;"	d
+DT_PPC_GOT	formats/elf_format.h	2102;"	d
+DT_PPC_NUM	formats/elf_format.h	2103;"	d
+DT_PREINIT_ARRAY	formats/elf_format.h	674;"	d
+DT_PREINIT_ARRAYSZ	formats/elf_format.h	675;"	d
+DT_PROCNUM	formats/elf_format.h	681;"	d
+DT_REL	formats/elf_format.h	659;"	d
+DT_RELA	formats/elf_format.h	649;"	d
+DT_RELACOUNT	formats/elf_format.h	728;"	d
+DT_RELAENT	formats/elf_format.h	651;"	d
+DT_RELASZ	formats/elf_format.h	650;"	d
+DT_RELCOUNT	formats/elf_format.h	729;"	d
+DT_RELENT	formats/elf_format.h	661;"	d
+DT_RELSZ	formats/elf_format.h	660;"	d
+DT_RPATH	formats/elf_format.h	657;"	d
+DT_RUNPATH	formats/elf_format.h	671;"	d
+DT_SONAME	formats/elf_format.h	656;"	d
+DT_SPARC_NUM	formats/elf_format.h	1326;"	d
+DT_SPARC_REGISTER	formats/elf_format.h	1325;"	d
+DT_STRSZ	formats/elf_format.h	652;"	d
+DT_STRTAB	formats/elf_format.h	647;"	d
+DT_SYMBOLIC	formats/elf_format.h	658;"	d
+DT_SYMENT	formats/elf_format.h	653;"	d
+DT_SYMINENT	formats/elf_format.h	698;"	d
+DT_SYMINFO	formats/elf_format.h	719;"	d
+DT_SYMINSZ	formats/elf_format.h	697;"	d
+DT_SYMTAB	formats/elf_format.h	648;"	d
+DT_TEXTREL	formats/elf_format.h	664;"	d
+DT_TLSDESC_GOT	formats/elf_format.h	711;"	d
+DT_TLSDESC_PLT	formats/elf_format.h	710;"	d
+DT_TMS430C1250	drivers/devicelist.h	/^	DT_TMS430C1250,$/;"	e	enum:__anon44
+DT_TMS430EMU	drivers/devicelist.h	/^	DT_TMS430EMU,$/;"	e	enum:__anon44
+DT_TMS430F1250	drivers/devicelist.h	/^	DT_TMS430F1250,$/;"	e	enum:__anon44
+DT_TMS430F1390	drivers/devicelist.h	/^	DT_TMS430F1390,$/;"	e	enum:__anon44
+DT_UNKNOWN_DEVICE	drivers/devicelist.h	/^	DT_UNKNOWN_DEVICE = 0,$/;"	e	enum:__anon44
+DT_VALNUM	formats/elf_format.h	701;"	d
+DT_VALRNGHI	formats/elf_format.h	699;"	d
+DT_VALRNGLO	formats/elf_format.h	686;"	d
+DT_VALTAGIDX	formats/elf_format.h	700;"	d
+DT_VERDEF	formats/elf_format.h	733;"	d
+DT_VERDEFNUM	formats/elf_format.h	735;"	d
+DT_VERNEED	formats/elf_format.h	736;"	d
+DT_VERNEEDNUM	formats/elf_format.h	738;"	d
+DT_VERSIONTAGIDX	formats/elf_format.h	739;"	d
+DT_VERSIONTAGNUM	formats/elf_format.h	740;"	d
+DT_VERSYM	formats/elf_format.h	726;"	d
+DT_XMS430F5438	drivers/devicelist.h	/^	DT_XMS430F5438,$/;"	e	enum:__anon44
+DYNLOAD_H_	util/dynload.h	20;"	d
+EDT_TRACE_MODE	drivers/tilib_defs.h	/^        EDT_TRACE_MODE = 7,$/;"	e	enum:CONFIG_MODE
+EFA_PARISC_1_0	formats/elf_format.h	1735;"	d
+EFA_PARISC_1_1	formats/elf_format.h	1736;"	d
+EFA_PARISC_2_0	formats/elf_format.h	1737;"	d
+EF_ALPHA_32BIT	formats/elf_format.h	1915;"	d
+EF_ALPHA_CANRELAX	formats/elf_format.h	1916;"	d
+EF_ARM_ALIGN8	formats/elf_format.h	2241;"	d
+EF_ARM_APCS_26	formats/elf_format.h	2238;"	d
+EF_ARM_APCS_FLOAT	formats/elf_format.h	2239;"	d
+EF_ARM_BE8	formats/elf_format.h	2257;"	d
+EF_ARM_DYNSYMSUSESEGIDX	formats/elf_format.h	2252;"	d
+EF_ARM_EABIMASK	formats/elf_format.h	2254;"	d
+EF_ARM_EABI_UNKNOWN	formats/elf_format.h	2261;"	d
+EF_ARM_EABI_VER1	formats/elf_format.h	2262;"	d
+EF_ARM_EABI_VER2	formats/elf_format.h	2263;"	d
+EF_ARM_EABI_VER3	formats/elf_format.h	2264;"	d
+EF_ARM_EABI_VER4	formats/elf_format.h	2265;"	d
+EF_ARM_EABI_VER5	formats/elf_format.h	2266;"	d
+EF_ARM_EABI_VERSION	formats/elf_format.h	2260;"	d
+EF_ARM_HASENTRY	formats/elf_format.h	2236;"	d
+EF_ARM_INTERWORK	formats/elf_format.h	2237;"	d
+EF_ARM_LE8	formats/elf_format.h	2258;"	d
+EF_ARM_MAPSYMSFIRST	formats/elf_format.h	2253;"	d
+EF_ARM_MAVERICK_FLOAT	formats/elf_format.h	2246;"	d
+EF_ARM_NEW_ABI	formats/elf_format.h	2242;"	d
+EF_ARM_OLD_ABI	formats/elf_format.h	2243;"	d
+EF_ARM_PIC	formats/elf_format.h	2240;"	d
+EF_ARM_RELEXEC	formats/elf_format.h	2235;"	d
+EF_ARM_SOFT_FLOAT	formats/elf_format.h	2244;"	d
+EF_ARM_SYMSARESORTED	formats/elf_format.h	2251;"	d
+EF_ARM_VFP_FLOAT	formats/elf_format.h	2245;"	d
+EF_CPU32	formats/elf_format.h	1089;"	d
+EF_IA_64_ABI64	formats/elf_format.h	2356;"	d
+EF_IA_64_ARCH	formats/elf_format.h	2357;"	d
+EF_IA_64_MASKOS	formats/elf_format.h	2355;"	d
+EF_MIPS_64BIT_WHIRL	formats/elf_format.h	1347;"	d
+EF_MIPS_ABI2	formats/elf_format.h	1348;"	d
+EF_MIPS_ABI_ON32	formats/elf_format.h	1349;"	d
+EF_MIPS_ARCH	formats/elf_format.h	1350;"	d
+EF_MIPS_ARCH_1	formats/elf_format.h	1354;"	d
+EF_MIPS_ARCH_2	formats/elf_format.h	1355;"	d
+EF_MIPS_ARCH_3	formats/elf_format.h	1356;"	d
+EF_MIPS_ARCH_32	formats/elf_format.h	1359;"	d
+EF_MIPS_ARCH_4	formats/elf_format.h	1357;"	d
+EF_MIPS_ARCH_5	formats/elf_format.h	1358;"	d
+EF_MIPS_ARCH_64	formats/elf_format.h	1360;"	d
+EF_MIPS_CPIC	formats/elf_format.h	1345;"	d
+EF_MIPS_NOREORDER	formats/elf_format.h	1343;"	d
+EF_MIPS_PIC	formats/elf_format.h	1344;"	d
+EF_MIPS_XGOT	formats/elf_format.h	1346;"	d
+EF_PARISC_ARCH	formats/elf_format.h	1731;"	d
+EF_PARISC_EXT	formats/elf_format.h	1725;"	d
+EF_PARISC_LAZYSWAP	formats/elf_format.h	1730;"	d
+EF_PARISC_LSB	formats/elf_format.h	1726;"	d
+EF_PARISC_NO_KABP	formats/elf_format.h	1728;"	d
+EF_PARISC_TRAPNIL	formats/elf_format.h	1724;"	d
+EF_PARISC_WIDE	formats/elf_format.h	1727;"	d
+EF_PPC_EMB	formats/elf_format.h	1985;"	d
+EF_PPC_RELOCATABLE	formats/elf_format.h	1988;"	d
+EF_PPC_RELOCATABLE_LIB	formats/elf_format.h	1989;"	d
+EF_SPARCV9_MM	formats/elf_format.h	1213;"	d
+EF_SPARCV9_PSO	formats/elf_format.h	1215;"	d
+EF_SPARCV9_RMO	formats/elf_format.h	1216;"	d
+EF_SPARCV9_TSO	formats/elf_format.h	1214;"	d
+EF_SPARC_32PLUS	formats/elf_format.h	1219;"	d
+EF_SPARC_EXT_MASK	formats/elf_format.h	1218;"	d
+EF_SPARC_HAL_R1	formats/elf_format.h	1221;"	d
+EF_SPARC_LEDATA	formats/elf_format.h	1217;"	d
+EF_SPARC_SUN_US1	formats/elf_format.h	1220;"	d
+EF_SPARC_SUN_US3	formats/elf_format.h	1222;"	d
+EI_ABIVERSION	formats/elf_format.h	152;"	d
+EI_CLASS	formats/elf_format.h	121;"	d
+EI_DATA	formats/elf_format.h	127;"	d
+EI_MAG0	formats/elf_format.h	105;"	d
+EI_MAG1	formats/elf_format.h	108;"	d
+EI_MAG2	formats/elf_format.h	111;"	d
+EI_MAG3	formats/elf_format.h	114;"	d
+EI_NIDENT	formats/elf_format.h	63;"	d
+EI_OSABI	formats/elf_format.h	136;"	d
+EI_PAD	formats/elf_format.h	154;"	d
+EI_VERSION	formats/elf_format.h	133;"	d
+ELF32_H_	formats/elf32.h	20;"	d
+ELF32_M_INFO	formats/elf_format.h	1079;"	d
+ELF32_M_SIZE	formats/elf_format.h	1078;"	d
+ELF32_M_SYM	formats/elf_format.h	1077;"	d
+ELF32_R_INFO	formats/elf_format.h	525;"	d
+ELF32_R_SYM	formats/elf_format.h	523;"	d
+ELF32_R_TYPE	formats/elf_format.h	524;"	d
+ELF32_ST_BIND	formats/elf_format.h	427;"	d
+ELF32_ST_INFO	formats/elf_format.h	429;"	d
+ELF32_ST_TYPE	formats/elf_format.h	428;"	d
+ELF32_ST_VISIBILITY	formats/elf_format.h	474;"	d
+ELF64_M_INFO	formats/elf_format.h	1083;"	d
+ELF64_M_SIZE	formats/elf_format.h	1082;"	d
+ELF64_M_SYM	formats/elf_format.h	1081;"	d
+ELF64_R_INFO	formats/elf_format.h	529;"	d
+ELF64_R_SYM	formats/elf_format.h	527;"	d
+ELF64_R_TYPE	formats/elf_format.h	528;"	d
+ELF64_ST_BIND	formats/elf_format.h	432;"	d
+ELF64_ST_INFO	formats/elf_format.h	434;"	d
+ELF64_ST_TYPE	formats/elf_format.h	433;"	d
+ELF64_ST_VISIBILITY	formats/elf_format.h	477;"	d
+ELFCLASS32	formats/elf_format.h	123;"	d
+ELFCLASS64	formats/elf_format.h	124;"	d
+ELFCLASSNONE	formats/elf_format.h	122;"	d
+ELFCLASSNUM	formats/elf_format.h	125;"	d
+ELFDATA2LSB	formats/elf_format.h	129;"	d
+ELFDATA2MSB	formats/elf_format.h	130;"	d
+ELFDATANONE	formats/elf_format.h	128;"	d
+ELFDATANUM	formats/elf_format.h	131;"	d
+ELFMAG	formats/elf_format.h	118;"	d
+ELFMAG0	formats/elf_format.h	106;"	d
+ELFMAG1	formats/elf_format.h	109;"	d
+ELFMAG2	formats/elf_format.h	112;"	d
+ELFMAG3	formats/elf_format.h	115;"	d
+ELFOSABI_AIX	formats/elf_format.h	143;"	d
+ELFOSABI_ARM	formats/elf_format.h	149;"	d
+ELFOSABI_FREEBSD	formats/elf_format.h	145;"	d
+ELFOSABI_HPUX	formats/elf_format.h	139;"	d
+ELFOSABI_IRIX	formats/elf_format.h	144;"	d
+ELFOSABI_LINUX	formats/elf_format.h	141;"	d
+ELFOSABI_MODESTO	formats/elf_format.h	147;"	d
+ELFOSABI_NETBSD	formats/elf_format.h	140;"	d
+ELFOSABI_NONE	formats/elf_format.h	137;"	d
+ELFOSABI_OPENBSD	formats/elf_format.h	148;"	d
+ELFOSABI_SOLARIS	formats/elf_format.h	142;"	d
+ELFOSABI_STANDALONE	formats/elf_format.h	150;"	d
+ELFOSABI_SYSV	formats/elf_format.h	138;"	d
+ELFOSABI_TRU64	formats/elf_format.h	146;"	d
+ELF_NOTE_ABI	formats/elf_format.h	1032;"	d
+ELF_NOTE_GNU	formats/elf_format.h	1014;"	d
+ELF_NOTE_OS_FREEBSD	formats/elf_format.h	1039;"	d
+ELF_NOTE_OS_GNU	formats/elf_format.h	1037;"	d
+ELF_NOTE_OS_LINUX	formats/elf_format.h	1036;"	d
+ELF_NOTE_OS_SOLARIS2	formats/elf_format.h	1038;"	d
+ELF_NOTE_PAGESIZE_HINT	formats/elf_format.h	1020;"	d
+ELF_NOTE_SOLARIS	formats/elf_format.h	1011;"	d
+EMB_SYS_OFFSET	drivers/fet_olimex_db.c	33;"	d	file:
+EMULATION_MODE	drivers/tilib_defs.h	/^        EMULATION_MODE = 1,$/;"	e	enum:CONFIG_MODE
+EM_386	formats/elf_format.h	174;"	d
+EM_68HC05	formats/elf_format.h	225;"	d
+EM_68HC08	formats/elf_format.h	224;"	d
+EM_68HC11	formats/elf_format.h	223;"	d
+EM_68HC12	formats/elf_format.h	207;"	d
+EM_68HC16	formats/elf_format.h	222;"	d
+EM_68K	formats/elf_format.h	175;"	d
+EM_860	formats/elf_format.h	177;"	d
+EM_88K	formats/elf_format.h	176;"	d
+EM_960	formats/elf_format.h	185;"	d
+EM_ALPHA	formats/elf_format.h	254;"	d
+EM_ARC	formats/elf_format.h	199;"	d
+EM_ARC_A5	formats/elf_format.h	246;"	d
+EM_ARM	formats/elf_format.h	194;"	d
+EM_AVR	formats/elf_format.h	236;"	d
+EM_COLDFIRE	formats/elf_format.h	206;"	d
+EM_CRIS	formats/elf_format.h	229;"	d
+EM_D10V	formats/elf_format.h	238;"	d
+EM_D30V	formats/elf_format.h	239;"	d
+EM_FAKE_ALPHA	formats/elf_format.h	195;"	d
+EM_FIREPATH	formats/elf_format.h	231;"	d
+EM_FR20	formats/elf_format.h	191;"	d
+EM_FR30	formats/elf_format.h	237;"	d
+EM_FX66	formats/elf_format.h	219;"	d
+EM_H8S	formats/elf_format.h	202;"	d
+EM_H8_300	formats/elf_format.h	200;"	d
+EM_H8_300H	formats/elf_format.h	201;"	d
+EM_H8_500	formats/elf_format.h	203;"	d
+EM_HUANY	formats/elf_format.h	234;"	d
+EM_IA_64	formats/elf_format.h	204;"	d
+EM_JAVELIN	formats/elf_format.h	230;"	d
+EM_M32	formats/elf_format.h	172;"	d
+EM_M32R	formats/elf_format.h	241;"	d
+EM_ME16	formats/elf_format.h	213;"	d
+EM_MIPS	formats/elf_format.h	178;"	d
+EM_MIPS_RS3_LE	formats/elf_format.h	180;"	d
+EM_MIPS_X	formats/elf_format.h	205;"	d
+EM_MMA	formats/elf_format.h	208;"	d
+EM_MMIX	formats/elf_format.h	233;"	d
+EM_MN10200	formats/elf_format.h	243;"	d
+EM_MN10300	formats/elf_format.h	242;"	d
+EM_MSP430	formats/elf32.c	28;"	d	file:
+EM_NCPU	formats/elf_format.h	210;"	d
+EM_NDR1	formats/elf_format.h	211;"	d
+EM_NONE	formats/elf_format.h	171;"	d
+EM_NUM	formats/elf_format.h	248;"	d
+EM_OPENRISC	formats/elf_format.h	245;"	d
+EM_PARISC	formats/elf_format.h	182;"	d
+EM_PCP	formats/elf_format.h	209;"	d
+EM_PDSP	formats/elf_format.h	217;"	d
+EM_PJ	formats/elf_format.h	244;"	d
+EM_PPC	formats/elf_format.h	186;"	d
+EM_PPC64	formats/elf_format.h	187;"	d
+EM_PRISM	formats/elf_format.h	235;"	d
+EM_RCE	formats/elf_format.h	193;"	d
+EM_RH32	formats/elf_format.h	192;"	d
+EM_S370	formats/elf_format.h	179;"	d
+EM_S390	formats/elf_format.h	188;"	d
+EM_SH	formats/elf_format.h	196;"	d
+EM_SPARC	formats/elf_format.h	173;"	d
+EM_SPARC32PLUS	formats/elf_format.h	184;"	d
+EM_SPARCV9	formats/elf_format.h	197;"	d
+EM_ST100	formats/elf_format.h	214;"	d
+EM_ST19	formats/elf_format.h	227;"	d
+EM_ST7	formats/elf_format.h	221;"	d
+EM_ST9PLUS	formats/elf_format.h	220;"	d
+EM_STARCORE	formats/elf_format.h	212;"	d
+EM_SVX	formats/elf_format.h	226;"	d
+EM_TINYJ	formats/elf_format.h	215;"	d
+EM_TRICORE	formats/elf_format.h	198;"	d
+EM_V800	formats/elf_format.h	190;"	d
+EM_V850	formats/elf_format.h	240;"	d
+EM_VAX	formats/elf_format.h	228;"	d
+EM_VPP500	formats/elf_format.h	183;"	d
+EM_X86_64	formats/elf_format.h	216;"	d
+EM_XTENSA	formats/elf_format.h	247;"	d
+EM_ZSP	formats/elf_format.h	232;"	d
+ENABLE	drivers/jtdev.c	69;"	d	file:
+EP_IN	transport/ftdi.c	36;"	d	file:
+EP_OUT	transport/ftdi.c	37;"	d	file:
+ERASE_ALL	drivers/tilib_defs.h	/^        ERASE_ALL = 2, \/**< Erase all MAIN and INFORMATION memory *\/$/;"	e	enum:ERASE_TYPE
+ERASE_MAIN	drivers/tilib_defs.h	/^        ERASE_MAIN = 1, \/**< Erase all MAIN memory *\/$/;"	e	enum:ERASE_TYPE
+ERASE_SEGMENT	drivers/flash_bsl.c	92;"	d	file:
+ERASE_SEGMENT	drivers/tilib_defs.h	/^        ERASE_SEGMENT = 0, \/**< Erase a segment *\/$/;"	e	enum:ERASE_TYPE
+ERASE_TYPE	drivers/tilib_defs.h	/^enum ERASE_TYPE {$/;"	g
+ERR	drivers/jtdev.c	47;"	d	file:
+ET_CORE	formats/elf_format.h	162;"	d
+ET_DYN	formats/elf_format.h	161;"	d
+ET_EXEC	formats/elf_format.h	160;"	d
+ET_HIOS	formats/elf_format.h	165;"	d
+ET_HIPROC	formats/elf_format.h	167;"	d
+ET_LOOS	formats/elf_format.h	164;"	d
+ET_LOPROC	formats/elf_format.h	166;"	d
+ET_NONE	formats/elf_format.h	158;"	d
+ET_NUM	formats/elf_format.h	163;"	d
+ET_REL	formats/elf_format.h	159;"	d
+EVENT_IRQ_HANDLE	simio/simio_tracer.c	/^	EVENT_IRQ_HANDLE,$/;"	e	enum:__anon64	file:
+EVENT_READ_16	simio/simio_tracer.c	/^	EVENT_READ_16,$/;"	e	enum:__anon64	file:
+EVENT_READ_8	simio/simio_tracer.c	/^	EVENT_READ_8,$/;"	e	enum:__anon64	file:
+EVENT_RESET	simio/simio_tracer.c	/^	EVENT_RESET$/;"	e	enum:__anon64	file:
+EVENT_WRITE_16	simio/simio_tracer.c	/^	EVENT_WRITE_16,$/;"	e	enum:__anon64	file:
+EVENT_WRITE_8	simio/simio_tracer.c	/^	EVENT_WRITE_8,$/;"	e	enum:__anon64	file:
+EV_CURRENT	formats/elf_format.h	259;"	d
+EV_NONE	formats/elf_format.h	258;"	d
+EV_NUM	formats/elf_format.h	260;"	d
+EXPR_H_	util/expr.h	20;"	d
+EXTENSION_BIT	util/dis.c	29;"	d	file:
+E_MIPS_ARCH_1	formats/elf_format.h	1364;"	d
+E_MIPS_ARCH_2	formats/elf_format.h	1365;"	d
+E_MIPS_ARCH_3	formats/elf_format.h	1366;"	d
+E_MIPS_ARCH_32	formats/elf_format.h	1369;"	d
+E_MIPS_ARCH_4	formats/elf_format.h	1367;"	d
+E_MIPS_ARCH_5	formats/elf_format.h	1368;"	d
+E_MIPS_ARCH_64	formats/elf_format.h	1370;"	d
+Elf32_Addr	formats/elf_format.h	/^typedef uint32_t Elf32_Addr;$/;"	t
+Elf32_Conflict	formats/elf_format.h	/^typedef Elf32_Addr Elf32_Conflict;$/;"	t
+Elf32_Dyn	formats/elf_format.h	/^} Elf32_Dyn;$/;"	t	typeref:struct:__anon15
+Elf32_Ehdr	formats/elf_format.h	/^} Elf32_Ehdr;$/;"	t	typeref:struct:__anon1
+Elf32_Half	formats/elf_format.h	/^typedef uint16_t Elf32_Half;$/;"	t
+Elf32_Lib	formats/elf_format.h	/^} Elf32_Lib;$/;"	t	typeref:struct:__anon41
+Elf32_Move	formats/elf_format.h	/^} Elf32_Move;$/;"	t	typeref:struct:__anon33
+Elf32_Nhdr	formats/elf_format.h	/^} Elf32_Nhdr;$/;"	t	typeref:struct:__anon31
+Elf32_Off	formats/elf_format.h	/^typedef uint32_t Elf32_Off;$/;"	t
+Elf32_Phdr	formats/elf_format.h	/^} Elf32_Phdr;$/;"	t	typeref:struct:__anon13
+Elf32_RegInfo	formats/elf_format.h	/^} Elf32_RegInfo;$/;"	t	typeref:struct:__anon38
+Elf32_Rel	formats/elf_format.h	/^} Elf32_Rel;$/;"	t	typeref:struct:__anon9
+Elf32_Rela	formats/elf_format.h	/^} Elf32_Rela;$/;"	t	typeref:struct:__anon11
+Elf32_Section	formats/elf_format.h	/^typedef uint16_t Elf32_Section;$/;"	t
+Elf32_Shdr	formats/elf_format.h	/^} Elf32_Shdr;$/;"	t	typeref:struct:__anon3
+Elf32_Sword	formats/elf_format.h	/^typedef	int32_t  Elf32_Sword;$/;"	t
+Elf32_Sxword	formats/elf_format.h	/^typedef	int64_t  Elf32_Sxword;$/;"	t
+Elf32_Sym	formats/elf_format.h	/^} Elf32_Sym;$/;"	t	typeref:struct:__anon5
+Elf32_Syminfo	formats/elf_format.h	/^} Elf32_Syminfo;$/;"	t	typeref:struct:__anon7
+Elf32_Verdaux	formats/elf_format.h	/^} Elf32_Verdaux;$/;"	t	typeref:struct:__anon21
+Elf32_Verdef	formats/elf_format.h	/^} Elf32_Verdef;$/;"	t	typeref:struct:__anon19
+Elf32_Vernaux	formats/elf_format.h	/^} Elf32_Vernaux;$/;"	t	typeref:struct:__anon25
+Elf32_Verneed	formats/elf_format.h	/^} Elf32_Verneed;$/;"	t	typeref:struct:__anon23
+Elf32_Versym	formats/elf_format.h	/^typedef Elf32_Half Elf32_Versym;$/;"	t
+Elf32_Word	formats/elf_format.h	/^typedef uint32_t Elf32_Word;$/;"	t
+Elf32_Xword	formats/elf_format.h	/^typedef uint64_t Elf32_Xword;$/;"	t
+Elf32_auxv_t	formats/elf_format.h	/^} Elf32_auxv_t;$/;"	t	typeref:struct:__anon27
+Elf32_gptab	formats/elf_format.h	/^} Elf32_gptab;$/;"	t	typeref:union:__anon35
+Elf64_Addr	formats/elf_format.h	/^typedef uint64_t Elf64_Addr;$/;"	t
+Elf64_Dyn	formats/elf_format.h	/^} Elf64_Dyn;$/;"	t	typeref:struct:__anon17
+Elf64_Ehdr	formats/elf_format.h	/^} Elf64_Ehdr;$/;"	t	typeref:struct:__anon2
+Elf64_Half	formats/elf_format.h	/^typedef uint16_t Elf64_Half;$/;"	t
+Elf64_Lib	formats/elf_format.h	/^} Elf64_Lib;$/;"	t	typeref:struct:__anon42
+Elf64_Move	formats/elf_format.h	/^} Elf64_Move;$/;"	t	typeref:struct:__anon34
+Elf64_Nhdr	formats/elf_format.h	/^} Elf64_Nhdr;$/;"	t	typeref:struct:__anon32
+Elf64_Off	formats/elf_format.h	/^typedef uint64_t Elf64_Off;$/;"	t
+Elf64_Phdr	formats/elf_format.h	/^} Elf64_Phdr;$/;"	t	typeref:struct:__anon14
+Elf64_Rel	formats/elf_format.h	/^} Elf64_Rel;$/;"	t	typeref:struct:__anon10
+Elf64_Rela	formats/elf_format.h	/^} Elf64_Rela;$/;"	t	typeref:struct:__anon12
+Elf64_Section	formats/elf_format.h	/^typedef uint16_t Elf64_Section;$/;"	t
+Elf64_Shdr	formats/elf_format.h	/^} Elf64_Shdr;$/;"	t	typeref:struct:__anon4
+Elf64_Sword	formats/elf_format.h	/^typedef	int32_t  Elf64_Sword;$/;"	t
+Elf64_Sxword	formats/elf_format.h	/^typedef	int64_t  Elf64_Sxword;$/;"	t
+Elf64_Sym	formats/elf_format.h	/^} Elf64_Sym;$/;"	t	typeref:struct:__anon6
+Elf64_Syminfo	formats/elf_format.h	/^} Elf64_Syminfo;$/;"	t	typeref:struct:__anon8
+Elf64_Verdaux	formats/elf_format.h	/^} Elf64_Verdaux;$/;"	t	typeref:struct:__anon22
+Elf64_Verdef	formats/elf_format.h	/^} Elf64_Verdef;$/;"	t	typeref:struct:__anon20
+Elf64_Vernaux	formats/elf_format.h	/^} Elf64_Vernaux;$/;"	t	typeref:struct:__anon26
+Elf64_Verneed	formats/elf_format.h	/^} Elf64_Verneed;$/;"	t	typeref:struct:__anon24
+Elf64_Versym	formats/elf_format.h	/^typedef Elf64_Half Elf64_Versym;$/;"	t
+Elf64_Word	formats/elf_format.h	/^typedef uint32_t Elf64_Word;$/;"	t
+Elf64_Xword	formats/elf_format.h	/^typedef uint64_t Elf64_Xword;$/;"	t
+Elf64_auxv_t	formats/elf_format.h	/^} Elf64_auxv_t;$/;"	t	typeref:struct:__anon29
+Elf_Options	formats/elf_format.h	/^} Elf_Options;$/;"	t	typeref:struct:__anon39
+Elf_Options_Hw	formats/elf_format.h	/^} Elf_Options_Hw;$/;"	t	typeref:struct:__anon40
+FAB_ID_OFFSET	drivers/fet_olimex_db.c	30;"	d	file:
+FCTL3_ADDR	drivers/sim.c	42;"	d	file:
+FET_CONFIG_CLKCTRL	drivers/fet_core.c	111;"	d	file:
+FET_CONFIG_EMULATION	drivers/fet_core.c	110;"	d	file:
+FET_CONFIG_FLASH_LOCK	drivers/fet_core.c	114;"	d	file:
+FET_CONFIG_FLASH_TESET	drivers/fet_core.c	113;"	d	file:
+FET_CONFIG_MCLKCTRL	drivers/fet_core.c	112;"	d	file:
+FET_CONFIG_PROTOCOL	drivers/fet_core.c	115;"	d	file:
+FET_CONFIG_UNLOCK_BSL	drivers/fet_core.c	116;"	d	file:
+FET_CONFIG_VERIFICATION	drivers/fet_core.c	109;"	d	file:
+FET_CORE_H_	drivers/fet_core.h	20;"	d
+FET_DB_H_	drivers/fet_db.h	20;"	d
+FET_DB_MSG28_LEN	drivers/fet_db.h	24;"	d
+FET_DB_MSG29_LEN	drivers/fet_db.h	26;"	d
+FET_DB_MSG29_PARAMS	drivers/fet_db.h	25;"	d
+FET_DB_MSG2B_LEN	drivers/fet_db.h	27;"	d
+FET_ERASE_ALL	drivers/fet_core.c	129;"	d	file:
+FET_ERASE_MAIN	drivers/fet_core.c	128;"	d	file:
+FET_ERASE_SEGMENT	drivers/fet_core.c	127;"	d	file:
+FET_ERROR_H_	drivers/fet_error.h	20;"	d
+FET_FORCE_RESET	drivers/fet_core.h	32;"	d
+FET_H_	drivers/fet.h	20;"	d
+FET_IDENTIFY_NEW	drivers/fet_core.h	29;"	d
+FET_OLIMEX_DB_H_	drivers/fet_olimex_db.h	21;"	d
+FET_OLIMEX_DB_MSG28_LEN	drivers/fet_olimex_db.h	26;"	d
+FET_OLIMEX_DB_MSG29_LEN	drivers/fet_olimex_db.h	28;"	d
+FET_OLIMEX_DB_MSG29_PARAMS	drivers/fet_olimex_db.h	27;"	d
+FET_OLIMEX_DB_MSG2B_LEN	drivers/fet_olimex_db.h	29;"	d
+FET_POLL_BREAKPOINT	drivers/fet_core.c	132;"	d	file:
+FET_POLL_RUNNING	drivers/fet_core.c	131;"	d	file:
+FET_PROTO_EXTRA_RECV	drivers/fet_proto.h	30;"	d
+FET_PROTO_H_	drivers/fet_proto.h	20;"	d
+FET_PROTO_MAX_BLOCK	drivers/fet_proto.h	37;"	d
+FET_PROTO_MAX_PARAMS	drivers/fet_proto.h	36;"	d
+FET_PROTO_NOLEAD_SEND	drivers/fet_proto.h	33;"	d
+FET_PROTO_SEPARATE_DATA	drivers/fet_proto.h	27;"	d
+FET_RESET_ALL	drivers/fet_core.c	125;"	d	file:
+FET_RESET_PUC	drivers/fet_core.c	122;"	d	file:
+FET_RESET_RST	drivers/fet_core.c	123;"	d	file:
+FET_RESET_VCC	drivers/fet_core.c	124;"	d	file:
+FET_RUN_BREAKPOINT	drivers/fet_core.c	120;"	d	file:
+FET_RUN_FREE	drivers/fet_core.c	118;"	d	file:
+FET_RUN_STEP	drivers/fet_core.c	119;"	d	file:
+FET_SKIP_CLOSE	drivers/fet_core.h	26;"	d
+FILE_HEADER_SIZE	formats/coff.c	38;"	d	file:
+FLASH_BSL_H_	drivers/flash_bsl.h	21;"	d
+FLASH_PAGE_SIZE	drivers/obl.c	28;"	d	file:
+FLASH_SWOP	drivers/tilib_defs.h	/^        FLASH_SWOP = 6,$/;"	e	enum:CONFIG_MODE
+FLASH_TEST_MODE	drivers/tilib_defs.h	/^        FLASH_TEST_MODE = 4,$/;"	e	enum:CONFIG_MODE
+FLATFILE_H_	ui/flatfile.h	21;"	d
+FORCE_RESET	drivers/tilib_defs.h	/^	FORCE_RESET = (1 << 3)$/;"	e	enum:RESET_METHOD
+FPERM_BSL	util/opdb.h	/^	FPERM_BSL = 0x02$/;"	e	enum:__anon62
+FPERM_LOCKED_FLASH	util/opdb.h	/^	FPERM_LOCKED_FLASH = 0x01,$/;"	e	enum:__anon62
+FREE_RUN	drivers/tilib_defs.h	/^        FREE_RUN = 1,$/;"	e	enum:RUN_MODES
+FTDI_CLOCK	transport/ftdi.c	63;"	d	file:
+FTDI_DTR	transport/ftdi.c	65;"	d	file:
+FTDI_H_	transport/ftdi.h	20;"	d
+FTDI_PACKET_SIZE	transport/ftdi.c	61;"	d	file:
+FTDI_RTS	transport/ftdi.c	66;"	d	file:
+FTDI_SIO_GET_LATENCY_TIMER	transport/ftdi.c	55;"	d	file:
+FTDI_SIO_GET_MODEM_STATUS	transport/ftdi.c	50;"	d	file:
+FTDI_SIO_MODEM_CTRL	transport/ftdi.c	45;"	d	file:
+FTDI_SIO_RESET	transport/ftdi.c	44;"	d	file:
+FTDI_SIO_RESET_PURGE_RX	transport/ftdi.c	58;"	d	file:
+FTDI_SIO_RESET_PURGE_TX	transport/ftdi.c	59;"	d	file:
+FTDI_SIO_RESET_SIO	transport/ftdi.c	57;"	d	file:
+FTDI_SIO_SET_BAUD_RATE	transport/ftdi.c	47;"	d	file:
+FTDI_SIO_SET_DATA	transport/ftdi.c	48;"	d	file:
+FTDI_SIO_SET_ERROR_CHAR	transport/ftdi.c	53;"	d	file:
+FTDI_SIO_SET_EVENT_CHAR	transport/ftdi.c	52;"	d	file:
+FTDI_SIO_SET_FLOW_CTRL	transport/ftdi.c	46;"	d	file:
+FTDI_SIO_SET_LATENCY_TIMER	transport/ftdi.c	54;"	d	file:
+FTDI_WRITE_DTR	transport/ftdi.c	67;"	d	file:
+FTDI_WRITE_RTS	transport/ftdi.c	68;"	d	file:
+F_BIG	formats/coff.c	48;"	d	file:
+F_EXEC	formats/coff.c	45;"	d	file:
+F_LITTLE	formats/coff.c	47;"	d	file:
+F_LSYMS	formats/coff.c	46;"	d	file:
+F_RELFLG	formats/coff.c	44;"	d	file:
+F_SYMMERGE	formats/coff.c	49;"	d	file:
+GCC_CFLAGS	Makefile	/^GCC_CFLAGS = -O1 -Wall -Wno-char-subscripts -ggdb$/;"	m
+GDBC_H_	drivers/gdbc.h	20;"	d
+GDB_BUF_SIZE	util/gdb_proto.h	23;"	d
+GDB_H_	ui/gdb.h	20;"	d
+GDB_MAX_XFER	util/gdb_proto.h	22;"	d
+GDB_PROTO_H_	util/gdb_proto.h	20;"	d
+GIE_MASK	drivers/sim.c	49;"	d	file:
+GLOBAL_CALL	drivers/goodfet.c	39;"	d	file:
+GLOBAL_DEBUG	drivers/goodfet.c	46;"	d	file:
+GLOBAL_EXEC	drivers/goodfet.c	40;"	d	file:
+GLOBAL_EXIST	drivers/goodfet.c	42;"	d	file:
+GLOBAL_LIMIT	drivers/goodfet.c	41;"	d	file:
+GLOBAL_NMEM	drivers/goodfet.c	43;"	d	file:
+GLOBAL_NOK	drivers/goodfet.c	44;"	d	file:
+GLOBAL_OK	drivers/goodfet.c	45;"	d	file:
+GLOBAL_PEEK	drivers/goodfet.c	34;"	d	file:
+GLOBAL_POKE	drivers/goodfet.c	35;"	d	file:
+GLOBAL_READ	drivers/goodfet.c	32;"	d	file:
+GLOBAL_SETUP	drivers/goodfet.c	36;"	d	file:
+GLOBAL_START	drivers/goodfet.c	37;"	d	file:
+GLOBAL_STOP	drivers/goodfet.c	38;"	d	file:
+GLOBAL_WRITE	drivers/goodfet.c	33;"	d	file:
+GOODFET_H_	drivers/goodfet.h	20;"	d
+GRP_COMDAT	formats/elf_format.h	369;"	d
+HI_MASK_INTERRUPT_IRQ	drivers/sim.c	79;"	d	file:
+HWCAP_SPARC_BLKINIT	formats/elf_format.h	1336;"	d
+HWCAP_SPARC_FLUSH	formats/elf_format.h	1330;"	d
+HWCAP_SPARC_MULDIV	formats/elf_format.h	1333;"	d
+HWCAP_SPARC_N2	formats/elf_format.h	1337;"	d
+HWCAP_SPARC_STBAR	formats/elf_format.h	1331;"	d
+HWCAP_SPARC_SWAP	formats/elf_format.h	1332;"	d
+HWCAP_SPARC_ULTRA3	formats/elf_format.h	1335;"	d
+HWCAP_SPARC_V9	formats/elf_format.h	1334;"	d
+HasFramMemroy	drivers/tilib_defs.h	/^		WORD HasFramMemroy;$/;"	m	struct:DEVICE_T::__anon45
+ID0	simio/simio_timer.c	32;"	d	file:
+ID0_OFFSET	drivers/fet_olimex_db.c	27;"	d	file:
+ID1	simio/simio_timer.c	31;"	d	file:
+ID1_OFFSET	drivers/fet_olimex_db.c	28;"	d	file:
+IE1_ADDR	drivers/sim.c	39;"	d	file:
+IFG1_ADDR	drivers/sim.c	41;"	d	file:
+IHEX_H_	formats/ihex.h	20;"	d
+IHEX_REC_DATA	ui/devcmd.c	375;"	d	file:
+IHEX_REC_ELAR	ui/devcmd.c	379;"	d	file:
+IHEX_REC_EOF	ui/devcmd.c	376;"	d	file:
+IHEX_REC_ESAR	ui/devcmd.c	377;"	d	file:
+IHEX_REC_SLAR	ui/devcmd.c	380;"	d	file:
+IHEX_REC_SSAR	ui/devcmd.c	378;"	d	file:
+IHEX_SEG	ui/devcmd.c	381;"	d	file:
+IMAGE_MAGIC	drivers/obl.c	27;"	d	file:
+INCLUDES	Makefile	/^INCLUDES = -I. -Isimio -Iformats -Itransport -Idrivers -Iutil -Iui$/;"	m
+INIT	drivers/jtdev.c	56;"	d	file:
+INPUT_ASYNC_H_	ui/input_async.h	20;"	d
+INPUT_CONSOLE_H_	ui/input_console.h	20;"	d
+INPUT_H_	ui/input.h	20;"	d
+INSTALL	Makefile	/^INSTALL = \/usr\/bin\/install$/;"	m
+INTERFACE_MODE	drivers/tilib_defs.h	/^        INTERFACE_MODE = 8,$/;"	e	enum:CONFIG_MODE
+INTERRUPT_ACCV	drivers/sim.c	/^	INTERRUPT_ACCV,		\/* Flash Access Violation *\/$/;"	e	enum:__anon50	file:
+INTERRUPT_MASK	drivers/sim.c	/^	INTERRUPT_MASK,		\/* All maskable interrupts *\/$/;"	e	enum:__anon50	file:
+INTERRUPT_NMI	drivers/sim.c	/^	INTERRUPT_NMI,		\/* NMI *\/$/;"	e	enum:__anon50	file:
+INTERRUPT_NONE	drivers/sim.c	/^	INTERRUPT_NONE,$/;"	e	enum:__anon50	file:
+INTERRUPT_OF	drivers/sim.c	/^	INTERRUPT_OF,		\/* Oscilalator Fault *\/$/;"	e	enum:__anon50	file:
+INTERRUPT_RST	drivers/sim.c	/^	INTERRUPT_RST, 		\/* RST *\/$/;"	e	enum:__anon50	file:
+INTERRUPT_TOTAL_NUM	drivers/sim.c	/^	INTERRUPT_TOTAL_NUM$/;"	e	enum:__anon50	file:
+IO_REQUEST_FUNC	simio/simio.c	/^IO_REQUEST_FUNC(simio_write, write, uint16_t)$/;"	f
+IO_REQUEST_FUNC	simio/simio.c	324;"	d	file:
+IO_REQUEST_FUNC_S	simio/simio.c	343;"	d	file:
+IRQEN	drivers/jtdev.c	58;"	d	file:
+IR_ADDR_16BIT	drivers/jtaglib.c	45;"	d	file:
+IR_ADDR_CAPTURE	drivers/jtaglib.c	46;"	d	file:
+IR_BYPASS	drivers/jtaglib.c	55;"	d	file:
+IR_CNTRL_SIG_16BIT	drivers/jtaglib.c	37;"	d	file:
+IR_CNTRL_SIG_CAPTURE	drivers/jtaglib.c	38;"	d	file:
+IR_CNTRL_SIG_RELEASE	drivers/jtaglib.c	39;"	d	file:
+IR_DATA_16BIT	drivers/jtaglib.c	41;"	d	file:
+IR_DATA_CAPTURE	drivers/jtaglib.c	42;"	d	file:
+IR_DATA_PSA	drivers/jtaglib.c	49;"	d	file:
+IR_DATA_QUICK	drivers/jtaglib.c	43;"	d	file:
+IR_DATA_TO_ADDR	drivers/jtaglib.c	47;"	d	file:
+IR_EX_BLOW	drivers/jtaglib.c	53;"	d	file:
+IR_PREPARE_BLOW	drivers/jtaglib.c	52;"	d	file:
+IR_SHIFT_OUT_PSA	drivers/jtaglib.c	50;"	d	file:
+ISEARCH_DSIZE	ui/rtools.c	38;"	d	file:
+ISEARCH_DST_ADDR	ui/rtools.c	40;"	d	file:
+ISEARCH_DST_MODE	ui/rtools.c	42;"	d	file:
+ISEARCH_DST_REG	ui/rtools.c	44;"	d	file:
+ISEARCH_OPCODE	ui/rtools.c	37;"	d	file:
+ISEARCH_SRC_ADDR	ui/rtools.c	39;"	d	file:
+ISEARCH_SRC_MODE	ui/rtools.c	41;"	d	file:
+ISEARCH_SRC_REG	ui/rtools.c	43;"	d	file:
+ISEARCH_TYPE	ui/rtools.c	45;"	d	file:
+JTAG430_BLOWFUSE	drivers/goodfet.c	60;"	d	file:
+JTAG430_COREIP_ID	drivers/goodfet.c	63;"	d	file:
+JTAG430_DEVICE_ID	drivers/goodfet.c	64;"	d	file:
+JTAG430_ERASECHECK	drivers/goodfet.c	58;"	d	file:
+JTAG430_ERASEFLASH	drivers/goodfet.c	57;"	d	file:
+JTAG430_ERASEINFO	drivers/goodfet.c	62;"	d	file:
+JTAG430_GETREG	drivers/goodfet.c	53;"	d	file:
+JTAG430_HALTCPU	drivers/goodfet.c	48;"	d	file:
+JTAG430_ISFUSEBLOWN	drivers/goodfet.c	61;"	d	file:
+JTAG430_READMEM	drivers/goodfet.c	56;"	d	file:
+JTAG430_RELEASECPU	drivers/goodfet.c	49;"	d	file:
+JTAG430_SETINSTRFETCH	drivers/goodfet.c	50;"	d	file:
+JTAG430_SETPC	drivers/goodfet.c	51;"	d	file:
+JTAG430_SETREG	drivers/goodfet.c	52;"	d	file:
+JTAG430_VERIFYMEM	drivers/goodfet.c	59;"	d	file:
+JTAG430_WRITEFLASH	drivers/goodfet.c	55;"	d	file:
+JTAG430_WRITEMEM	drivers/goodfet.c	54;"	d	file:
+JTAGLIB_H_	drivers/jtaglib.h	26;"	d
+JTAG_ERASE_MAIN	drivers/jtaglib.h	36;"	d
+JTAG_ERASE_MASS	drivers/jtaglib.h	35;"	d
+JTAG_ERASE_SGMT	drivers/jtaglib.h	37;"	d
+JTAG_ID	drivers/jtaglib.c	33;"	d	file:
+JTDEV_H_	drivers/jtdev.h	21;"	d
+LDFLAGS	Makefile	/^LDFLAGS ?= -s$/;"	m
+LED_GREEN	drivers/jtdev.c	70;"	d	file:
+LED_RED	drivers/jtdev.c	71;"	d	file:
+LE_BYTE	util/util.h	27;"	d
+LE_LONG	util/util.h	29;"	d
+LE_WORD	util/util.h	28;"	d
+LIBDIR	Makefile	/^LIBDIR = ${PREFIX}\/lib\/$/;"	m
+LINEBUF_SIZE	util/output.c	36;"	d	file:
+LINE_BUF_SIZE	ui/input_console.c	33;"	d	file:
+LIST_EMPTY	util/list.h	43;"	d
+LIST_H_	util/list.h	20;"	d
+LITUSE_ALPHA_ADDR	formats/elf_format.h	1971;"	d
+LITUSE_ALPHA_BASE	formats/elf_format.h	1972;"	d
+LITUSE_ALPHA_BYTOFF	formats/elf_format.h	1973;"	d
+LITUSE_ALPHA_JSR	formats/elf_format.h	1974;"	d
+LITUSE_ALPHA_TLS_GD	formats/elf_format.h	1975;"	d
+LITUSE_ALPHA_TLS_LDM	formats/elf_format.h	1976;"	d
+LLFMT	util/util.h	76;"	d
+LLFMT	util/util.h	78;"	d
+LL_DELAY_LOAD	formats/elf_format.h	1712;"	d
+LL_DELTA	formats/elf_format.h	1713;"	d
+LL_EXACT_MATCH	formats/elf_format.h	1708;"	d
+LL_EXPORTS	formats/elf_format.h	1711;"	d
+LL_IGNORE_INT_VER	formats/elf_format.h	1709;"	d
+LL_NONE	formats/elf_format.h	1707;"	d
+LL_REQUIRE_MINOR	formats/elf_format.h	1710;"	d
+LOAD	ui/flatfile.c	/^	LOAD,$/;"	e	enum:operation	file:
+LOAD_PC	drivers/flash_bsl.c	96;"	d	file:
+LOCKED_FLASH_ACCESS	drivers/tilib_defs.h	/^        LOCKED_FLASH_ACCESS = 5,$/;"	e	enum:CONFIG_MODE
+LONG	drivers/tilib_defs.h	/^typedef long LONG;$/;"	t
+LPMX5_MODE	drivers/tilib_defs.h	/^        LPMX5_MODE = 4,$/;"	e	enum:STATE_MODES
+LPMX5_WAKEUP	drivers/tilib_defs.h	/^        LPMX5_WAKEUP = 5$/;"	e	enum:STATE_MODES
+MAC	simio/simio_hwmult.c	30;"	d	file:
+MACS	simio/simio_hwmult.c	31;"	d	file:
+MANDIR	Makefile	/^MANDIR = ${PREFIX}\/share\/man\/man1$/;"	m
+MASS_ERASE	drivers/flash_bsl.c	94;"	d	file:
+MAX_BLOCK	drivers/flash_bsl.c	40;"	d	file:
+MAX_CCRS	simio/simio_timer.c	56;"	d	file:
+MAX_HEIGHT	util/btree.c	28;"	d	file:
+MAX_LEN	drivers/goodfet.c	67;"	d	file:
+MAX_LINE_LENGTH	ui/input_async.c	28;"	d	file:
+MAX_MEM_BLOCK	drivers/goodfet.c	68;"	d	file:
+MAX_PACKET	drivers/flash_bsl.c	43;"	d	file:
+MAX_PHDRS	formats/elf32.c	35;"	d	file:
+MAX_READER_LINE	ui/reader.c	36;"	d	file:
+MAX_SHDRS	formats/elf32.c	36;"	d	file:
+MAX_SYMBOL_LENGTH	util/stab.h	25;"	d
+MC0	simio/simio_timer.c	34;"	d	file:
+MC1	simio/simio_timer.c	33;"	d	file:
+MCLK_CNTRL_MODE	drivers/tilib_defs.h	/^        MCLK_CNTRL_MODE = 3,$/;"	e	enum:CONFIG_MODE
+MEM_GETB	drivers/sim.c	155;"	d	file:
+MEM_GETW	drivers/sim.c	157;"	d	file:
+MEM_IO_END	drivers/sim.c	36;"	d	file:
+MEM_SETB	drivers/sim.c	156;"	d	file:
+MEM_SETW	drivers/sim.c	160;"	d	file:
+MEM_SIZE	drivers/sim.c	35;"	d	file:
+MESSAGE_ID	drivers/tilib_defs.h	/^typedef struct MESSAGE_ID {$/;"	s
+MID_BREAKPOINT	drivers/tilib.c	96;"	d	file:
+MID_CPU_STOPPED	drivers/tilib.c	100;"	d	file:
+MID_HALT_ANY	drivers/tilib.c	102;"	d	file:
+MID_SINGLE_STEP	drivers/tilib.c	95;"	d	file:
+MID_STATE	drivers/tilib.c	98;"	d	file:
+MID_STORAGE	drivers/tilib.c	97;"	d	file:
+MID_WARNING	drivers/tilib.c	99;"	d	file:
+MODIFY_SYMS	ui/reader.h	33;"	d
+MPY	simio/simio_hwmult.c	28;"	d	file:
+MPYS	simio/simio_hwmult.c	29;"	d	file:
+MSP430_AMODE_ABSOLUTE	util/dis.h	/^	MSP430_AMODE_ABSOLUTE           = 0x82,$/;"	e	enum:__anon54
+MSP430_AMODE_IMMEDIATE	util/dis.h	/^	MSP430_AMODE_IMMEDIATE          = 0x83$/;"	e	enum:__anon54
+MSP430_AMODE_INDEXED	util/dis.h	/^	MSP430_AMODE_INDEXED            = 0x1,$/;"	e	enum:__anon54
+MSP430_AMODE_INDIRECT	util/dis.h	/^	MSP430_AMODE_INDIRECT           = 0x2,$/;"	e	enum:__anon54
+MSP430_AMODE_INDIRECT_INC	util/dis.h	/^	MSP430_AMODE_INDIRECT_INC       = 0x3,$/;"	e	enum:__anon54
+MSP430_AMODE_REGISTER	util/dis.h	/^	MSP430_AMODE_REGISTER           = 0x0,$/;"	e	enum:__anon54
+MSP430_AMODE_SYMBOLIC	util/dis.h	/^	MSP430_AMODE_SYMBOLIC           = 0x81,$/;"	e	enum:__anon54
+MSP430_Close	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_Close)(long vccOff);$/;"	m	struct:tilib_device	file:
+MSP430_Configure	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_Configure)(long mode, long value);$/;"	m	struct:tilib_device	file:
+MSP430_DSIZE_AWORD	util/dis.h	/^	MSP430_DSIZE_AWORD   = 3,$/;"	e	enum:__anon57
+MSP430_DSIZE_BYTE	util/dis.h	/^	MSP430_DSIZE_BYTE    = 1,$/;"	e	enum:__anon57
+MSP430_DSIZE_UNKNOWN	util/dis.h	/^	MSP430_DSIZE_UNKNOWN = 2,$/;"	e	enum:__anon57
+MSP430_DSIZE_WORD	util/dis.h	/^	MSP430_DSIZE_WORD    = 0,$/;"	e	enum:__anon57
+MSP430_EEM_Init	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_EEM_Init)(DLL430_EVENTNOTIFY_FUNC callback,$/;"	m	struct:tilib_device	file:
+MSP430_EEM_SetBreakpoint	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_EEM_SetBreakpoint)(uint16_t *pwBpHandle,$/;"	m	struct:tilib_device	file:
+MSP430_Erase	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_Erase)(long type, long address, long length);$/;"	m	struct:tilib_device	file:
+MSP430_Error_Number	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_Error_Number)(void);$/;"	m	struct:tilib_device	file:
+MSP430_Error_String	drivers/tilib.c	/^	const char *TIDLL (*MSP430_Error_String)(long errNumber);$/;"	m	struct:tilib_device	file:
+MSP430_FET_FwUpdate	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_FET_FwUpdate)(char* lpszFileName,$/;"	m	struct:tilib_device	file:
+MSP430_GetFoundDevice	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_GetFoundDevice)(char *FoundDevice,$/;"	m	struct:tilib_device	file:
+MSP430_GetNameOfUsbIf	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_GetNameOfUsbIf)(long idx, char **name,$/;"	m	struct:tilib_device	file:
+MSP430_GetNumberOfUsbIfs	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_GetNumberOfUsbIfs)(long* number);$/;"	m	struct:tilib_device	file:
+MSP430_ITYPE_DOUBLE	util/dis.h	/^	MSP430_ITYPE_DOUBLE,$/;"	e	enum:__anon56
+MSP430_ITYPE_JUMP	util/dis.h	/^	MSP430_ITYPE_JUMP,$/;"	e	enum:__anon56
+MSP430_ITYPE_NOARG	util/dis.h	/^	MSP430_ITYPE_NOARG,$/;"	e	enum:__anon56
+MSP430_ITYPE_SINGLE	util/dis.h	/^	MSP430_ITYPE_SINGLE$/;"	e	enum:__anon56
+MSP430_Initialize	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_Initialize)(char *port, long *version);$/;"	m	struct:tilib_device	file:
+MSP430_MAGIC	formats/coff.c	98;"	d	file:
+MSP430_Memory	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_Memory)(long address, char *buffer,$/;"	m	struct:tilib_device	file:
+MSP430_OP_ADC	util/dis.h	/^	MSP430_OP_ADC           = 0x10000,$/;"	e	enum:__anon58
+MSP430_OP_ADCX	util/dis.h	/^	MSP430_OP_ADCX		= 0x40000,$/;"	e	enum:__anon58
+MSP430_OP_ADD	util/dis.h	/^	MSP430_OP_ADD           = 0x5000,$/;"	e	enum:__anon58
+MSP430_OP_ADDA	util/dis.h	/^	MSP430_OP_ADDA          = 0x00A0,$/;"	e	enum:__anon58
+MSP430_OP_ADDC	util/dis.h	/^	MSP430_OP_ADDC          = 0x6000,$/;"	e	enum:__anon58
+MSP430_OP_ADDCX	util/dis.h	/^	MSP430_OP_ADDCX         = 0x26000,$/;"	e	enum:__anon58
+MSP430_OP_ADDX	util/dis.h	/^	MSP430_OP_ADDX          = 0x25000,$/;"	e	enum:__anon58
+MSP430_OP_AND	util/dis.h	/^	MSP430_OP_AND           = 0xF000,$/;"	e	enum:__anon58
+MSP430_OP_ANDX	util/dis.h	/^	MSP430_OP_ANDX          = 0x2F000,$/;"	e	enum:__anon58
+MSP430_OP_BIC	util/dis.h	/^	MSP430_OP_BIC           = 0xC000,$/;"	e	enum:__anon58
+MSP430_OP_BICX	util/dis.h	/^	MSP430_OP_BICX          = 0x2C000,$/;"	e	enum:__anon58
+MSP430_OP_BIS	util/dis.h	/^	MSP430_OP_BIS           = 0xD000,$/;"	e	enum:__anon58
+MSP430_OP_BISX	util/dis.h	/^	MSP430_OP_BISX          = 0x2D000,$/;"	e	enum:__anon58
+MSP430_OP_BIT	util/dis.h	/^	MSP430_OP_BIT           = 0xB000,$/;"	e	enum:__anon58
+MSP430_OP_BITX	util/dis.h	/^	MSP430_OP_BITX          = 0x2B000,$/;"	e	enum:__anon58
+MSP430_OP_BR	util/dis.h	/^	MSP430_OP_BR            = 0x10001,$/;"	e	enum:__anon58
+MSP430_OP_BRA	util/dis.h	/^	MSP430_OP_BRA		= 0x40001,$/;"	e	enum:__anon58
+MSP430_OP_CALL	util/dis.h	/^	MSP430_OP_CALL          = 0x1280,$/;"	e	enum:__anon58
+MSP430_OP_CALLA	util/dis.h	/^	MSP430_OP_CALLA         = 0x21300,$/;"	e	enum:__anon58
+MSP430_OP_CLR	util/dis.h	/^	MSP430_OP_CLR           = 0x10002,$/;"	e	enum:__anon58
+MSP430_OP_CLRC	util/dis.h	/^	MSP430_OP_CLRC          = 0x10003,$/;"	e	enum:__anon58
+MSP430_OP_CLRN	util/dis.h	/^	MSP430_OP_CLRN          = 0x10004,$/;"	e	enum:__anon58
+MSP430_OP_CLRX	util/dis.h	/^	MSP430_OP_CLRX		= 0x40003,$/;"	e	enum:__anon58
+MSP430_OP_CLRZ	util/dis.h	/^	MSP430_OP_CLRZ          = 0x10005,$/;"	e	enum:__anon58
+MSP430_OP_CMP	util/dis.h	/^	MSP430_OP_CMP           = 0x9000,$/;"	e	enum:__anon58
+MSP430_OP_CMPA	util/dis.h	/^	MSP430_OP_CMPA          = 0x0090,$/;"	e	enum:__anon58
+MSP430_OP_CMPX	util/dis.h	/^	MSP430_OP_CMPX          = 0x29000,$/;"	e	enum:__anon58
+MSP430_OP_DADC	util/dis.h	/^	MSP430_OP_DADC          = 0x10006,$/;"	e	enum:__anon58
+MSP430_OP_DADCX	util/dis.h	/^	MSP430_OP_DADCX         = 0x40004,$/;"	e	enum:__anon58
+MSP430_OP_DADD	util/dis.h	/^	MSP430_OP_DADD          = 0xA000,$/;"	e	enum:__anon58
+MSP430_OP_DADDX	util/dis.h	/^	MSP430_OP_DADDX         = 0x2A000,$/;"	e	enum:__anon58
+MSP430_OP_DEC	util/dis.h	/^	MSP430_OP_DEC           = 0x10007,$/;"	e	enum:__anon58
+MSP430_OP_DECD	util/dis.h	/^	MSP430_OP_DECD          = 0x10008,$/;"	e	enum:__anon58
+MSP430_OP_DECDA	util/dis.h	/^	MSP430_OP_DECDA		= 0x40006,$/;"	e	enum:__anon58
+MSP430_OP_DECDX	util/dis.h	/^	MSP430_OP_DECDX		= 0x40007,$/;"	e	enum:__anon58
+MSP430_OP_DECX	util/dis.h	/^	MSP430_OP_DECX		= 0x40005,$/;"	e	enum:__anon58
+MSP430_OP_DINT	util/dis.h	/^	MSP430_OP_DINT          = 0x10009,$/;"	e	enum:__anon58
+MSP430_OP_EINT	util/dis.h	/^	MSP430_OP_EINT          = 0x1000A,$/;"	e	enum:__anon58
+MSP430_OP_INC	util/dis.h	/^	MSP430_OP_INC           = 0x1000B,$/;"	e	enum:__anon58
+MSP430_OP_INCD	util/dis.h	/^	MSP430_OP_INCD          = 0x1000C,$/;"	e	enum:__anon58
+MSP430_OP_INCDA	util/dis.h	/^	MSP430_OP_INCDA		= 0x40009,$/;"	e	enum:__anon58
+MSP430_OP_INCDX	util/dis.h	/^	MSP430_OP_INCDX		= 0x40011,$/;"	e	enum:__anon58
+MSP430_OP_INCX	util/dis.h	/^	MSP430_OP_INCX		= 0x40008,$/;"	e	enum:__anon58
+MSP430_OP_INV	util/dis.h	/^	MSP430_OP_INV           = 0x1000D,$/;"	e	enum:__anon58
+MSP430_OP_INVX	util/dis.h	/^	MSP430_OP_INVX		= 0x4000A,$/;"	e	enum:__anon58
+MSP430_OP_JC	util/dis.h	/^	MSP430_OP_JC            = 0x2C00,$/;"	e	enum:__anon58
+MSP430_OP_JGE	util/dis.h	/^	MSP430_OP_JGE           = 0x3400,$/;"	e	enum:__anon58
+MSP430_OP_JL	util/dis.h	/^	MSP430_OP_JL            = 0x3800,$/;"	e	enum:__anon58
+MSP430_OP_JMP	util/dis.h	/^	MSP430_OP_JMP           = 0x3C00,$/;"	e	enum:__anon58
+MSP430_OP_JN	util/dis.h	/^	MSP430_OP_JN            = 0x3000,$/;"	e	enum:__anon58
+MSP430_OP_JNC	util/dis.h	/^	MSP430_OP_JNC           = 0x2800,$/;"	e	enum:__anon58
+MSP430_OP_JNZ	util/dis.h	/^	MSP430_OP_JNZ           = 0x2000,$/;"	e	enum:__anon58
+MSP430_OP_JZ	util/dis.h	/^	MSP430_OP_JZ            = 0x2400,$/;"	e	enum:__anon58
+MSP430_OP_MOV	util/dis.h	/^	MSP430_OP_MOV           = 0x4000,$/;"	e	enum:__anon58
+MSP430_OP_MOVA	util/dis.h	/^	MSP430_OP_MOVA          = 0x0000,$/;"	e	enum:__anon58
+MSP430_OP_MOVX	util/dis.h	/^	MSP430_OP_MOVX          = 0x24000,$/;"	e	enum:__anon58
+MSP430_OP_NOP	util/dis.h	/^	MSP430_OP_NOP           = 0x1000E,$/;"	e	enum:__anon58
+MSP430_OP_POP	util/dis.h	/^	MSP430_OP_POP           = 0x1000F,$/;"	e	enum:__anon58
+MSP430_OP_POPM	util/dis.h	/^	MSP430_OP_POPM		= 0x1600,$/;"	e	enum:__anon58
+MSP430_OP_POPX	util/dis.h	/^	MSP430_OP_POPX		= 0x40010,$/;"	e	enum:__anon58
+MSP430_OP_PUSH	util/dis.h	/^	MSP430_OP_PUSH          = 0x1200,$/;"	e	enum:__anon58
+MSP430_OP_PUSHM	util/dis.h	/^	MSP430_OP_PUSHM         = 0x1400,$/;"	e	enum:__anon58
+MSP430_OP_PUSHX	util/dis.h	/^	MSP430_OP_PUSHX         = 0x21200,$/;"	e	enum:__anon58
+MSP430_OP_RET	util/dis.h	/^	MSP430_OP_RET           = 0x10010,$/;"	e	enum:__anon58
+MSP430_OP_RETA	util/dis.h	/^	MSP430_OP_RETA		= 0x40002,$/;"	e	enum:__anon58
+MSP430_OP_RETI	util/dis.h	/^	MSP430_OP_RETI          = 0x1300,$/;"	e	enum:__anon58
+MSP430_OP_RLA	util/dis.h	/^	MSP430_OP_RLA           = 0x10011,$/;"	e	enum:__anon58
+MSP430_OP_RLAM	util/dis.h	/^	MSP430_OP_RLAM		= 0x0240,$/;"	e	enum:__anon58
+MSP430_OP_RLAX	util/dis.h	/^	MSP430_OP_RLAX		= 0x4000B,$/;"	e	enum:__anon58
+MSP430_OP_RLC	util/dis.h	/^	MSP430_OP_RLC           = 0x10012,$/;"	e	enum:__anon58
+MSP430_OP_RLCX	util/dis.h	/^	MSP430_OP_RLCX		= 0x4000C,$/;"	e	enum:__anon58
+MSP430_OP_RRA	util/dis.h	/^	MSP430_OP_RRA           = 0x1100,$/;"	e	enum:__anon58
+MSP430_OP_RRAM	util/dis.h	/^	MSP430_OP_RRAM		= 0x0140,$/;"	e	enum:__anon58
+MSP430_OP_RRAX	util/dis.h	/^	MSP430_OP_RRAX          = 0x21100,$/;"	e	enum:__anon58
+MSP430_OP_RRC	util/dis.h	/^	MSP430_OP_RRC           = 0x1000,$/;"	e	enum:__anon58
+MSP430_OP_RRCM	util/dis.h	/^	MSP430_OP_RRCM		= 0x0040,$/;"	e	enum:__anon58
+MSP430_OP_RRCX	util/dis.h	/^	MSP430_OP_RRCX          = 0x21000,$/;"	e	enum:__anon58
+MSP430_OP_RRUM	util/dis.h	/^	MSP430_OP_RRUM		= 0x0340,$/;"	e	enum:__anon58
+MSP430_OP_RRUX	util/dis.h	/^	MSP430_OP_RRUX          = 0x21001, \/* note: ZC = 1 *\/$/;"	e	enum:__anon58
+MSP430_OP_SBC	util/dis.h	/^	MSP430_OP_SBC           = 0x10013,$/;"	e	enum:__anon58
+MSP430_OP_SECX	util/dis.h	/^	MSP430_OP_SECX		= 0x4000D,$/;"	e	enum:__anon58
+MSP430_OP_SETC	util/dis.h	/^	MSP430_OP_SETC          = 0x10014,$/;"	e	enum:__anon58
+MSP430_OP_SETN	util/dis.h	/^	MSP430_OP_SETN          = 0x10015,$/;"	e	enum:__anon58
+MSP430_OP_SETZ	util/dis.h	/^	MSP430_OP_SETZ          = 0x10016,$/;"	e	enum:__anon58
+MSP430_OP_SUB	util/dis.h	/^	MSP430_OP_SUB           = 0x8000,$/;"	e	enum:__anon58
+MSP430_OP_SUBA	util/dis.h	/^	MSP430_OP_SUBA          = 0x00B0,$/;"	e	enum:__anon58
+MSP430_OP_SUBC	util/dis.h	/^	MSP430_OP_SUBC          = 0x7000,$/;"	e	enum:__anon58
+MSP430_OP_SUBCX	util/dis.h	/^	MSP430_OP_SUBCX         = 0x27000,$/;"	e	enum:__anon58
+MSP430_OP_SUBX	util/dis.h	/^	MSP430_OP_SUBX          = 0x28000,$/;"	e	enum:__anon58
+MSP430_OP_SWPB	util/dis.h	/^	MSP430_OP_SWPB          = 0x1080,$/;"	e	enum:__anon58
+MSP430_OP_SWPBX	util/dis.h	/^	MSP430_OP_SWPBX         = 0x21080,$/;"	e	enum:__anon58
+MSP430_OP_SXT	util/dis.h	/^	MSP430_OP_SXT           = 0x1180,$/;"	e	enum:__anon58
+MSP430_OP_SXTX	util/dis.h	/^	MSP430_OP_SXTX          = 0x21180,$/;"	e	enum:__anon58
+MSP430_OP_TST	util/dis.h	/^	MSP430_OP_TST           = 0x10017,$/;"	e	enum:__anon58
+MSP430_OP_TSTA	util/dis.h	/^	MSP430_OP_TSTA		= 0x4000E,$/;"	e	enum:__anon58
+MSP430_OP_TSTX	util/dis.h	/^	MSP430_OP_TSTX		= 0x4000F,$/;"	e	enum:__anon58
+MSP430_OP_XOR	util/dis.h	/^	MSP430_OP_XOR           = 0xE000,$/;"	e	enum:__anon58
+MSP430_OP_XORX	util/dis.h	/^	MSP430_OP_XORX          = 0x2E000,$/;"	e	enum:__anon58
+MSP430_OpenDevice	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_OpenDevice)(char *Device, char *Password,$/;"	m	struct:tilib_device	file:
+MSP430_REG_PC	util/dis.h	/^	MSP430_REG_PC           = 0,$/;"	e	enum:__anon55
+MSP430_REG_R10	util/dis.h	/^	MSP430_REG_R10          = 10,$/;"	e	enum:__anon55
+MSP430_REG_R11	util/dis.h	/^	MSP430_REG_R11          = 11,$/;"	e	enum:__anon55
+MSP430_REG_R12	util/dis.h	/^	MSP430_REG_R12          = 12,$/;"	e	enum:__anon55
+MSP430_REG_R13	util/dis.h	/^	MSP430_REG_R13          = 13,$/;"	e	enum:__anon55
+MSP430_REG_R14	util/dis.h	/^	MSP430_REG_R14          = 14,$/;"	e	enum:__anon55
+MSP430_REG_R15	util/dis.h	/^	MSP430_REG_R15          = 15,$/;"	e	enum:__anon55
+MSP430_REG_R3	util/dis.h	/^	MSP430_REG_R3           = 3,$/;"	e	enum:__anon55
+MSP430_REG_R4	util/dis.h	/^	MSP430_REG_R4           = 4,$/;"	e	enum:__anon55
+MSP430_REG_R5	util/dis.h	/^	MSP430_REG_R5           = 5,$/;"	e	enum:__anon55
+MSP430_REG_R6	util/dis.h	/^	MSP430_REG_R6           = 6,$/;"	e	enum:__anon55
+MSP430_REG_R7	util/dis.h	/^	MSP430_REG_R7           = 7,$/;"	e	enum:__anon55
+MSP430_REG_R8	util/dis.h	/^	MSP430_REG_R8           = 8,$/;"	e	enum:__anon55
+MSP430_REG_R9	util/dis.h	/^	MSP430_REG_R9           = 9,$/;"	e	enum:__anon55
+MSP430_REG_SP	util/dis.h	/^	MSP430_REG_SP           = 1,$/;"	e	enum:__anon55
+MSP430_REG_SR	util/dis.h	/^	MSP430_REG_SR           = 2,$/;"	e	enum:__anon55
+MSP430_Registers	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_Registers)(long *registers, long mask,$/;"	m	struct:tilib_device	file:
+MSP430_Reset	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_Reset)(long method, long execute,$/;"	m	struct:tilib_device	file:
+MSP430_Run	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_Run)(long mode, long releaseJTAG);$/;"	m	struct:tilib_device	file:
+MSP430_SR_C	util/dis.h	88;"	d
+MSP430_SR_CPUOFF	util/dis.h	84;"	d
+MSP430_SR_GIE	util/dis.h	85;"	d
+MSP430_SR_N	util/dis.h	86;"	d
+MSP430_SR_OSCOFF	util/dis.h	83;"	d
+MSP430_SR_SCG0	util/dis.h	82;"	d
+MSP430_SR_SCG1	util/dis.h	81;"	d
+MSP430_SR_V	util/dis.h	80;"	d
+MSP430_SR_Z	util/dis.h	87;"	d
+MSP430_State	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_State)(long *state, long stop,$/;"	m	struct:tilib_device	file:
+MSP430_VCC	drivers/tilib.c	/^	STATUS_T TIDLL (*MSP430_VCC)(long voltage);$/;"	m	struct:tilib_device	file:
+MSPDEBUG_CC	Makefile	/^    MSPDEBUG_CC = $(CC)$/;"	m
+MSPDEBUG_CC	Makefile	/^    MSPDEBUG_CC = gcc$/;"	m
+MSPDEBUG_CFLAGS	Makefile	/^MSPDEBUG_CFLAGS = $(CFLAGS) $(READLINE_CFLAGS) $(PORTS_CFLAGS)\\$/;"	m
+MSPDEBUG_LDFLAGS	Makefile	/^MSPDEBUG_LDFLAGS = $(LDFLAGS) $(PORTS_LDFLAGS)$/;"	m
+MSPDEBUG_LIBS	Makefile	/^MSPDEBUG_LIBS = -lusb $(READLINE_LIBS) $(OS_LIBS)$/;"	m
+MessageID_t	drivers/tilib_defs.h	/^} MessageID_t;$/;"	t	typeref:struct:MESSAGE_ID
+NMIIE	simio/simio_wdt.c	44;"	d	file:
+NMIIE_MASK	drivers/sim.c	47;"	d	file:
+NMIIFG	simio/simio_wdt.c	48;"	d	file:
+NMIIFG_MASK	drivers/sim.c	50;"	d	file:
+NO_INSTR	drivers/sim.c	77;"	d	file:
+NO_IRQ	drivers/sim.c	78;"	d	file:
+NT_386_IOPERM	formats/elf_format.h	611;"	d
+NT_386_TLS	formats/elf_format.h	610;"	d
+NT_ASRS	formats/elf_format.h	598;"	d
+NT_AUXV	formats/elf_format.h	596;"	d
+NT_FPREGSET	formats/elf_format.h	591;"	d
+NT_GNU_ABI_TAG	formats/elf_format.h	1031;"	d
+NT_GNU_BUILD_ID	formats/elf_format.h	1051;"	d
+NT_GNU_GOLD_VERSION	formats/elf_format.h	1054;"	d
+NT_GNU_HWCAP	formats/elf_format.h	1047;"	d
+NT_GWINDOWS	formats/elf_format.h	597;"	d
+NT_LWPSINFO	formats/elf_format.h	604;"	d
+NT_LWPSTATUS	formats/elf_format.h	603;"	d
+NT_PLATFORM	formats/elf_format.h	595;"	d
+NT_PPC_SPE	formats/elf_format.h	608;"	d
+NT_PPC_VMX	formats/elf_format.h	607;"	d
+NT_PPC_VSX	formats/elf_format.h	609;"	d
+NT_PRCRED	formats/elf_format.h	601;"	d
+NT_PRFPXREG	formats/elf_format.h	605;"	d
+NT_PRPSINFO	formats/elf_format.h	592;"	d
+NT_PRSTATUS	formats/elf_format.h	590;"	d
+NT_PRXFPREG	formats/elf_format.h	606;"	d
+NT_PRXREG	formats/elf_format.h	593;"	d
+NT_PSINFO	formats/elf_format.h	600;"	d
+NT_PSTATUS	formats/elf_format.h	599;"	d
+NT_TASKSTRUCT	formats/elf_format.h	594;"	d
+NT_UTSNAME	formats/elf_format.h	602;"	d
+NT_VERSION	formats/elf_format.h	615;"	d
+N_SYMS	formats/elf32.c	372;"	d	file:
+OBJ	Makefile	/^OBJ=\\$/;"	m
+OBL_CMD_DEV_RESET	drivers/obl.c	/^	OBL_CMD_DEV_RESET	= 0x07,$/;"	e	enum:__anon51	file:
+OBL_CMD_DEV_VERSION	drivers/obl.c	/^	OBL_CMD_DEV_VERSION	= 0x08,$/;"	e	enum:__anon51	file:
+OBL_CMD_PROD_TEST	drivers/obl.c	/^	OBL_CMD_PROD_TEST	= 0x09$/;"	e	enum:__anon51	file:
+OBL_CMD_READ_FLASH	drivers/obl.c	/^	OBL_CMD_READ_FLASH	= 0x03,$/;"	e	enum:__anon51	file:
+OBL_CMD_READ_RAM	drivers/obl.c	/^	OBL_CMD_READ_RAM	= 0x01,$/;"	e	enum:__anon51	file:
+OBL_CMD_RF_SELF_TEST	drivers/obl.c	/^	OBL_CMD_RF_SELF_TEST	= 0x05,$/;"	e	enum:__anon51	file:
+OBL_CMD_SET_PROTECTION	drivers/obl.c	/^	OBL_CMD_SET_PROTECTION	= 0x06,$/;"	e	enum:__anon51	file:
+OBL_CMD_WRITE_FLASH	drivers/obl.c	/^	OBL_CMD_WRITE_FLASH	= 0x04,$/;"	e	enum:__anon51	file:
+OBL_CMD_WRITE_RAM	drivers/obl.c	/^	OBL_CMD_WRITE_RAM	= 0x02,$/;"	e	enum:__anon51	file:
+OBL_H_	drivers/obl.h	20;"	d
+OBL_RESULT_COMMAND_FAULT	drivers/obl.c	/^	OBL_RESULT_COMMAND_FAULT	= 0xff$/;"	e	enum:__anon52	file:
+OBL_RESULT_NRF_LINK_FAULT	drivers/obl.c	/^	OBL_RESULT_NRF_LINK_FAULT	= 0x02,$/;"	e	enum:__anon52	file:
+OBL_RESULT_NRF_SPI_FAULT	drivers/obl.c	/^	OBL_RESULT_NRF_SPI_FAULT	= 0x01,$/;"	e	enum:__anon52	file:
+OBL_RESULT_OK	drivers/obl.c	/^	OBL_RESULT_OK			= 0x00,$/;"	e	enum:__anon52	file:
+ODK_EXCEPTIONS	formats/elf_format.h	1488;"	d
+ODK_FILL	formats/elf_format.h	1491;"	d
+ODK_HWAND	formats/elf_format.h	1493;"	d
+ODK_HWOR	formats/elf_format.h	1494;"	d
+ODK_HWPATCH	formats/elf_format.h	1490;"	d
+ODK_NULL	formats/elf_format.h	1486;"	d
+ODK_PAD	formats/elf_format.h	1489;"	d
+ODK_REGINFO	formats/elf_format.h	1487;"	d
+ODK_TAGS	formats/elf_format.h	1492;"	d
+OEX_DISMISS	formats/elf_format.h	1504;"	d
+OEX_FPDBUG	formats/elf_format.h	1502;"	d
+OEX_FPU_DIV0	formats/elf_format.h	1507;"	d
+OEX_FPU_INEX	formats/elf_format.h	1510;"	d
+OEX_FPU_INVAL	formats/elf_format.h	1506;"	d
+OEX_FPU_MAX	formats/elf_format.h	1499;"	d
+OEX_FPU_MIN	formats/elf_format.h	1498;"	d
+OEX_FPU_OFLO	formats/elf_format.h	1508;"	d
+OEX_FPU_UFLO	formats/elf_format.h	1509;"	d
+OEX_PAGE0	formats/elf_format.h	1500;"	d
+OEX_PRECISEFP	formats/elf_format.h	1503;"	d
+OEX_SMM	formats/elf_format.h	1501;"	d
+OFIE_MASK	drivers/sim.c	45;"	d	file:
+OFIFG_MASK	drivers/sim.c	51;"	d	file:
+OHWA0_R4KEOP_CHECKED	formats/elf_format.h	1533;"	d
+OHWA1_R4KEOP_CLEAN	formats/elf_format.h	1534;"	d
+OHW_R4KEOP	formats/elf_format.h	1514;"	d
+OHW_R5KCVTL	formats/elf_format.h	1517;"	d
+OHW_R5KEOP	formats/elf_format.h	1516;"	d
+OHW_R8KPFETCH	formats/elf_format.h	1515;"	d
+OP2	simio/simio_hwmult.c	32;"	d	file:
+OPAD_POSTFIX	formats/elf_format.h	1520;"	d
+OPAD_PREFIX	formats/elf_format.h	1519;"	d
+OPAD_SYMBOL	formats/elf_format.h	1521;"	d
+OPDB_H_	util/opdb.h	20;"	d
+OPDB_TYPE_BOOLEAN	util/opdb.h	/^	OPDB_TYPE_BOOLEAN,$/;"	e	enum:__anon61
+OPDB_TYPE_NUMERIC	util/opdb.h	/^	OPDB_TYPE_NUMERIC,$/;"	e	enum:__anon61
+OPDB_TYPE_STRING	util/opdb.h	/^	OPDB_TYPE_STRING$/;"	e	enum:__anon61
+OPT_EMBEDDED	ui/main.c	63;"	d	file:
+OPT_HEADER_SIZE	formats/coff.c	39;"	d	file:
+OPT_NO_RC	ui/main.c	62;"	d	file:
+OS_CFLAGS	Makefile	/^	OS_CFLAGS = -D__Windows__$/;"	m
+OS_CFLAGS	Makefile	/^	OS_CFLAGS = -pthread$/;"	m
+OS_LIBS	Makefile	/^	OS_LIBS = -lpthread -ldl$/;"	m
+OS_LIBS	Makefile	/^	OS_LIBS = -lpthread$/;"	m
+OS_LIBS	Makefile	/^	OS_LIBS = -lws2_32 -lregex$/;"	m
+OS_LIBS	Makefile	/^	OS_LIBS =$/;"	m
+OUTMOD0	simio/simio_timer.c	49;"	d	file:
+OUTMOD1	simio/simio_timer.c	48;"	d	file:
+OUTMOD2	simio/simio_timer.c	47;"	d	file:
+OUTPUT_H_	util/output.h	20;"	d
+OUTPUT_UTIL_H_	util/output_util.h	20;"	d
+PAGE_DATA	util/btree.c	51;"	d	file:
+PAGE_KEY	util/btree.c	48;"	d	file:
+PAGE_PTR	util/btree.c	55;"	d	file:
+PE	drivers/jtdev.c	49;"	d	file:
+PF_ARM_ABS	formats/elf_format.h	2281;"	d
+PF_ARM_PI	formats/elf_format.h	2280;"	d
+PF_ARM_SB	formats/elf_format.h	2278;"	d
+PF_HP_CODE	formats/elf_format.h	1905;"	d
+PF_HP_FAR_SHARED	formats/elf_format.h	1903;"	d
+PF_HP_LAZYSWAP	formats/elf_format.h	1907;"	d
+PF_HP_MODIFY	formats/elf_format.h	1906;"	d
+PF_HP_NEAR_SHARED	formats/elf_format.h	1904;"	d
+PF_HP_PAGE_SIZE	formats/elf_format.h	1902;"	d
+PF_HP_SBP	formats/elf_format.h	1908;"	d
+PF_IA_64_NORECOV	formats/elf_format.h	2367;"	d
+PF_MASKOS	formats/elf_format.h	585;"	d
+PF_MASKPROC	formats/elf_format.h	586;"	d
+PF_MIPS_LOCAL	formats/elf_format.h	1601;"	d
+PF_PARISC_SBP	formats/elf_format.h	1900;"	d
+PF_R	formats/elf_format.h	584;"	d
+PF_W	formats/elf_format.h	583;"	d
+PF_X	formats/elf_format.h	582;"	d
+PIF_H_	drivers/pif.h	27;"	d
+PORTS_CFLAGS	Makefile	/^	PORTS_CFLAGS := $(shell pkg-config --cflags libusb)$/;"	m
+PORTS_CFLAGS	Makefile	/^	PORTS_CFLAGS := -I\/opt\/local\/include$/;"	m
+PORTS_CFLAGS	Makefile	/^	PORTS_CFLAGS :=$/;"	m
+PORTS_LDFLAGS	Makefile	/^	PORTS_LDFLAGS := $(shell pkg-config --libs libusb) -ltermcap -pthread$/;"	m
+PORTS_LDFLAGS	Makefile	/^	PORTS_LDFLAGS := -L\/opt\/local\/lib$/;"	m
+PORTS_LDFLAGS	Makefile	/^	PORTS_LDFLAGS :=$/;"	m
+POWER	drivers/jtdev.c	67;"	d	file:
+POWERBUF_DEFAULT_SAMPLES	util/powerbuf.h	48;"	d
+POWERBUF_H_	util/powerbuf.h	20;"	d
+POWERBUF_MAX_SESSIONS	util/powerbuf.h	47;"	d
+POWER_H_	ui/power.h	20;"	d
+PREFIX	Makefile	/^PREFIX ?= \/usr\/local$/;"	m
+PRINT_ADDRESS_EXACT	util/output_util.h	/^	PRINT_ADDRESS_EXACT	= 0x01$/;"	e	enum:__anon59
+PROG_BUFSIZE	util/prog.h	24;"	d
+PROG_H_	util/prog.h	20;"	d
+PROG_VERIFY	util/prog.h	40;"	d
+PROG_WANT_ERASE	util/prog.h	39;"	d
+PTYPE_ACK	drivers/fet_proto.c	117;"	d	file:
+PTYPE_CMD	drivers/fet_proto.c	118;"	d	file:
+PTYPE_DATA	drivers/fet_proto.c	120;"	d	file:
+PTYPE_FLASH_ACK	drivers/fet_proto.c	123;"	d	file:
+PTYPE_MIXED	drivers/fet_proto.c	121;"	d	file:
+PTYPE_NAK	drivers/fet_proto.c	122;"	d	file:
+PTYPE_PARAM	drivers/fet_proto.c	119;"	d	file:
+PT_ARM_EXIDX	formats/elf_format.h	2284;"	d
+PT_DYNAMIC	formats/elf_format.h	561;"	d
+PT_GNU_EH_FRAME	formats/elf_format.h	569;"	d
+PT_GNU_RELRO	formats/elf_format.h	571;"	d
+PT_GNU_STACK	formats/elf_format.h	570;"	d
+PT_HIOS	formats/elf_format.h	576;"	d
+PT_HIPROC	formats/elf_format.h	578;"	d
+PT_HISUNW	formats/elf_format.h	575;"	d
+PT_HP_CORE_COMM	formats/elf_format.h	1883;"	d
+PT_HP_CORE_KERNEL	formats/elf_format.h	1882;"	d
+PT_HP_CORE_LOADABLE	formats/elf_format.h	1885;"	d
+PT_HP_CORE_MMF	formats/elf_format.h	1888;"	d
+PT_HP_CORE_NONE	formats/elf_format.h	1880;"	d
+PT_HP_CORE_PROC	formats/elf_format.h	1884;"	d
+PT_HP_CORE_SHM	formats/elf_format.h	1887;"	d
+PT_HP_CORE_STACK	formats/elf_format.h	1886;"	d
+PT_HP_CORE_VERSION	formats/elf_format.h	1881;"	d
+PT_HP_FASTBIND	formats/elf_format.h	1890;"	d
+PT_HP_HSL_ANNOT	formats/elf_format.h	1892;"	d
+PT_HP_OPT_ANNOT	formats/elf_format.h	1891;"	d
+PT_HP_PARALLEL	formats/elf_format.h	1889;"	d
+PT_HP_STACK	formats/elf_format.h	1893;"	d
+PT_HP_TLS	formats/elf_format.h	1879;"	d
+PT_IA_64_ARCHEXT	formats/elf_format.h	2360;"	d
+PT_IA_64_HP_HSL_ANOT	formats/elf_format.h	2363;"	d
+PT_IA_64_HP_OPT_ANOT	formats/elf_format.h	2362;"	d
+PT_IA_64_HP_STACK	formats/elf_format.h	2364;"	d
+PT_IA_64_UNWIND	formats/elf_format.h	2361;"	d
+PT_INTERP	formats/elf_format.h	562;"	d
+PT_LOAD	formats/elf_format.h	560;"	d
+PT_LOOS	formats/elf_format.h	568;"	d
+PT_LOPROC	formats/elf_format.h	577;"	d
+PT_LOSUNW	formats/elf_format.h	572;"	d
+PT_MIPS_OPTIONS	formats/elf_format.h	1597;"	d
+PT_MIPS_REGINFO	formats/elf_format.h	1595;"	d
+PT_MIPS_RTPROC	formats/elf_format.h	1596;"	d
+PT_NOTE	formats/elf_format.h	563;"	d
+PT_NULL	formats/elf_format.h	559;"	d
+PT_NUM	formats/elf_format.h	567;"	d
+PT_PARISC_ARCHEXT	formats/elf_format.h	1895;"	d
+PT_PARISC_UNWIND	formats/elf_format.h	1896;"	d
+PT_PHDR	formats/elf_format.h	565;"	d
+PT_SHLIB	formats/elf_format.h	564;"	d
+PT_SUNWBSS	formats/elf_format.h	573;"	d
+PT_SUNWSTACK	formats/elf_format.h	574;"	d
+PT_TLS	formats/elf_format.h	566;"	d
+PUC_RESET	drivers/tilib_defs.h	/^	PUC_RESET   = (1 << 0), \/**< Power up clear (i.e., a "soft") reset *\/$/;"	e	enum:RESET_METHOD
+RAM_PRESERVE_MODE	drivers/tilib_defs.h	/^	RAM_PRESERVE_MODE = 10,$/;"	e	enum:CONFIG_MODE
+READ	drivers/tilib_defs.h	/^	READ = 1,$/;"	e	enum:READ_WRITE
+READER_H_	ui/reader.h	20;"	d
+READLINE_CFLAGS	Makefile	/^	READLINE_CFLAGS = -DUSE_READLINE$/;"	m
+READLINE_CFLAGS	Makefile	/^	READLINE_CFLAGS =$/;"	m
+READLINE_LIBS	Makefile	/^	READLINE_LIBS = -lreadline$/;"	m
+READLINE_LIBS	Makefile	/^	READLINE_LIBS =$/;"	m
+READ_BUFFER_SIZE	transport/cdc_acm.c	29;"	d	file:
+READ_TIMEOUT	transport/ti3410.c	136;"	d	file:
+READ_WRITE	drivers/tilib_defs.h	/^enum READ_WRITE {$/;"	g
+REG_DIR	simio/simio_gpio.c	29;"	d	file:
+REG_IE	simio/simio_gpio.c	32;"	d	file:
+REG_IES	simio/simio_gpio.c	31;"	d	file:
+REG_IFG	simio/simio_gpio.c	30;"	d	file:
+REG_IN	simio/simio_gpio.c	27;"	d	file:
+REG_OUT	simio/simio_gpio.c	28;"	d	file:
+REG_REN	simio/simio_gpio.c	34;"	d	file:
+REG_SEL	simio/simio_gpio.c	33;"	d	file:
+REQTYPE_HOST_TO_DEVICE	transport/ftdi.c	42;"	d	file:
+REQ_TIMEOUT_MS	transport/ftdi.c	40;"	d	file:
+RESET	drivers/jtdev.c	68;"	d	file:
+RESET_METHOD	drivers/tilib_defs.h	/^enum RESET_METHOD {$/;"	g
+RESHI	simio/simio_hwmult.c	34;"	d	file:
+RESLO	simio/simio_hwmult.c	33;"	d	file:
+REV_OFFSET	drivers/fet_olimex_db.c	29;"	d	file:
+RF2500_H_	transport/rf2500.h	20;"	d
+RHF_CORD	formats/elf_format.h	1680;"	d
+RHF_DEFAULT_DELAY_LOAD	formats/elf_format.h	1677;"	d
+RHF_DELTA_C_PLUS_PLUS	formats/elf_format.h	1674;"	d
+RHF_GUARANTEE_INIT	formats/elf_format.h	1673;"	d
+RHF_GUARANTEE_START_INIT	formats/elf_format.h	1675;"	d
+RHF_NONE	formats/elf_format.h	1667;"	d
+RHF_NOTPOT	formats/elf_format.h	1669;"	d
+RHF_NO_LIBRARY_REPLACEMENT	formats/elf_format.h	1670;"	d
+RHF_NO_MOVE	formats/elf_format.h	1671;"	d
+RHF_NO_UNRES_UNDEF	formats/elf_format.h	1681;"	d
+RHF_PIXIE	formats/elf_format.h	1676;"	d
+RHF_QUICKSTART	formats/elf_format.h	1668;"	d
+RHF_REQUICKSTART	formats/elf_format.h	1678;"	d
+RHF_REQUICKSTARTED	formats/elf_format.h	1679;"	d
+RHF_RLD_ORDER_SAFE	formats/elf_format.h	1682;"	d
+RHF_SGI_ONLY	formats/elf_format.h	1672;"	d
+RST_RESET	drivers/tilib_defs.h	/^	RST_RESET   = (1 << 1), \/**< RST\/NMI (i.e., "hard") reset *\/$/;"	e	enum:RESET_METHOD
+RTOOLS_H_	ui/rtools.h	20;"	d
+RUNNING	drivers/tilib_defs.h	/^        RUNNING = 1,$/;"	e	enum:STATE_MODES
+RUN_MODES	drivers/tilib_defs.h	/^enum RUN_MODES {$/;"	g
+RUN_TO_BREAKPOINT	drivers/tilib_defs.h	/^        RUN_TO_BREAKPOINT = 3$/;"	e	enum:RUN_MODES
+RX_DATA_BLOCK	drivers/flash_bsl.c	89;"	d	file:
+RX_DATA_BLOCK_FAST	drivers/flash_bsl.c	90;"	d	file:
+RX_PASSWORD	drivers/flash_bsl.c	91;"	d	file:
+R_386_16	formats/elf_format.h	1168;"	d
+R_386_32	formats/elf_format.h	1145;"	d
+R_386_32PLT	formats/elf_format.h	1155;"	d
+R_386_8	formats/elf_format.h	1170;"	d
+R_386_COPY	formats/elf_format.h	1149;"	d
+R_386_GLOB_DAT	formats/elf_format.h	1150;"	d
+R_386_GOT32	formats/elf_format.h	1147;"	d
+R_386_GOTOFF	formats/elf_format.h	1153;"	d
+R_386_GOTPC	formats/elf_format.h	1154;"	d
+R_386_IRELATIVE	formats/elf_format.h	1201;"	d
+R_386_JMP_SLOT	formats/elf_format.h	1151;"	d
+R_386_NONE	formats/elf_format.h	1144;"	d
+R_386_NUM	formats/elf_format.h	1203;"	d
+R_386_PC16	formats/elf_format.h	1169;"	d
+R_386_PC32	formats/elf_format.h	1146;"	d
+R_386_PC8	formats/elf_format.h	1171;"	d
+R_386_PLT32	formats/elf_format.h	1148;"	d
+R_386_RELATIVE	formats/elf_format.h	1152;"	d
+R_386_TLS_DESC	formats/elf_format.h	1197;"	d
+R_386_TLS_DESC_CALL	formats/elf_format.h	1194;"	d
+R_386_TLS_DTPMOD32	formats/elf_format.h	1189;"	d
+R_386_TLS_DTPOFF32	formats/elf_format.h	1190;"	d
+R_386_TLS_GD	formats/elf_format.h	1163;"	d
+R_386_TLS_GD_32	formats/elf_format.h	1172;"	d
+R_386_TLS_GD_CALL	formats/elf_format.h	1175;"	d
+R_386_TLS_GD_POP	formats/elf_format.h	1177;"	d
+R_386_TLS_GD_PUSH	formats/elf_format.h	1174;"	d
+R_386_TLS_GOTDESC	formats/elf_format.h	1193;"	d
+R_386_TLS_GOTIE	formats/elf_format.h	1159;"	d
+R_386_TLS_IE	formats/elf_format.h	1157;"	d
+R_386_TLS_IE_32	formats/elf_format.h	1185;"	d
+R_386_TLS_LDM	formats/elf_format.h	1165;"	d
+R_386_TLS_LDM_32	formats/elf_format.h	1178;"	d
+R_386_TLS_LDM_CALL	formats/elf_format.h	1181;"	d
+R_386_TLS_LDM_POP	formats/elf_format.h	1183;"	d
+R_386_TLS_LDM_PUSH	formats/elf_format.h	1180;"	d
+R_386_TLS_LDO_32	formats/elf_format.h	1184;"	d
+R_386_TLS_LE	formats/elf_format.h	1161;"	d
+R_386_TLS_LE_32	formats/elf_format.h	1187;"	d
+R_386_TLS_TPOFF	formats/elf_format.h	1156;"	d
+R_386_TLS_TPOFF32	formats/elf_format.h	1191;"	d
+R_390_12	formats/elf_format.h	2511;"	d
+R_390_16	formats/elf_format.h	2512;"	d
+R_390_20	formats/elf_format.h	2583;"	d
+R_390_32	formats/elf_format.h	2513;"	d
+R_390_64	formats/elf_format.h	2531;"	d
+R_390_8	formats/elf_format.h	2510;"	d
+R_390_COPY	formats/elf_format.h	2518;"	d
+R_390_GLOB_DAT	formats/elf_format.h	2519;"	d
+R_390_GOT12	formats/elf_format.h	2515;"	d
+R_390_GOT16	formats/elf_format.h	2524;"	d
+R_390_GOT20	formats/elf_format.h	2584;"	d
+R_390_GOT32	formats/elf_format.h	2516;"	d
+R_390_GOT64	formats/elf_format.h	2533;"	d
+R_390_GOTENT	formats/elf_format.h	2535;"	d
+R_390_GOTOFF16	formats/elf_format.h	2536;"	d
+R_390_GOTOFF32	formats/elf_format.h	2522;"	d
+R_390_GOTOFF64	formats/elf_format.h	2537;"	d
+R_390_GOTPC	formats/elf_format.h	2523;"	d
+R_390_GOTPCDBL	formats/elf_format.h	2530;"	d
+R_390_GOTPLT12	formats/elf_format.h	2538;"	d
+R_390_GOTPLT16	formats/elf_format.h	2539;"	d
+R_390_GOTPLT20	formats/elf_format.h	2585;"	d
+R_390_GOTPLT32	formats/elf_format.h	2540;"	d
+R_390_GOTPLT64	formats/elf_format.h	2541;"	d
+R_390_GOTPLTENT	formats/elf_format.h	2542;"	d
+R_390_JMP_SLOT	formats/elf_format.h	2520;"	d
+R_390_NONE	formats/elf_format.h	2509;"	d
+R_390_NUM	formats/elf_format.h	2589;"	d
+R_390_PC16	formats/elf_format.h	2525;"	d
+R_390_PC16DBL	formats/elf_format.h	2526;"	d
+R_390_PC32	formats/elf_format.h	2514;"	d
+R_390_PC32DBL	formats/elf_format.h	2528;"	d
+R_390_PC64	formats/elf_format.h	2532;"	d
+R_390_PLT16DBL	formats/elf_format.h	2527;"	d
+R_390_PLT32	formats/elf_format.h	2517;"	d
+R_390_PLT32DBL	formats/elf_format.h	2529;"	d
+R_390_PLT64	formats/elf_format.h	2534;"	d
+R_390_PLTOFF16	formats/elf_format.h	2543;"	d
+R_390_PLTOFF32	formats/elf_format.h	2544;"	d
+R_390_PLTOFF64	formats/elf_format.h	2545;"	d
+R_390_RELATIVE	formats/elf_format.h	2521;"	d
+R_390_TLS_DTPMOD	formats/elf_format.h	2579;"	d
+R_390_TLS_DTPOFF	formats/elf_format.h	2580;"	d
+R_390_TLS_GD32	formats/elf_format.h	2551;"	d
+R_390_TLS_GD64	formats/elf_format.h	2553;"	d
+R_390_TLS_GDCALL	formats/elf_format.h	2547;"	d
+R_390_TLS_GOTIE12	formats/elf_format.h	2555;"	d
+R_390_TLS_GOTIE20	formats/elf_format.h	2586;"	d
+R_390_TLS_GOTIE32	formats/elf_format.h	2557;"	d
+R_390_TLS_GOTIE64	formats/elf_format.h	2559;"	d
+R_390_TLS_IE32	formats/elf_format.h	2565;"	d
+R_390_TLS_IE64	formats/elf_format.h	2567;"	d
+R_390_TLS_IEENT	formats/elf_format.h	2569;"	d
+R_390_TLS_LDCALL	formats/elf_format.h	2549;"	d
+R_390_TLS_LDM32	formats/elf_format.h	2561;"	d
+R_390_TLS_LDM64	formats/elf_format.h	2563;"	d
+R_390_TLS_LDO32	formats/elf_format.h	2575;"	d
+R_390_TLS_LDO64	formats/elf_format.h	2577;"	d
+R_390_TLS_LE32	formats/elf_format.h	2571;"	d
+R_390_TLS_LE64	formats/elf_format.h	2573;"	d
+R_390_TLS_LOAD	formats/elf_format.h	2546;"	d
+R_390_TLS_TPOFF	formats/elf_format.h	2581;"	d
+R_68K_16	formats/elf_format.h	1095;"	d
+R_68K_32	formats/elf_format.h	1094;"	d
+R_68K_8	formats/elf_format.h	1096;"	d
+R_68K_COPY	formats/elf_format.h	1112;"	d
+R_68K_GLOB_DAT	formats/elf_format.h	1113;"	d
+R_68K_GOT16	formats/elf_format.h	1101;"	d
+R_68K_GOT16O	formats/elf_format.h	1104;"	d
+R_68K_GOT32	formats/elf_format.h	1100;"	d
+R_68K_GOT32O	formats/elf_format.h	1103;"	d
+R_68K_GOT8	formats/elf_format.h	1102;"	d
+R_68K_GOT8O	formats/elf_format.h	1105;"	d
+R_68K_JMP_SLOT	formats/elf_format.h	1114;"	d
+R_68K_NONE	formats/elf_format.h	1093;"	d
+R_68K_NUM	formats/elf_format.h	1138;"	d
+R_68K_PC16	formats/elf_format.h	1098;"	d
+R_68K_PC32	formats/elf_format.h	1097;"	d
+R_68K_PC8	formats/elf_format.h	1099;"	d
+R_68K_PLT16	formats/elf_format.h	1107;"	d
+R_68K_PLT16O	formats/elf_format.h	1110;"	d
+R_68K_PLT32	formats/elf_format.h	1106;"	d
+R_68K_PLT32O	formats/elf_format.h	1109;"	d
+R_68K_PLT8	formats/elf_format.h	1108;"	d
+R_68K_PLT8O	formats/elf_format.h	1111;"	d
+R_68K_RELATIVE	formats/elf_format.h	1115;"	d
+R_68K_TLS_DTPMOD32	formats/elf_format.h	1134;"	d
+R_68K_TLS_DTPREL32	formats/elf_format.h	1135;"	d
+R_68K_TLS_GD16	formats/elf_format.h	1117;"	d
+R_68K_TLS_GD32	formats/elf_format.h	1116;"	d
+R_68K_TLS_GD8	formats/elf_format.h	1118;"	d
+R_68K_TLS_IE16	formats/elf_format.h	1126;"	d
+R_68K_TLS_IE32	formats/elf_format.h	1125;"	d
+R_68K_TLS_IE8	formats/elf_format.h	1127;"	d
+R_68K_TLS_LDM16	formats/elf_format.h	1120;"	d
+R_68K_TLS_LDM32	formats/elf_format.h	1119;"	d
+R_68K_TLS_LDM8	formats/elf_format.h	1121;"	d
+R_68K_TLS_LDO16	formats/elf_format.h	1123;"	d
+R_68K_TLS_LDO32	formats/elf_format.h	1122;"	d
+R_68K_TLS_LDO8	formats/elf_format.h	1124;"	d
+R_68K_TLS_LE16	formats/elf_format.h	1130;"	d
+R_68K_TLS_LE32	formats/elf_format.h	1128;"	d
+R_68K_TLS_LE8	formats/elf_format.h	1132;"	d
+R_68K_TLS_TPREL32	formats/elf_format.h	1136;"	d
+R_ALPHA_BRADDR	formats/elf_format.h	1941;"	d
+R_ALPHA_COPY	formats/elf_format.h	1949;"	d
+R_ALPHA_DTPMOD64	formats/elf_format.h	1956;"	d
+R_ALPHA_DTPREL16	formats/elf_format.h	1961;"	d
+R_ALPHA_DTPREL64	formats/elf_format.h	1958;"	d
+R_ALPHA_DTPRELHI	formats/elf_format.h	1959;"	d
+R_ALPHA_DTPRELLO	formats/elf_format.h	1960;"	d
+R_ALPHA_GLOB_DAT	formats/elf_format.h	1950;"	d
+R_ALPHA_GOTDTPREL	formats/elf_format.h	1957;"	d
+R_ALPHA_GOTTPREL	formats/elf_format.h	1962;"	d
+R_ALPHA_GPDISP	formats/elf_format.h	1940;"	d
+R_ALPHA_GPREL16	formats/elf_format.h	1948;"	d
+R_ALPHA_GPREL32	formats/elf_format.h	1937;"	d
+R_ALPHA_GPRELHIGH	formats/elf_format.h	1946;"	d
+R_ALPHA_GPRELLOW	formats/elf_format.h	1947;"	d
+R_ALPHA_HINT	formats/elf_format.h	1942;"	d
+R_ALPHA_JMP_SLOT	formats/elf_format.h	1951;"	d
+R_ALPHA_LITERAL	formats/elf_format.h	1938;"	d
+R_ALPHA_LITUSE	formats/elf_format.h	1939;"	d
+R_ALPHA_NONE	formats/elf_format.h	1934;"	d
+R_ALPHA_NUM	formats/elf_format.h	1968;"	d
+R_ALPHA_REFLONG	formats/elf_format.h	1935;"	d
+R_ALPHA_REFQUAD	formats/elf_format.h	1936;"	d
+R_ALPHA_RELATIVE	formats/elf_format.h	1952;"	d
+R_ALPHA_SREL16	formats/elf_format.h	1943;"	d
+R_ALPHA_SREL32	formats/elf_format.h	1944;"	d
+R_ALPHA_SREL64	formats/elf_format.h	1945;"	d
+R_ALPHA_TLSGD	formats/elf_format.h	1954;"	d
+R_ALPHA_TLS_GD_HI	formats/elf_format.h	1953;"	d
+R_ALPHA_TLS_LDM	formats/elf_format.h	1955;"	d
+R_ALPHA_TPREL16	formats/elf_format.h	1966;"	d
+R_ALPHA_TPREL64	formats/elf_format.h	1963;"	d
+R_ALPHA_TPRELHI	formats/elf_format.h	1964;"	d
+R_ALPHA_TPRELLO	formats/elf_format.h	1965;"	d
+R_ARM_ABS12	formats/elf_format.h	2300;"	d
+R_ARM_ABS16	formats/elf_format.h	2299;"	d
+R_ARM_ABS32	formats/elf_format.h	2296;"	d
+R_ARM_ABS8	formats/elf_format.h	2302;"	d
+R_ARM_ALU_PCREL_15_8	formats/elf_format.h	2323;"	d
+R_ARM_ALU_PCREL_23_15	formats/elf_format.h	2324;"	d
+R_ARM_ALU_PCREL_7_0	formats/elf_format.h	2322;"	d
+R_ARM_ALU_SBREL_19_12	formats/elf_format.h	2326;"	d
+R_ARM_ALU_SBREL_27_20	formats/elf_format.h	2327;"	d
+R_ARM_AMP_VCALL9	formats/elf_format.h	2306;"	d
+R_ARM_COPY	formats/elf_format.h	2314;"	d
+R_ARM_GLOB_DAT	formats/elf_format.h	2315;"	d
+R_ARM_GNU_VTENTRY	formats/elf_format.h	2328;"	d
+R_ARM_GNU_VTINHERIT	formats/elf_format.h	2329;"	d
+R_ARM_GOT32	formats/elf_format.h	2320;"	d
+R_ARM_GOTOFF	formats/elf_format.h	2318;"	d
+R_ARM_GOTPC	formats/elf_format.h	2319;"	d
+R_ARM_JUMP_SLOT	formats/elf_format.h	2316;"	d
+R_ARM_LDR_SBREL_11_0	formats/elf_format.h	2325;"	d
+R_ARM_NONE	formats/elf_format.h	2294;"	d
+R_ARM_NUM	formats/elf_format.h	2350;"	d
+R_ARM_PC13	formats/elf_format.h	2298;"	d
+R_ARM_PC24	formats/elf_format.h	2295;"	d
+R_ARM_PLT32	formats/elf_format.h	2321;"	d
+R_ARM_RABS22	formats/elf_format.h	2346;"	d
+R_ARM_RBASE	formats/elf_format.h	2348;"	d
+R_ARM_REL32	formats/elf_format.h	2297;"	d
+R_ARM_RELATIVE	formats/elf_format.h	2317;"	d
+R_ARM_RPC24	formats/elf_format.h	2347;"	d
+R_ARM_RREL32	formats/elf_format.h	2345;"	d
+R_ARM_RSBREL32	formats/elf_format.h	2343;"	d
+R_ARM_RXPC25	formats/elf_format.h	2342;"	d
+R_ARM_SBREL32	formats/elf_format.h	2303;"	d
+R_ARM_SWI24	formats/elf_format.h	2307;"	d
+R_ARM_THM_ABS5	formats/elf_format.h	2301;"	d
+R_ARM_THM_PC11	formats/elf_format.h	2330;"	d
+R_ARM_THM_PC22	formats/elf_format.h	2304;"	d
+R_ARM_THM_PC8	formats/elf_format.h	2305;"	d
+R_ARM_THM_PC9	formats/elf_format.h	2331;"	d
+R_ARM_THM_RPC22	formats/elf_format.h	2344;"	d
+R_ARM_THM_SWI8	formats/elf_format.h	2308;"	d
+R_ARM_THM_XPC22	formats/elf_format.h	2310;"	d
+R_ARM_TLS_DTPMOD32	formats/elf_format.h	2311;"	d
+R_ARM_TLS_DTPOFF32	formats/elf_format.h	2312;"	d
+R_ARM_TLS_GD32	formats/elf_format.h	2332;"	d
+R_ARM_TLS_IE32	formats/elf_format.h	2338;"	d
+R_ARM_TLS_LDM32	formats/elf_format.h	2334;"	d
+R_ARM_TLS_LDO32	formats/elf_format.h	2336;"	d
+R_ARM_TLS_LE32	formats/elf_format.h	2340;"	d
+R_ARM_TLS_TPOFF32	formats/elf_format.h	2313;"	d
+R_ARM_XPC25	formats/elf_format.h	2309;"	d
+R_CRIS_16	formats/elf_format.h	2595;"	d
+R_CRIS_16_GOT	formats/elf_format.h	2606;"	d
+R_CRIS_16_GOTPLT	formats/elf_format.h	2608;"	d
+R_CRIS_16_PCREL	formats/elf_format.h	2598;"	d
+R_CRIS_32	formats/elf_format.h	2596;"	d
+R_CRIS_32_GOT	formats/elf_format.h	2607;"	d
+R_CRIS_32_GOTPLT	formats/elf_format.h	2609;"	d
+R_CRIS_32_GOTREL	formats/elf_format.h	2610;"	d
+R_CRIS_32_PCREL	formats/elf_format.h	2599;"	d
+R_CRIS_32_PLT_GOTREL	formats/elf_format.h	2611;"	d
+R_CRIS_32_PLT_PCREL	formats/elf_format.h	2612;"	d
+R_CRIS_8	formats/elf_format.h	2594;"	d
+R_CRIS_8_PCREL	formats/elf_format.h	2597;"	d
+R_CRIS_COPY	formats/elf_format.h	2602;"	d
+R_CRIS_GLOB_DAT	formats/elf_format.h	2603;"	d
+R_CRIS_GNU_VTENTRY	formats/elf_format.h	2601;"	d
+R_CRIS_GNU_VTINHERIT	formats/elf_format.h	2600;"	d
+R_CRIS_JUMP_SLOT	formats/elf_format.h	2604;"	d
+R_CRIS_NONE	formats/elf_format.h	2593;"	d
+R_CRIS_NUM	formats/elf_format.h	2614;"	d
+R_CRIS_RELATIVE	formats/elf_format.h	2605;"	d
+R_IA64_COPY	formats/elf_format.h	2442;"	d
+R_IA64_DIR32LSB	formats/elf_format.h	2387;"	d
+R_IA64_DIR32MSB	formats/elf_format.h	2386;"	d
+R_IA64_DIR64LSB	formats/elf_format.h	2389;"	d
+R_IA64_DIR64MSB	formats/elf_format.h	2388;"	d
+R_IA64_DTPMOD64LSB	formats/elf_format.h	2453;"	d
+R_IA64_DTPMOD64MSB	formats/elf_format.h	2452;"	d
+R_IA64_DTPREL14	formats/elf_format.h	2455;"	d
+R_IA64_DTPREL22	formats/elf_format.h	2456;"	d
+R_IA64_DTPREL32LSB	formats/elf_format.h	2459;"	d
+R_IA64_DTPREL32MSB	formats/elf_format.h	2458;"	d
+R_IA64_DTPREL64I	formats/elf_format.h	2457;"	d
+R_IA64_DTPREL64LSB	formats/elf_format.h	2461;"	d
+R_IA64_DTPREL64MSB	formats/elf_format.h	2460;"	d
+R_IA64_FPTR32LSB	formats/elf_format.h	2404;"	d
+R_IA64_FPTR32MSB	formats/elf_format.h	2403;"	d
+R_IA64_FPTR64I	formats/elf_format.h	2402;"	d
+R_IA64_FPTR64LSB	formats/elf_format.h	2406;"	d
+R_IA64_FPTR64MSB	formats/elf_format.h	2405;"	d
+R_IA64_GPREL22	formats/elf_format.h	2390;"	d
+R_IA64_GPREL32LSB	formats/elf_format.h	2393;"	d
+R_IA64_GPREL32MSB	formats/elf_format.h	2392;"	d
+R_IA64_GPREL64I	formats/elf_format.h	2391;"	d
+R_IA64_GPREL64LSB	formats/elf_format.h	2395;"	d
+R_IA64_GPREL64MSB	formats/elf_format.h	2394;"	d
+R_IA64_IMM14	formats/elf_format.h	2383;"	d
+R_IA64_IMM22	formats/elf_format.h	2384;"	d
+R_IA64_IMM64	formats/elf_format.h	2385;"	d
+R_IA64_IPLTLSB	formats/elf_format.h	2441;"	d
+R_IA64_IPLTMSB	formats/elf_format.h	2440;"	d
+R_IA64_LDXMOV	formats/elf_format.h	2445;"	d
+R_IA64_LTOFF22	formats/elf_format.h	2396;"	d
+R_IA64_LTOFF22X	formats/elf_format.h	2444;"	d
+R_IA64_LTOFF64I	formats/elf_format.h	2397;"	d
+R_IA64_LTOFF_DTPMOD22	formats/elf_format.h	2454;"	d
+R_IA64_LTOFF_DTPREL22	formats/elf_format.h	2462;"	d
+R_IA64_LTOFF_FPTR22	formats/elf_format.h	2415;"	d
+R_IA64_LTOFF_FPTR32LSB	formats/elf_format.h	2418;"	d
+R_IA64_LTOFF_FPTR32MSB	formats/elf_format.h	2417;"	d
+R_IA64_LTOFF_FPTR64I	formats/elf_format.h	2416;"	d
+R_IA64_LTOFF_FPTR64LSB	formats/elf_format.h	2420;"	d
+R_IA64_LTOFF_FPTR64MSB	formats/elf_format.h	2419;"	d
+R_IA64_LTOFF_TPREL22	formats/elf_format.h	2451;"	d
+R_IA64_LTV32LSB	formats/elf_format.h	2434;"	d
+R_IA64_LTV32MSB	formats/elf_format.h	2433;"	d
+R_IA64_LTV64LSB	formats/elf_format.h	2436;"	d
+R_IA64_LTV64MSB	formats/elf_format.h	2435;"	d
+R_IA64_NONE	formats/elf_format.h	2382;"	d
+R_IA64_PCREL21B	formats/elf_format.h	2408;"	d
+R_IA64_PCREL21BI	formats/elf_format.h	2437;"	d
+R_IA64_PCREL21F	formats/elf_format.h	2410;"	d
+R_IA64_PCREL21M	formats/elf_format.h	2409;"	d
+R_IA64_PCREL22	formats/elf_format.h	2438;"	d
+R_IA64_PCREL32LSB	formats/elf_format.h	2412;"	d
+R_IA64_PCREL32MSB	formats/elf_format.h	2411;"	d
+R_IA64_PCREL60B	formats/elf_format.h	2407;"	d
+R_IA64_PCREL64I	formats/elf_format.h	2439;"	d
+R_IA64_PCREL64LSB	formats/elf_format.h	2414;"	d
+R_IA64_PCREL64MSB	formats/elf_format.h	2413;"	d
+R_IA64_PLTOFF22	formats/elf_format.h	2398;"	d
+R_IA64_PLTOFF64I	formats/elf_format.h	2399;"	d
+R_IA64_PLTOFF64LSB	formats/elf_format.h	2401;"	d
+R_IA64_PLTOFF64MSB	formats/elf_format.h	2400;"	d
+R_IA64_REL32LSB	formats/elf_format.h	2430;"	d
+R_IA64_REL32MSB	formats/elf_format.h	2429;"	d
+R_IA64_REL64LSB	formats/elf_format.h	2432;"	d
+R_IA64_REL64MSB	formats/elf_format.h	2431;"	d
+R_IA64_SECREL32LSB	formats/elf_format.h	2426;"	d
+R_IA64_SECREL32MSB	formats/elf_format.h	2425;"	d
+R_IA64_SECREL64LSB	formats/elf_format.h	2428;"	d
+R_IA64_SECREL64MSB	formats/elf_format.h	2427;"	d
+R_IA64_SEGREL32LSB	formats/elf_format.h	2422;"	d
+R_IA64_SEGREL32MSB	formats/elf_format.h	2421;"	d
+R_IA64_SEGREL64LSB	formats/elf_format.h	2424;"	d
+R_IA64_SEGREL64MSB	formats/elf_format.h	2423;"	d
+R_IA64_SUB	formats/elf_format.h	2443;"	d
+R_IA64_TPREL14	formats/elf_format.h	2446;"	d
+R_IA64_TPREL22	formats/elf_format.h	2447;"	d
+R_IA64_TPREL64I	formats/elf_format.h	2448;"	d
+R_IA64_TPREL64LSB	formats/elf_format.h	2450;"	d
+R_IA64_TPREL64MSB	formats/elf_format.h	2449;"	d
+R_M32R_10_PCREL	formats/elf_format.h	2694;"	d
+R_M32R_10_PCREL_RELA	formats/elf_format.h	2707;"	d
+R_M32R_16	formats/elf_format.h	2691;"	d
+R_M32R_16_RELA	formats/elf_format.h	2704;"	d
+R_M32R_18_PCREL	formats/elf_format.h	2695;"	d
+R_M32R_18_PCREL_RELA	formats/elf_format.h	2708;"	d
+R_M32R_24	formats/elf_format.h	2693;"	d
+R_M32R_24_RELA	formats/elf_format.h	2706;"	d
+R_M32R_26_PCREL	formats/elf_format.h	2696;"	d
+R_M32R_26_PCREL_RELA	formats/elf_format.h	2709;"	d
+R_M32R_26_PLTREL	formats/elf_format.h	2719;"	d
+R_M32R_32	formats/elf_format.h	2692;"	d
+R_M32R_32_RELA	formats/elf_format.h	2705;"	d
+R_M32R_COPY	formats/elf_format.h	2720;"	d
+R_M32R_GLOB_DAT	formats/elf_format.h	2721;"	d
+R_M32R_GNU_VTENTRY	formats/elf_format.h	2702;"	d
+R_M32R_GNU_VTINHERIT	formats/elf_format.h	2701;"	d
+R_M32R_GOT16_HI_SLO	formats/elf_format.h	2728;"	d
+R_M32R_GOT16_HI_ULO	formats/elf_format.h	2726;"	d
+R_M32R_GOT16_LO	formats/elf_format.h	2730;"	d
+R_M32R_GOT24	formats/elf_format.h	2718;"	d
+R_M32R_GOTOFF	formats/elf_format.h	2724;"	d
+R_M32R_GOTOFF_HI_SLO	formats/elf_format.h	2739;"	d
+R_M32R_GOTOFF_HI_ULO	formats/elf_format.h	2737;"	d
+R_M32R_GOTOFF_LO	formats/elf_format.h	2741;"	d
+R_M32R_GOTPC24	formats/elf_format.h	2725;"	d
+R_M32R_GOTPC_HI_SLO	formats/elf_format.h	2733;"	d
+R_M32R_GOTPC_HI_ULO	formats/elf_format.h	2731;"	d
+R_M32R_GOTPC_LO	formats/elf_format.h	2735;"	d
+R_M32R_HI16_SLO	formats/elf_format.h	2698;"	d
+R_M32R_HI16_SLO_RELA	formats/elf_format.h	2711;"	d
+R_M32R_HI16_ULO	formats/elf_format.h	2697;"	d
+R_M32R_HI16_ULO_RELA	formats/elf_format.h	2710;"	d
+R_M32R_JMP_SLOT	formats/elf_format.h	2722;"	d
+R_M32R_LO16	formats/elf_format.h	2699;"	d
+R_M32R_LO16_RELA	formats/elf_format.h	2712;"	d
+R_M32R_NONE	formats/elf_format.h	2690;"	d
+R_M32R_NUM	formats/elf_format.h	2742;"	d
+R_M32R_REL32	formats/elf_format.h	2716;"	d
+R_M32R_RELATIVE	formats/elf_format.h	2723;"	d
+R_M32R_RELA_GNU_VTENTRY	formats/elf_format.h	2715;"	d
+R_M32R_RELA_GNU_VTINHERIT	formats/elf_format.h	2714;"	d
+R_M32R_SDA16	formats/elf_format.h	2700;"	d
+R_M32R_SDA16_RELA	formats/elf_format.h	2713;"	d
+R_MIPS_16	formats/elf_format.h	1539;"	d
+R_MIPS_26	formats/elf_format.h	1542;"	d
+R_MIPS_32	formats/elf_format.h	1540;"	d
+R_MIPS_64	formats/elf_format.h	1554;"	d
+R_MIPS_ADD_IMMEDIATE	formats/elf_format.h	1570;"	d
+R_MIPS_CALL16	formats/elf_format.h	1549;"	d
+R_MIPS_CALL_HI16	formats/elf_format.h	1566;"	d
+R_MIPS_CALL_LO16	formats/elf_format.h	1567;"	d
+R_MIPS_COPY	formats/elf_format.h	1588;"	d
+R_MIPS_DELETE	formats/elf_format.h	1563;"	d
+R_MIPS_GLOB_DAT	formats/elf_format.h	1587;"	d
+R_MIPS_GOT16	formats/elf_format.h	1547;"	d
+R_MIPS_GOT_DISP	formats/elf_format.h	1555;"	d
+R_MIPS_GOT_HI16	formats/elf_format.h	1558;"	d
+R_MIPS_GOT_LO16	formats/elf_format.h	1559;"	d
+R_MIPS_GOT_OFST	formats/elf_format.h	1557;"	d
+R_MIPS_GOT_PAGE	formats/elf_format.h	1556;"	d
+R_MIPS_GPREL16	formats/elf_format.h	1545;"	d
+R_MIPS_GPREL32	formats/elf_format.h	1550;"	d
+R_MIPS_HI16	formats/elf_format.h	1543;"	d
+R_MIPS_HIGHER	formats/elf_format.h	1564;"	d
+R_MIPS_HIGHEST	formats/elf_format.h	1565;"	d
+R_MIPS_INSERT_A	formats/elf_format.h	1561;"	d
+R_MIPS_INSERT_B	formats/elf_format.h	1562;"	d
+R_MIPS_JALR	formats/elf_format.h	1573;"	d
+R_MIPS_JUMP_SLOT	formats/elf_format.h	1589;"	d
+R_MIPS_LITERAL	formats/elf_format.h	1546;"	d
+R_MIPS_LO16	formats/elf_format.h	1544;"	d
+R_MIPS_NONE	formats/elf_format.h	1538;"	d
+R_MIPS_NUM	formats/elf_format.h	1591;"	d
+R_MIPS_PC16	formats/elf_format.h	1548;"	d
+R_MIPS_PJUMP	formats/elf_format.h	1571;"	d
+R_MIPS_REL16	formats/elf_format.h	1569;"	d
+R_MIPS_REL32	formats/elf_format.h	1541;"	d
+R_MIPS_RELGOT	formats/elf_format.h	1572;"	d
+R_MIPS_SCN_DISP	formats/elf_format.h	1568;"	d
+R_MIPS_SHIFT5	formats/elf_format.h	1552;"	d
+R_MIPS_SHIFT6	formats/elf_format.h	1553;"	d
+R_MIPS_SUB	formats/elf_format.h	1560;"	d
+R_MIPS_TLS_DTPMOD32	formats/elf_format.h	1574;"	d
+R_MIPS_TLS_DTPMOD64	formats/elf_format.h	1576;"	d
+R_MIPS_TLS_DTPREL32	formats/elf_format.h	1575;"	d
+R_MIPS_TLS_DTPREL64	formats/elf_format.h	1577;"	d
+R_MIPS_TLS_DTPREL_HI16	formats/elf_format.h	1580;"	d
+R_MIPS_TLS_DTPREL_LO16	formats/elf_format.h	1581;"	d
+R_MIPS_TLS_GD	formats/elf_format.h	1578;"	d
+R_MIPS_TLS_GOTTPREL	formats/elf_format.h	1582;"	d
+R_MIPS_TLS_LDM	formats/elf_format.h	1579;"	d
+R_MIPS_TLS_TPREL32	formats/elf_format.h	1583;"	d
+R_MIPS_TLS_TPREL64	formats/elf_format.h	1584;"	d
+R_MIPS_TLS_TPREL_HI16	formats/elf_format.h	1585;"	d
+R_MIPS_TLS_TPREL_LO16	formats/elf_format.h	1586;"	d
+R_MN10300_16	formats/elf_format.h	2663;"	d
+R_MN10300_24	formats/elf_format.h	2670;"	d
+R_MN10300_32	formats/elf_format.h	2662;"	d
+R_MN10300_8	formats/elf_format.h	2664;"	d
+R_MN10300_COPY	formats/elf_format.h	2681;"	d
+R_MN10300_GLOB_DAT	formats/elf_format.h	2682;"	d
+R_MN10300_GNU_VTENTRY	formats/elf_format.h	2669;"	d
+R_MN10300_GNU_VTINHERIT	formats/elf_format.h	2668;"	d
+R_MN10300_GOT16	formats/elf_format.h	2680;"	d
+R_MN10300_GOT24	formats/elf_format.h	2679;"	d
+R_MN10300_GOT32	formats/elf_format.h	2678;"	d
+R_MN10300_GOTOFF16	formats/elf_format.h	2675;"	d
+R_MN10300_GOTOFF24	formats/elf_format.h	2674;"	d
+R_MN10300_GOTOFF32	formats/elf_format.h	2673;"	d
+R_MN10300_GOTPC16	formats/elf_format.h	2672;"	d
+R_MN10300_GOTPC32	formats/elf_format.h	2671;"	d
+R_MN10300_JMP_SLOT	formats/elf_format.h	2683;"	d
+R_MN10300_NONE	formats/elf_format.h	2661;"	d
+R_MN10300_NUM	formats/elf_format.h	2686;"	d
+R_MN10300_PCREL16	formats/elf_format.h	2666;"	d
+R_MN10300_PCREL32	formats/elf_format.h	2665;"	d
+R_MN10300_PCREL8	formats/elf_format.h	2667;"	d
+R_MN10300_PLT16	formats/elf_format.h	2677;"	d
+R_MN10300_PLT32	formats/elf_format.h	2676;"	d
+R_MN10300_RELATIVE	formats/elf_format.h	2684;"	d
+R_PARISC_COPY	formats/elf_format.h	1834;"	d
+R_PARISC_DIR14DR	formats/elf_format.h	1804;"	d
+R_PARISC_DIR14R	formats/elf_format.h	1771;"	d
+R_PARISC_DIR14WR	formats/elf_format.h	1803;"	d
+R_PARISC_DIR16DF	formats/elf_format.h	1807;"	d
+R_PARISC_DIR16F	formats/elf_format.h	1805;"	d
+R_PARISC_DIR16WF	formats/elf_format.h	1806;"	d
+R_PARISC_DIR17F	formats/elf_format.h	1770;"	d
+R_PARISC_DIR17R	formats/elf_format.h	1769;"	d
+R_PARISC_DIR21L	formats/elf_format.h	1768;"	d
+R_PARISC_DIR32	formats/elf_format.h	1767;"	d
+R_PARISC_DIR64	formats/elf_format.h	1802;"	d
+R_PARISC_DPREL14R	formats/elf_format.h	1778;"	d
+R_PARISC_DPREL21L	formats/elf_format.h	1777;"	d
+R_PARISC_EPLT	formats/elf_format.h	1836;"	d
+R_PARISC_FPTR64	formats/elf_format.h	1791;"	d
+R_PARISC_GNU_VTENTRY	formats/elf_format.h	1855;"	d
+R_PARISC_GNU_VTINHERIT	formats/elf_format.h	1856;"	d
+R_PARISC_GPREL14DR	formats/elf_format.h	1810;"	d
+R_PARISC_GPREL14R	formats/elf_format.h	1780;"	d
+R_PARISC_GPREL14WR	formats/elf_format.h	1809;"	d
+R_PARISC_GPREL16DF	formats/elf_format.h	1813;"	d
+R_PARISC_GPREL16F	formats/elf_format.h	1811;"	d
+R_PARISC_GPREL16WF	formats/elf_format.h	1812;"	d
+R_PARISC_GPREL21L	formats/elf_format.h	1779;"	d
+R_PARISC_GPREL64	formats/elf_format.h	1808;"	d
+R_PARISC_HIRESERVE	formats/elf_format.h	1875;"	d
+R_PARISC_IPLT	formats/elf_format.h	1835;"	d
+R_PARISC_LORESERVE	formats/elf_format.h	1833;"	d
+R_PARISC_LTOFF14DR	formats/elf_format.h	1816;"	d
+R_PARISC_LTOFF14R	formats/elf_format.h	1782;"	d
+R_PARISC_LTOFF14WR	formats/elf_format.h	1815;"	d
+R_PARISC_LTOFF16DF	formats/elf_format.h	1819;"	d
+R_PARISC_LTOFF16F	formats/elf_format.h	1817;"	d
+R_PARISC_LTOFF16WF	formats/elf_format.h	1818;"	d
+R_PARISC_LTOFF21L	formats/elf_format.h	1781;"	d
+R_PARISC_LTOFF64	formats/elf_format.h	1814;"	d
+R_PARISC_LTOFF_FPTR14DR	formats/elf_format.h	1829;"	d
+R_PARISC_LTOFF_FPTR14R	formats/elf_format.h	1790;"	d
+R_PARISC_LTOFF_FPTR14WR	formats/elf_format.h	1828;"	d
+R_PARISC_LTOFF_FPTR16DF	formats/elf_format.h	1832;"	d
+R_PARISC_LTOFF_FPTR16F	formats/elf_format.h	1830;"	d
+R_PARISC_LTOFF_FPTR16WF	formats/elf_format.h	1831;"	d
+R_PARISC_LTOFF_FPTR21L	formats/elf_format.h	1789;"	d
+R_PARISC_LTOFF_FPTR32	formats/elf_format.h	1788;"	d
+R_PARISC_LTOFF_FPTR64	formats/elf_format.h	1827;"	d
+R_PARISC_LTOFF_TP14DR	formats/elf_format.h	1851;"	d
+R_PARISC_LTOFF_TP14F	formats/elf_format.h	1842;"	d
+R_PARISC_LTOFF_TP14R	formats/elf_format.h	1841;"	d
+R_PARISC_LTOFF_TP14WR	formats/elf_format.h	1850;"	d
+R_PARISC_LTOFF_TP16DF	formats/elf_format.h	1854;"	d
+R_PARISC_LTOFF_TP16F	formats/elf_format.h	1852;"	d
+R_PARISC_LTOFF_TP16WF	formats/elf_format.h	1853;"	d
+R_PARISC_LTOFF_TP21L	formats/elf_format.h	1840;"	d
+R_PARISC_LTOFF_TP64	formats/elf_format.h	1849;"	d
+R_PARISC_NONE	formats/elf_format.h	1766;"	d
+R_PARISC_PCREL14DR	formats/elf_format.h	1798;"	d
+R_PARISC_PCREL14R	formats/elf_format.h	1776;"	d
+R_PARISC_PCREL14WR	formats/elf_format.h	1797;"	d
+R_PARISC_PCREL16DF	formats/elf_format.h	1801;"	d
+R_PARISC_PCREL16F	formats/elf_format.h	1799;"	d
+R_PARISC_PCREL16WF	formats/elf_format.h	1800;"	d
+R_PARISC_PCREL17F	formats/elf_format.h	1775;"	d
+R_PARISC_PCREL17R	formats/elf_format.h	1774;"	d
+R_PARISC_PCREL21L	formats/elf_format.h	1773;"	d
+R_PARISC_PCREL22F	formats/elf_format.h	1796;"	d
+R_PARISC_PCREL32	formats/elf_format.h	1772;"	d
+R_PARISC_PCREL64	formats/elf_format.h	1795;"	d
+R_PARISC_PLABEL14R	formats/elf_format.h	1794;"	d
+R_PARISC_PLABEL21L	formats/elf_format.h	1793;"	d
+R_PARISC_PLABEL32	formats/elf_format.h	1792;"	d
+R_PARISC_PLTOFF14DR	formats/elf_format.h	1823;"	d
+R_PARISC_PLTOFF14R	formats/elf_format.h	1787;"	d
+R_PARISC_PLTOFF14WR	formats/elf_format.h	1822;"	d
+R_PARISC_PLTOFF16DF	formats/elf_format.h	1826;"	d
+R_PARISC_PLTOFF16F	formats/elf_format.h	1824;"	d
+R_PARISC_PLTOFF16WF	formats/elf_format.h	1825;"	d
+R_PARISC_PLTOFF21L	formats/elf_format.h	1786;"	d
+R_PARISC_SECREL32	formats/elf_format.h	1783;"	d
+R_PARISC_SECREL64	formats/elf_format.h	1820;"	d
+R_PARISC_SEGBASE	formats/elf_format.h	1784;"	d
+R_PARISC_SEGREL32	formats/elf_format.h	1785;"	d
+R_PARISC_SEGREL64	formats/elf_format.h	1821;"	d
+R_PARISC_TLS_DTPMOD32	formats/elf_format.h	1865;"	d
+R_PARISC_TLS_DTPMOD64	formats/elf_format.h	1866;"	d
+R_PARISC_TLS_DTPOFF32	formats/elf_format.h	1867;"	d
+R_PARISC_TLS_DTPOFF64	formats/elf_format.h	1868;"	d
+R_PARISC_TLS_GD14R	formats/elf_format.h	1858;"	d
+R_PARISC_TLS_GD21L	formats/elf_format.h	1857;"	d
+R_PARISC_TLS_GDCALL	formats/elf_format.h	1859;"	d
+R_PARISC_TLS_IE14R	formats/elf_format.h	1872;"	d
+R_PARISC_TLS_IE21L	formats/elf_format.h	1871;"	d
+R_PARISC_TLS_LDM14R	formats/elf_format.h	1861;"	d
+R_PARISC_TLS_LDM21L	formats/elf_format.h	1860;"	d
+R_PARISC_TLS_LDMCALL	formats/elf_format.h	1862;"	d
+R_PARISC_TLS_LDO14R	formats/elf_format.h	1864;"	d
+R_PARISC_TLS_LDO21L	formats/elf_format.h	1863;"	d
+R_PARISC_TLS_LE14R	formats/elf_format.h	1870;"	d
+R_PARISC_TLS_LE21L	formats/elf_format.h	1869;"	d
+R_PARISC_TLS_TPREL32	formats/elf_format.h	1873;"	d
+R_PARISC_TLS_TPREL64	formats/elf_format.h	1874;"	d
+R_PARISC_TPREL14DR	formats/elf_format.h	1845;"	d
+R_PARISC_TPREL14R	formats/elf_format.h	1839;"	d
+R_PARISC_TPREL14WR	formats/elf_format.h	1844;"	d
+R_PARISC_TPREL16DF	formats/elf_format.h	1848;"	d
+R_PARISC_TPREL16F	formats/elf_format.h	1846;"	d
+R_PARISC_TPREL16WF	formats/elf_format.h	1847;"	d
+R_PARISC_TPREL21L	formats/elf_format.h	1838;"	d
+R_PARISC_TPREL32	formats/elf_format.h	1837;"	d
+R_PARISC_TPREL64	formats/elf_format.h	1843;"	d
+R_PPC64_ADDR14	formats/elf_format.h	2113;"	d
+R_PPC64_ADDR14_BRNTAKEN	formats/elf_format.h	2115;"	d
+R_PPC64_ADDR14_BRTAKEN	formats/elf_format.h	2114;"	d
+R_PPC64_ADDR16	formats/elf_format.h	2109;"	d
+R_PPC64_ADDR16_DS	formats/elf_format.h	2163;"	d
+R_PPC64_ADDR16_HA	formats/elf_format.h	2112;"	d
+R_PPC64_ADDR16_HI	formats/elf_format.h	2111;"	d
+R_PPC64_ADDR16_HIGHER	formats/elf_format.h	2145;"	d
+R_PPC64_ADDR16_HIGHERA	formats/elf_format.h	2146;"	d
+R_PPC64_ADDR16_HIGHEST	formats/elf_format.h	2147;"	d
+R_PPC64_ADDR16_HIGHESTA	formats/elf_format.h	2148;"	d
+R_PPC64_ADDR16_LO	formats/elf_format.h	2110;"	d
+R_PPC64_ADDR16_LO_DS	formats/elf_format.h	2164;"	d
+R_PPC64_ADDR24	formats/elf_format.h	2108;"	d
+R_PPC64_ADDR30	formats/elf_format.h	2143;"	d
+R_PPC64_ADDR32	formats/elf_format.h	2107;"	d
+R_PPC64_ADDR64	formats/elf_format.h	2144;"	d
+R_PPC64_COPY	formats/elf_format.h	2125;"	d
+R_PPC64_DTPMOD64	formats/elf_format.h	2177;"	d
+R_PPC64_DTPREL16	formats/elf_format.h	2183;"	d
+R_PPC64_DTPREL16_DS	formats/elf_format.h	2210;"	d
+R_PPC64_DTPREL16_HA	formats/elf_format.h	2186;"	d
+R_PPC64_DTPREL16_HI	formats/elf_format.h	2185;"	d
+R_PPC64_DTPREL16_HIGHER	formats/elf_format.h	2212;"	d
+R_PPC64_DTPREL16_HIGHERA	formats/elf_format.h	2213;"	d
+R_PPC64_DTPREL16_HIGHEST	formats/elf_format.h	2214;"	d
+R_PPC64_DTPREL16_HIGHESTA	formats/elf_format.h	2215;"	d
+R_PPC64_DTPREL16_LO	formats/elf_format.h	2184;"	d
+R_PPC64_DTPREL16_LO_DS	formats/elf_format.h	2211;"	d
+R_PPC64_DTPREL64	formats/elf_format.h	2187;"	d
+R_PPC64_GLOB_DAT	formats/elf_format.h	2126;"	d
+R_PPC64_GOT16	formats/elf_format.h	2120;"	d
+R_PPC64_GOT16_DS	formats/elf_format.h	2165;"	d
+R_PPC64_GOT16_HA	formats/elf_format.h	2123;"	d
+R_PPC64_GOT16_HI	formats/elf_format.h	2122;"	d
+R_PPC64_GOT16_LO	formats/elf_format.h	2121;"	d
+R_PPC64_GOT16_LO_DS	formats/elf_format.h	2166;"	d
+R_PPC64_GOT_DTPREL16_DS	formats/elf_format.h	2200;"	d
+R_PPC64_GOT_DTPREL16_HA	formats/elf_format.h	2203;"	d
+R_PPC64_GOT_DTPREL16_HI	formats/elf_format.h	2202;"	d
+R_PPC64_GOT_DTPREL16_LO_DS	formats/elf_format.h	2201;"	d
+R_PPC64_GOT_TLSGD16	formats/elf_format.h	2188;"	d
+R_PPC64_GOT_TLSGD16_HA	formats/elf_format.h	2191;"	d
+R_PPC64_GOT_TLSGD16_HI	formats/elf_format.h	2190;"	d
+R_PPC64_GOT_TLSGD16_LO	formats/elf_format.h	2189;"	d
+R_PPC64_GOT_TLSLD16	formats/elf_format.h	2192;"	d
+R_PPC64_GOT_TLSLD16_HA	formats/elf_format.h	2195;"	d
+R_PPC64_GOT_TLSLD16_HI	formats/elf_format.h	2194;"	d
+R_PPC64_GOT_TLSLD16_LO	formats/elf_format.h	2193;"	d
+R_PPC64_GOT_TPREL16_DS	formats/elf_format.h	2196;"	d
+R_PPC64_GOT_TPREL16_HA	formats/elf_format.h	2199;"	d
+R_PPC64_GOT_TPREL16_HI	formats/elf_format.h	2198;"	d
+R_PPC64_GOT_TPREL16_LO_DS	formats/elf_format.h	2197;"	d
+R_PPC64_IRELATIVE	formats/elf_format.h	2219;"	d
+R_PPC64_JMP_IREL	formats/elf_format.h	2218;"	d
+R_PPC64_JMP_SLOT	formats/elf_format.h	2127;"	d
+R_PPC64_NONE	formats/elf_format.h	2106;"	d
+R_PPC64_PLT16_HA	formats/elf_format.h	2137;"	d
+R_PPC64_PLT16_HI	formats/elf_format.h	2136;"	d
+R_PPC64_PLT16_LO	formats/elf_format.h	2135;"	d
+R_PPC64_PLT16_LO_DS	formats/elf_format.h	2167;"	d
+R_PPC64_PLT32	formats/elf_format.h	2133;"	d
+R_PPC64_PLT64	formats/elf_format.h	2151;"	d
+R_PPC64_PLTGOT16	formats/elf_format.h	2158;"	d
+R_PPC64_PLTGOT16_DS	formats/elf_format.h	2172;"	d
+R_PPC64_PLTGOT16_HA	formats/elf_format.h	2161;"	d
+R_PPC64_PLTGOT16_HI	formats/elf_format.h	2160;"	d
+R_PPC64_PLTGOT16_LO	formats/elf_format.h	2159;"	d
+R_PPC64_PLTGOT16_LO_DS	formats/elf_format.h	2173;"	d
+R_PPC64_PLTREL32	formats/elf_format.h	2134;"	d
+R_PPC64_PLTREL64	formats/elf_format.h	2152;"	d
+R_PPC64_REL14	formats/elf_format.h	2117;"	d
+R_PPC64_REL14_BRNTAKEN	formats/elf_format.h	2119;"	d
+R_PPC64_REL14_BRTAKEN	formats/elf_format.h	2118;"	d
+R_PPC64_REL16	formats/elf_format.h	2220;"	d
+R_PPC64_REL16_HA	formats/elf_format.h	2223;"	d
+R_PPC64_REL16_HI	formats/elf_format.h	2222;"	d
+R_PPC64_REL16_LO	formats/elf_format.h	2221;"	d
+R_PPC64_REL24	formats/elf_format.h	2116;"	d
+R_PPC64_REL32	formats/elf_format.h	2132;"	d
+R_PPC64_REL64	formats/elf_format.h	2150;"	d
+R_PPC64_RELATIVE	formats/elf_format.h	2128;"	d
+R_PPC64_SECTOFF	formats/elf_format.h	2139;"	d
+R_PPC64_SECTOFF_DS	formats/elf_format.h	2168;"	d
+R_PPC64_SECTOFF_HA	formats/elf_format.h	2142;"	d
+R_PPC64_SECTOFF_HI	formats/elf_format.h	2141;"	d
+R_PPC64_SECTOFF_LO	formats/elf_format.h	2140;"	d
+R_PPC64_SECTOFF_LO_DS	formats/elf_format.h	2169;"	d
+R_PPC64_TLS	formats/elf_format.h	2176;"	d
+R_PPC64_TOC	formats/elf_format.h	2157;"	d
+R_PPC64_TOC16	formats/elf_format.h	2153;"	d
+R_PPC64_TOC16_DS	formats/elf_format.h	2170;"	d
+R_PPC64_TOC16_HA	formats/elf_format.h	2156;"	d
+R_PPC64_TOC16_HI	formats/elf_format.h	2155;"	d
+R_PPC64_TOC16_LO	formats/elf_format.h	2154;"	d
+R_PPC64_TOC16_LO_DS	formats/elf_format.h	2171;"	d
+R_PPC64_TPREL16	formats/elf_format.h	2178;"	d
+R_PPC64_TPREL16_DS	formats/elf_format.h	2204;"	d
+R_PPC64_TPREL16_HA	formats/elf_format.h	2181;"	d
+R_PPC64_TPREL16_HI	formats/elf_format.h	2180;"	d
+R_PPC64_TPREL16_HIGHER	formats/elf_format.h	2206;"	d
+R_PPC64_TPREL16_HIGHERA	formats/elf_format.h	2207;"	d
+R_PPC64_TPREL16_HIGHEST	formats/elf_format.h	2208;"	d
+R_PPC64_TPREL16_HIGHESTA	formats/elf_format.h	2209;"	d
+R_PPC64_TPREL16_LO	formats/elf_format.h	2179;"	d
+R_PPC64_TPREL16_LO_DS	formats/elf_format.h	2205;"	d
+R_PPC64_TPREL64	formats/elf_format.h	2182;"	d
+R_PPC64_UADDR16	formats/elf_format.h	2131;"	d
+R_PPC64_UADDR32	formats/elf_format.h	2130;"	d
+R_PPC64_UADDR64	formats/elf_format.h	2149;"	d
+R_PPC_ADDR14	formats/elf_format.h	2000;"	d
+R_PPC_ADDR14_BRNTAKEN	formats/elf_format.h	2002;"	d
+R_PPC_ADDR14_BRTAKEN	formats/elf_format.h	2001;"	d
+R_PPC_ADDR16	formats/elf_format.h	1996;"	d
+R_PPC_ADDR16_HA	formats/elf_format.h	1999;"	d
+R_PPC_ADDR16_HI	formats/elf_format.h	1998;"	d
+R_PPC_ADDR16_LO	formats/elf_format.h	1997;"	d
+R_PPC_ADDR24	formats/elf_format.h	1995;"	d
+R_PPC_ADDR32	formats/elf_format.h	1994;"	d
+R_PPC_COPY	formats/elf_format.h	2012;"	d
+R_PPC_DIAB_RELSDA_HA	formats/elf_format.h	2086;"	d
+R_PPC_DIAB_RELSDA_HI	formats/elf_format.h	2085;"	d
+R_PPC_DIAB_RELSDA_LO	formats/elf_format.h	2084;"	d
+R_PPC_DIAB_SDA21_HA	formats/elf_format.h	2083;"	d
+R_PPC_DIAB_SDA21_HI	formats/elf_format.h	2082;"	d
+R_PPC_DIAB_SDA21_LO	formats/elf_format.h	2081;"	d
+R_PPC_DTPMOD32	formats/elf_format.h	2033;"	d
+R_PPC_DTPREL16	formats/elf_format.h	2039;"	d
+R_PPC_DTPREL16_HA	formats/elf_format.h	2042;"	d
+R_PPC_DTPREL16_HI	formats/elf_format.h	2041;"	d
+R_PPC_DTPREL16_LO	formats/elf_format.h	2040;"	d
+R_PPC_DTPREL32	formats/elf_format.h	2043;"	d
+R_PPC_EMB_BIT_FLD	formats/elf_format.h	2077;"	d
+R_PPC_EMB_MRKREF	formats/elf_format.h	2072;"	d
+R_PPC_EMB_NADDR16	formats/elf_format.h	2064;"	d
+R_PPC_EMB_NADDR16_HA	formats/elf_format.h	2067;"	d
+R_PPC_EMB_NADDR16_HI	formats/elf_format.h	2066;"	d
+R_PPC_EMB_NADDR16_LO	formats/elf_format.h	2065;"	d
+R_PPC_EMB_NADDR32	formats/elf_format.h	2063;"	d
+R_PPC_EMB_RELSDA	formats/elf_format.h	2078;"	d
+R_PPC_EMB_RELSEC16	formats/elf_format.h	2073;"	d
+R_PPC_EMB_RELST_HA	formats/elf_format.h	2076;"	d
+R_PPC_EMB_RELST_HI	formats/elf_format.h	2075;"	d
+R_PPC_EMB_RELST_LO	formats/elf_format.h	2074;"	d
+R_PPC_EMB_SDA21	formats/elf_format.h	2071;"	d
+R_PPC_EMB_SDA2I16	formats/elf_format.h	2069;"	d
+R_PPC_EMB_SDA2REL	formats/elf_format.h	2070;"	d
+R_PPC_EMB_SDAI16	formats/elf_format.h	2068;"	d
+R_PPC_GLOB_DAT	formats/elf_format.h	2013;"	d
+R_PPC_GOT16	formats/elf_format.h	2007;"	d
+R_PPC_GOT16_HA	formats/elf_format.h	2010;"	d
+R_PPC_GOT16_HI	formats/elf_format.h	2009;"	d
+R_PPC_GOT16_LO	formats/elf_format.h	2008;"	d
+R_PPC_GOT_DTPREL16	formats/elf_format.h	2056;"	d
+R_PPC_GOT_DTPREL16_HA	formats/elf_format.h	2059;"	d
+R_PPC_GOT_DTPREL16_HI	formats/elf_format.h	2058;"	d
+R_PPC_GOT_DTPREL16_LO	formats/elf_format.h	2057;"	d
+R_PPC_GOT_TLSGD16	formats/elf_format.h	2044;"	d
+R_PPC_GOT_TLSGD16_HA	formats/elf_format.h	2047;"	d
+R_PPC_GOT_TLSGD16_HI	formats/elf_format.h	2046;"	d
+R_PPC_GOT_TLSGD16_LO	formats/elf_format.h	2045;"	d
+R_PPC_GOT_TLSLD16	formats/elf_format.h	2048;"	d
+R_PPC_GOT_TLSLD16_HA	formats/elf_format.h	2051;"	d
+R_PPC_GOT_TLSLD16_HI	formats/elf_format.h	2050;"	d
+R_PPC_GOT_TLSLD16_LO	formats/elf_format.h	2049;"	d
+R_PPC_GOT_TPREL16	formats/elf_format.h	2052;"	d
+R_PPC_GOT_TPREL16_HA	formats/elf_format.h	2055;"	d
+R_PPC_GOT_TPREL16_HI	formats/elf_format.h	2054;"	d
+R_PPC_GOT_TPREL16_LO	formats/elf_format.h	2053;"	d
+R_PPC_IRELATIVE	formats/elf_format.h	2089;"	d
+R_PPC_JMP_SLOT	formats/elf_format.h	2014;"	d
+R_PPC_LOCAL24PC	formats/elf_format.h	2016;"	d
+R_PPC_NONE	formats/elf_format.h	1993;"	d
+R_PPC_PLT16_HA	formats/elf_format.h	2024;"	d
+R_PPC_PLT16_HI	formats/elf_format.h	2023;"	d
+R_PPC_PLT16_LO	formats/elf_format.h	2022;"	d
+R_PPC_PLT32	formats/elf_format.h	2020;"	d
+R_PPC_PLTREL24	formats/elf_format.h	2011;"	d
+R_PPC_PLTREL32	formats/elf_format.h	2021;"	d
+R_PPC_REL14	formats/elf_format.h	2004;"	d
+R_PPC_REL14_BRNTAKEN	formats/elf_format.h	2006;"	d
+R_PPC_REL14_BRTAKEN	formats/elf_format.h	2005;"	d
+R_PPC_REL16	formats/elf_format.h	2092;"	d
+R_PPC_REL16_HA	formats/elf_format.h	2095;"	d
+R_PPC_REL16_HI	formats/elf_format.h	2094;"	d
+R_PPC_REL16_LO	formats/elf_format.h	2093;"	d
+R_PPC_REL24	formats/elf_format.h	2003;"	d
+R_PPC_REL32	formats/elf_format.h	2019;"	d
+R_PPC_RELATIVE	formats/elf_format.h	2015;"	d
+R_PPC_SDAREL16	formats/elf_format.h	2025;"	d
+R_PPC_SECTOFF	formats/elf_format.h	2026;"	d
+R_PPC_SECTOFF_HA	formats/elf_format.h	2029;"	d
+R_PPC_SECTOFF_HI	formats/elf_format.h	2028;"	d
+R_PPC_SECTOFF_LO	formats/elf_format.h	2027;"	d
+R_PPC_TLS	formats/elf_format.h	2032;"	d
+R_PPC_TOC16	formats/elf_format.h	2099;"	d
+R_PPC_TPREL16	formats/elf_format.h	2034;"	d
+R_PPC_TPREL16_HA	formats/elf_format.h	2037;"	d
+R_PPC_TPREL16_HI	formats/elf_format.h	2036;"	d
+R_PPC_TPREL16_LO	formats/elf_format.h	2035;"	d
+R_PPC_TPREL32	formats/elf_format.h	2038;"	d
+R_PPC_UADDR16	formats/elf_format.h	2018;"	d
+R_PPC_UADDR32	formats/elf_format.h	2017;"	d
+R_SH_ALIGN	formats/elf_format.h	2481;"	d
+R_SH_CODE	formats/elf_format.h	2482;"	d
+R_SH_COPY	formats/elf_format.h	2498;"	d
+R_SH_COUNT	formats/elf_format.h	2480;"	d
+R_SH_DATA	formats/elf_format.h	2483;"	d
+R_SH_DIR32	formats/elf_format.h	2468;"	d
+R_SH_DIR8BP	formats/elf_format.h	2474;"	d
+R_SH_DIR8L	formats/elf_format.h	2476;"	d
+R_SH_DIR8W	formats/elf_format.h	2475;"	d
+R_SH_DIR8WPL	formats/elf_format.h	2472;"	d
+R_SH_DIR8WPN	formats/elf_format.h	2470;"	d
+R_SH_DIR8WPZ	formats/elf_format.h	2473;"	d
+R_SH_GLOB_DAT	formats/elf_format.h	2499;"	d
+R_SH_GNU_VTENTRY	formats/elf_format.h	2487;"	d
+R_SH_GNU_VTINHERIT	formats/elf_format.h	2486;"	d
+R_SH_GOT32	formats/elf_format.h	2496;"	d
+R_SH_GOTOFF	formats/elf_format.h	2502;"	d
+R_SH_GOTPC	formats/elf_format.h	2503;"	d
+R_SH_IND12W	formats/elf_format.h	2471;"	d
+R_SH_JMP_SLOT	formats/elf_format.h	2500;"	d
+R_SH_LABEL	formats/elf_format.h	2484;"	d
+R_SH_NONE	formats/elf_format.h	2467;"	d
+R_SH_NUM	formats/elf_format.h	2505;"	d
+R_SH_PLT32	formats/elf_format.h	2497;"	d
+R_SH_REL32	formats/elf_format.h	2469;"	d
+R_SH_RELATIVE	formats/elf_format.h	2501;"	d
+R_SH_SWITCH16	formats/elf_format.h	2477;"	d
+R_SH_SWITCH32	formats/elf_format.h	2478;"	d
+R_SH_SWITCH8	formats/elf_format.h	2485;"	d
+R_SH_TLS_DTPMOD32	formats/elf_format.h	2493;"	d
+R_SH_TLS_DTPOFF32	formats/elf_format.h	2494;"	d
+R_SH_TLS_GD_32	formats/elf_format.h	2488;"	d
+R_SH_TLS_IE_32	formats/elf_format.h	2491;"	d
+R_SH_TLS_LDO_32	formats/elf_format.h	2490;"	d
+R_SH_TLS_LD_32	formats/elf_format.h	2489;"	d
+R_SH_TLS_LE_32	formats/elf_format.h	2492;"	d
+R_SH_TLS_TPOFF32	formats/elf_format.h	2495;"	d
+R_SH_USES	formats/elf_format.h	2479;"	d
+R_SPARC_10	formats/elf_format.h	1259;"	d
+R_SPARC_11	formats/elf_format.h	1260;"	d
+R_SPARC_13	formats/elf_format.h	1237;"	d
+R_SPARC_16	formats/elf_format.h	1228;"	d
+R_SPARC_22	formats/elf_format.h	1236;"	d
+R_SPARC_32	formats/elf_format.h	1229;"	d
+R_SPARC_5	formats/elf_format.h	1273;"	d
+R_SPARC_6	formats/elf_format.h	1274;"	d
+R_SPARC_64	formats/elf_format.h	1261;"	d
+R_SPARC_7	formats/elf_format.h	1272;"	d
+R_SPARC_8	formats/elf_format.h	1227;"	d
+R_SPARC_COPY	formats/elf_format.h	1245;"	d
+R_SPARC_DISP16	formats/elf_format.h	1231;"	d
+R_SPARC_DISP32	formats/elf_format.h	1232;"	d
+R_SPARC_DISP64	formats/elf_format.h	1275;"	d
+R_SPARC_DISP8	formats/elf_format.h	1230;"	d
+R_SPARC_GLOB_DAT	formats/elf_format.h	1246;"	d
+R_SPARC_GLOB_JMP	formats/elf_format.h	1271;"	d
+R_SPARC_GNU_VTENTRY	formats/elf_format.h	1318;"	d
+R_SPARC_GNU_VTINHERIT	formats/elf_format.h	1317;"	d
+R_SPARC_GOT10	formats/elf_format.h	1239;"	d
+R_SPARC_GOT13	formats/elf_format.h	1240;"	d
+R_SPARC_GOT22	formats/elf_format.h	1241;"	d
+R_SPARC_GOTDATA_HIX22	formats/elf_format.h	1309;"	d
+R_SPARC_GOTDATA_LOX10	formats/elf_format.h	1310;"	d
+R_SPARC_GOTDATA_OP	formats/elf_format.h	1313;"	d
+R_SPARC_GOTDATA_OP_HIX22	formats/elf_format.h	1311;"	d
+R_SPARC_GOTDATA_OP_LOX10	formats/elf_format.h	1312;"	d
+R_SPARC_H34	formats/elf_format.h	1314;"	d
+R_SPARC_H44	formats/elf_format.h	1279;"	d
+R_SPARC_HH22	formats/elf_format.h	1263;"	d
+R_SPARC_HI22	formats/elf_format.h	1235;"	d
+R_SPARC_HIPLT22	formats/elf_format.h	1254;"	d
+R_SPARC_HIX22	formats/elf_format.h	1277;"	d
+R_SPARC_HM10	formats/elf_format.h	1264;"	d
+R_SPARC_JMP_SLOT	formats/elf_format.h	1247;"	d
+R_SPARC_L44	formats/elf_format.h	1281;"	d
+R_SPARC_LM22	formats/elf_format.h	1265;"	d
+R_SPARC_LO10	formats/elf_format.h	1238;"	d
+R_SPARC_LOPLT10	formats/elf_format.h	1255;"	d
+R_SPARC_LOX10	formats/elf_format.h	1278;"	d
+R_SPARC_M44	formats/elf_format.h	1280;"	d
+R_SPARC_NONE	formats/elf_format.h	1226;"	d
+R_SPARC_NUM	formats/elf_format.h	1321;"	d
+R_SPARC_OLO10	formats/elf_format.h	1262;"	d
+R_SPARC_PC10	formats/elf_format.h	1242;"	d
+R_SPARC_PC22	formats/elf_format.h	1243;"	d
+R_SPARC_PCPLT10	formats/elf_format.h	1258;"	d
+R_SPARC_PCPLT22	formats/elf_format.h	1257;"	d
+R_SPARC_PCPLT32	formats/elf_format.h	1256;"	d
+R_SPARC_PC_HH22	formats/elf_format.h	1266;"	d
+R_SPARC_PC_HM10	formats/elf_format.h	1267;"	d
+R_SPARC_PC_LM22	formats/elf_format.h	1268;"	d
+R_SPARC_PLT32	formats/elf_format.h	1253;"	d
+R_SPARC_PLT64	formats/elf_format.h	1276;"	d
+R_SPARC_REGISTER	formats/elf_format.h	1282;"	d
+R_SPARC_RELATIVE	formats/elf_format.h	1248;"	d
+R_SPARC_REV32	formats/elf_format.h	1319;"	d
+R_SPARC_SIZE32	formats/elf_format.h	1315;"	d
+R_SPARC_SIZE64	formats/elf_format.h	1316;"	d
+R_SPARC_TLS_DTPMOD32	formats/elf_format.h	1303;"	d
+R_SPARC_TLS_DTPMOD64	formats/elf_format.h	1304;"	d
+R_SPARC_TLS_DTPOFF32	formats/elf_format.h	1305;"	d
+R_SPARC_TLS_DTPOFF64	formats/elf_format.h	1306;"	d
+R_SPARC_TLS_GD_ADD	formats/elf_format.h	1287;"	d
+R_SPARC_TLS_GD_CALL	formats/elf_format.h	1288;"	d
+R_SPARC_TLS_GD_HI22	formats/elf_format.h	1285;"	d
+R_SPARC_TLS_GD_LO10	formats/elf_format.h	1286;"	d
+R_SPARC_TLS_IE_ADD	formats/elf_format.h	1300;"	d
+R_SPARC_TLS_IE_HI22	formats/elf_format.h	1296;"	d
+R_SPARC_TLS_IE_LD	formats/elf_format.h	1298;"	d
+R_SPARC_TLS_IE_LDX	formats/elf_format.h	1299;"	d
+R_SPARC_TLS_IE_LO10	formats/elf_format.h	1297;"	d
+R_SPARC_TLS_LDM_ADD	formats/elf_format.h	1291;"	d
+R_SPARC_TLS_LDM_CALL	formats/elf_format.h	1292;"	d
+R_SPARC_TLS_LDM_HI22	formats/elf_format.h	1289;"	d
+R_SPARC_TLS_LDM_LO10	formats/elf_format.h	1290;"	d
+R_SPARC_TLS_LDO_ADD	formats/elf_format.h	1295;"	d
+R_SPARC_TLS_LDO_HIX22	formats/elf_format.h	1293;"	d
+R_SPARC_TLS_LDO_LOX10	formats/elf_format.h	1294;"	d
+R_SPARC_TLS_LE_HIX22	formats/elf_format.h	1301;"	d
+R_SPARC_TLS_LE_LOX10	formats/elf_format.h	1302;"	d
+R_SPARC_TLS_TPOFF32	formats/elf_format.h	1307;"	d
+R_SPARC_TLS_TPOFF64	formats/elf_format.h	1308;"	d
+R_SPARC_UA16	formats/elf_format.h	1284;"	d
+R_SPARC_UA32	formats/elf_format.h	1249;"	d
+R_SPARC_UA64	formats/elf_format.h	1283;"	d
+R_SPARC_WDISP16	formats/elf_format.h	1269;"	d
+R_SPARC_WDISP19	formats/elf_format.h	1270;"	d
+R_SPARC_WDISP22	formats/elf_format.h	1234;"	d
+R_SPARC_WDISP30	formats/elf_format.h	1233;"	d
+R_SPARC_WPLT30	formats/elf_format.h	1244;"	d
+R_X86_64_16	formats/elf_format.h	2631;"	d
+R_X86_64_32	formats/elf_format.h	2629;"	d
+R_X86_64_32S	formats/elf_format.h	2630;"	d
+R_X86_64_64	formats/elf_format.h	2619;"	d
+R_X86_64_8	formats/elf_format.h	2633;"	d
+R_X86_64_COPY	formats/elf_format.h	2623;"	d
+R_X86_64_DTPMOD64	formats/elf_format.h	2635;"	d
+R_X86_64_DTPOFF32	formats/elf_format.h	2642;"	d
+R_X86_64_DTPOFF64	formats/elf_format.h	2636;"	d
+R_X86_64_GLOB_DAT	formats/elf_format.h	2624;"	d
+R_X86_64_GOT32	formats/elf_format.h	2621;"	d
+R_X86_64_GOTOFF64	formats/elf_format.h	2647;"	d
+R_X86_64_GOTPC32	formats/elf_format.h	2648;"	d
+R_X86_64_GOTPC32_TLSDESC	formats/elf_format.h	2651;"	d
+R_X86_64_GOTPCREL	formats/elf_format.h	2627;"	d
+R_X86_64_GOTTPOFF	formats/elf_format.h	2643;"	d
+R_X86_64_IRELATIVE	formats/elf_format.h	2655;"	d
+R_X86_64_JUMP_SLOT	formats/elf_format.h	2625;"	d
+R_X86_64_NONE	formats/elf_format.h	2618;"	d
+R_X86_64_NUM	formats/elf_format.h	2657;"	d
+R_X86_64_PC16	formats/elf_format.h	2632;"	d
+R_X86_64_PC32	formats/elf_format.h	2620;"	d
+R_X86_64_PC64	formats/elf_format.h	2646;"	d
+R_X86_64_PC8	formats/elf_format.h	2634;"	d
+R_X86_64_PLT32	formats/elf_format.h	2622;"	d
+R_X86_64_RELATIVE	formats/elf_format.h	2626;"	d
+R_X86_64_TLSDESC	formats/elf_format.h	2654;"	d
+R_X86_64_TLSDESC_CALL	formats/elf_format.h	2652;"	d
+R_X86_64_TLSGD	formats/elf_format.h	2638;"	d
+R_X86_64_TLSLD	formats/elf_format.h	2640;"	d
+R_X86_64_TPOFF32	formats/elf_format.h	2645;"	d
+R_X86_64_TPOFF64	formats/elf_format.h	2637;"	d
+SAVE	ui/flatfile.c	/^	SAVE,$/;"	e	enum:operation	file:
+SCCI	simio/simio_timer.c	45;"	d	file:
+SCS	simio/simio_timer.c	44;"	d	file:
+SEL	drivers/jtdev.c	48;"	d	file:
+SELECTIN	drivers/jtdev.c	57;"	d	file:
+SELFMAG	formats/elf_format.h	119;"	d
+SELF_TEST0_OFFSET	drivers/fet_olimex_db.c	31;"	d	file:
+SELF_TEST1_OFFSET	drivers/fet_olimex_db.c	32;"	d	file:
+SET_MDB_BEFORE_RUN	drivers/tilib_defs.h	/^        SET_MDB_BEFORE_RUN = 9,$/;"	e	enum:CONFIG_MODE
+SHDR_SIZE	formats/coff.c	40;"	d	file:
+SHF_ALLOC	formats/elf_format.h	351;"	d
+SHF_ALPHA_GPREL	formats/elf_format.h	1926;"	d
+SHF_ARM_COMDEF	formats/elf_format.h	2274;"	d
+SHF_ARM_ENTRYSECT	formats/elf_format.h	2273;"	d
+SHF_EXCLUDE	formats/elf_format.h	365;"	d
+SHF_EXECINSTR	formats/elf_format.h	352;"	d
+SHF_GROUP	formats/elf_format.h	359;"	d
+SHF_IA_64_NORECOV	formats/elf_format.h	2375;"	d
+SHF_IA_64_SHORT	formats/elf_format.h	2374;"	d
+SHF_INFO_LINK	formats/elf_format.h	355;"	d
+SHF_LINK_ORDER	formats/elf_format.h	356;"	d
+SHF_MASKOS	formats/elf_format.h	361;"	d
+SHF_MASKPROC	formats/elf_format.h	362;"	d
+SHF_MERGE	formats/elf_format.h	353;"	d
+SHF_MIPS_ADDR	formats/elf_format.h	1426;"	d
+SHF_MIPS_GPREL	formats/elf_format.h	1424;"	d
+SHF_MIPS_LOCAL	formats/elf_format.h	1429;"	d
+SHF_MIPS_MERGE	formats/elf_format.h	1425;"	d
+SHF_MIPS_NAMES	formats/elf_format.h	1430;"	d
+SHF_MIPS_NODUPE	formats/elf_format.h	1431;"	d
+SHF_MIPS_NOSTRIP	formats/elf_format.h	1428;"	d
+SHF_MIPS_STRINGS	formats/elf_format.h	1427;"	d
+SHF_ORDERED	formats/elf_format.h	363;"	d
+SHF_OS_NONCONFORMING	formats/elf_format.h	357;"	d
+SHF_PARISC_HUGE	formats/elf_format.h	1754;"	d
+SHF_PARISC_SBP	formats/elf_format.h	1755;"	d
+SHF_PARISC_SHORT	formats/elf_format.h	1753;"	d
+SHF_STRINGS	formats/elf_format.h	354;"	d
+SHF_TLS	formats/elf_format.h	360;"	d
+SHF_WRITE	formats/elf_format.h	350;"	d
+SHN_ABS	formats/elf_format.h	304;"	d
+SHN_AFTER	formats/elf_format.h	299;"	d
+SHN_BEFORE	formats/elf_format.h	297;"	d
+SHN_COMMON	formats/elf_format.h	305;"	d
+SHN_HIOS	formats/elf_format.h	303;"	d
+SHN_HIPROC	formats/elf_format.h	301;"	d
+SHN_HIRESERVE	formats/elf_format.h	307;"	d
+SHN_LOOS	formats/elf_format.h	302;"	d
+SHN_LOPROC	formats/elf_format.h	296;"	d
+SHN_LORESERVE	formats/elf_format.h	295;"	d
+SHN_MIPS_ACOMMON	formats/elf_format.h	1374;"	d
+SHN_MIPS_DATA	formats/elf_format.h	1376;"	d
+SHN_MIPS_SCOMMON	formats/elf_format.h	1377;"	d
+SHN_MIPS_SUNDEFINED	formats/elf_format.h	1378;"	d
+SHN_MIPS_TEXT	formats/elf_format.h	1375;"	d
+SHN_PARISC_ANSI_COMMON	formats/elf_format.h	1741;"	d
+SHN_PARISC_HUGE_COMMON	formats/elf_format.h	1743;"	d
+SHN_UNDEF	formats/elf_format.h	294;"	d
+SHN_XINDEX	formats/elf_format.h	306;"	d
+SHT_ALPHA_DEBUG	formats/elf_format.h	1921;"	d
+SHT_ALPHA_REGINFO	formats/elf_format.h	1922;"	d
+SHT_ARM_ATTRIBUTES	formats/elf_format.h	2289;"	d
+SHT_ARM_EXIDX	formats/elf_format.h	2287;"	d
+SHT_ARM_PREEMPTMAP	formats/elf_format.h	2288;"	d
+SHT_CHECKSUM	formats/elf_format.h	333;"	d
+SHT_DYNAMIC	formats/elf_format.h	317;"	d
+SHT_DYNSYM	formats/elf_format.h	322;"	d
+SHT_FINI_ARRAY	formats/elf_format.h	324;"	d
+SHT_GNU_ATTRIBUTES	formats/elf_format.h	330;"	d
+SHT_GNU_HASH	formats/elf_format.h	331;"	d
+SHT_GNU_LIBLIST	formats/elf_format.h	332;"	d
+SHT_GNU_verdef	formats/elf_format.h	338;"	d
+SHT_GNU_verneed	formats/elf_format.h	339;"	d
+SHT_GNU_versym	formats/elf_format.h	340;"	d
+SHT_GROUP	formats/elf_format.h	326;"	d
+SHT_HASH	formats/elf_format.h	316;"	d
+SHT_HIOS	formats/elf_format.h	342;"	d
+SHT_HIPROC	formats/elf_format.h	344;"	d
+SHT_HISUNW	formats/elf_format.h	341;"	d
+SHT_HIUSER	formats/elf_format.h	346;"	d
+SHT_IA_64_EXT	formats/elf_format.h	2370;"	d
+SHT_IA_64_UNWIND	formats/elf_format.h	2371;"	d
+SHT_INIT_ARRAY	formats/elf_format.h	323;"	d
+SHT_LOOS	formats/elf_format.h	329;"	d
+SHT_LOPROC	formats/elf_format.h	343;"	d
+SHT_LOSUNW	formats/elf_format.h	334;"	d
+SHT_LOUSER	formats/elf_format.h	345;"	d
+SHT_MIPS_AUXSYM	formats/elf_format.h	1401;"	d
+SHT_MIPS_CONFLICT	formats/elf_format.h	1384;"	d
+SHT_MIPS_CONTENT	formats/elf_format.h	1393;"	d
+SHT_MIPS_DEBUG	formats/elf_format.h	1387;"	d
+SHT_MIPS_DELTACLASS	formats/elf_format.h	1408;"	d
+SHT_MIPS_DELTADECL	formats/elf_format.h	1410;"	d
+SHT_MIPS_DELTAINST	formats/elf_format.h	1407;"	d
+SHT_MIPS_DELTASYM	formats/elf_format.h	1406;"	d
+SHT_MIPS_DENSE	formats/elf_format.h	1398;"	d
+SHT_MIPS_DWARF	formats/elf_format.h	1409;"	d
+SHT_MIPS_EH_REGION	formats/elf_format.h	1418;"	d
+SHT_MIPS_EVENTS	formats/elf_format.h	1412;"	d
+SHT_MIPS_EXTSYM	formats/elf_format.h	1397;"	d
+SHT_MIPS_FDESC	formats/elf_format.h	1396;"	d
+SHT_MIPS_GPTAB	formats/elf_format.h	1385;"	d
+SHT_MIPS_IFACE	formats/elf_format.h	1392;"	d
+SHT_MIPS_LIBLIST	formats/elf_format.h	1382;"	d
+SHT_MIPS_LINE	formats/elf_format.h	1404;"	d
+SHT_MIPS_LOCSTR	formats/elf_format.h	1403;"	d
+SHT_MIPS_LOCSYM	formats/elf_format.h	1400;"	d
+SHT_MIPS_MSYM	formats/elf_format.h	1383;"	d
+SHT_MIPS_OPTIONS	formats/elf_format.h	1394;"	d
+SHT_MIPS_OPTSYM	formats/elf_format.h	1402;"	d
+SHT_MIPS_PACKAGE	formats/elf_format.h	1389;"	d
+SHT_MIPS_PACKSYM	formats/elf_format.h	1390;"	d
+SHT_MIPS_PDESC	formats/elf_format.h	1399;"	d
+SHT_MIPS_PDR_EXCEPTION	formats/elf_format.h	1420;"	d
+SHT_MIPS_PIXIE	formats/elf_format.h	1414;"	d
+SHT_MIPS_REGINFO	formats/elf_format.h	1388;"	d
+SHT_MIPS_RELD	formats/elf_format.h	1391;"	d
+SHT_MIPS_RFDESC	formats/elf_format.h	1405;"	d
+SHT_MIPS_SHDR	formats/elf_format.h	1395;"	d
+SHT_MIPS_SYMBOL_LIB	formats/elf_format.h	1411;"	d
+SHT_MIPS_TRANSLATE	formats/elf_format.h	1413;"	d
+SHT_MIPS_UCODE	formats/elf_format.h	1386;"	d
+SHT_MIPS_WHIRL	formats/elf_format.h	1417;"	d
+SHT_MIPS_XLATE	formats/elf_format.h	1415;"	d
+SHT_MIPS_XLATE_DEBUG	formats/elf_format.h	1416;"	d
+SHT_MIPS_XLATE_OLD	formats/elf_format.h	1419;"	d
+SHT_NOBITS	formats/elf_format.h	319;"	d
+SHT_NOTE	formats/elf_format.h	318;"	d
+SHT_NULL	formats/elf_format.h	311;"	d
+SHT_NUM	formats/elf_format.h	328;"	d
+SHT_PARISC_DOC	formats/elf_format.h	1749;"	d
+SHT_PARISC_EXT	formats/elf_format.h	1747;"	d
+SHT_PARISC_UNWIND	formats/elf_format.h	1748;"	d
+SHT_PREINIT_ARRAY	formats/elf_format.h	325;"	d
+SHT_PROGBITS	formats/elf_format.h	312;"	d
+SHT_REL	formats/elf_format.h	320;"	d
+SHT_RELA	formats/elf_format.h	315;"	d
+SHT_SHLIB	formats/elf_format.h	321;"	d
+SHT_STRTAB	formats/elf_format.h	314;"	d
+SHT_SUNW_COMDAT	formats/elf_format.h	336;"	d
+SHT_SUNW_move	formats/elf_format.h	335;"	d
+SHT_SUNW_syminfo	formats/elf_format.h	337;"	d
+SHT_SYMTAB	formats/elf_format.h	313;"	d
+SHT_SYMTAB_SHNDX	formats/elf_format.h	327;"	d
+SIMIO_ACLK	simio/simio_device.h	/^	SIMIO_ACLK,$/;"	e	enum:__anon63
+SIMIO_CONSOLE_H_	simio/simio_console.h	20;"	d
+SIMIO_CPU_H_	simio/simio_cpu.h	20;"	d
+SIMIO_DEVICE_H_	simio/simio_device.h	20;"	d
+SIMIO_GPIO_H_	simio/simio_gpio.h	20;"	d
+SIMIO_HWMULT_H_	simio/simio_hwmult.h	20;"	d
+SIMIO_H_	simio/simio.h	20;"	d
+SIMIO_IE1	simio/simio_device.h	41;"	d
+SIMIO_IE2	simio/simio_device.h	43;"	d
+SIMIO_IFG1	simio/simio_device.h	42;"	d
+SIMIO_IFG2	simio/simio_device.h	44;"	d
+SIMIO_MCLK	simio/simio_device.h	/^	SIMIO_MCLK = 0,$/;"	e	enum:__anon63
+SIMIO_NUM_CLOCKS	simio/simio_device.h	/^	SIMIO_NUM_CLOCKS$/;"	e	enum:__anon63
+SIMIO_SMCLK	simio/simio_device.h	/^	SIMIO_SMCLK,$/;"	e	enum:__anon63
+SIMIO_TIMER_H_	simio/simio_timer.h	20;"	d
+SIMIO_TRACER_H_	simio/simio_tracer.h	20;"	d
+SIMIO_WDT_H_	simio/simio_wdt.h	20;"	d
+SIM_H_	drivers/sim.h	20;"	d
+SINGLE_STEP	drivers/tilib_defs.h	/^        SINGLE_STEP = 2,$/;"	e	enum:RUN_MODES
+SINGLE_STEP_COMPLETE	drivers/tilib_defs.h	/^        SINGLE_STEP_COMPLETE = 2,$/;"	e	enum:STATE_MODES
+SOCKET	util/sockets.h	/^typedef int SOCKET;$/;"	t
+SOCKETS_H_	util/sockets.h	20;"	d
+SOCKET_ISERR	util/sockets.h	28;"	d
+SOCKET_ISERR	util/sockets.h	41;"	d
+SPORT_EVEN_PARITY	util/sport.h	50;"	d
+SPORT_H_	util/sport.h	20;"	d
+SPORT_ISERR	util/sport.h	30;"	d
+SPORT_ISERR	util/sport.h	41;"	d
+SPORT_MC_DTR	util/sport.h	32;"	d
+SPORT_MC_DTR	util/sport.h	43;"	d
+SPORT_MC_RTS	util/sport.h	33;"	d
+SPORT_MC_RTS	util/sport.h	44;"	d
+SREC_H_	formats/srec.h	20;"	d
+STAB_ENTRY_SIZE	formats/coff.c	41;"	d	file:
+STAB_H_	util/stab.h	20;"	d
+STATE_BLOCKED	ui/input_async.c	/^	STATE_BLOCKED,$/;"	e	enum:__anon65	file:
+STATE_EOF	ui/input_async.c	/^	STATE_EOF$/;"	e	enum:__anon65	file:
+STATE_MODES	drivers/tilib_defs.h	/^enum STATE_MODES {$/;"	g
+STATE_READY	ui/input_async.c	/^	STATE_READY,$/;"	e	enum:__anon65	file:
+STATE_RECEIVING	ui/input_async.c	/^	STATE_RECEIVING,$/;"	e	enum:__anon65	file:
+STATUS_T	drivers/tilib_defs.h	/^typedef long STATUS_T;$/;"	t
+STB_GLOBAL	formats/elf_format.h	439;"	d
+STB_GNU_UNIQUE	formats/elf_format.h	443;"	d
+STB_HIOS	formats/elf_format.h	444;"	d
+STB_HIPROC	formats/elf_format.h	446;"	d
+STB_LOCAL	formats/elf_format.h	438;"	d
+STB_LOOS	formats/elf_format.h	442;"	d
+STB_LOPROC	formats/elf_format.h	445;"	d
+STB_MIPS_SPLIT_COMMON	formats/elf_format.h	1445;"	d
+STB_NUM	formats/elf_format.h	441;"	d
+STB_WEAK	formats/elf_format.h	440;"	d
+STDCMD_H_	ui/stdcmd.h	20;"	d
+STN_UNDEF	formats/elf_format.h	469;"	d
+STOPPED	drivers/tilib_defs.h	/^        STOPPED = 0,$/;"	e	enum:STATE_MODES
+STO_ALPHA_NOPV	formats/elf_format.h	1929;"	d
+STO_ALPHA_STD_GPLOAD	formats/elf_format.h	1930;"	d
+STO_MIPS_DEFAULT	formats/elf_format.h	1437;"	d
+STO_MIPS_HIDDEN	formats/elf_format.h	1439;"	d
+STO_MIPS_INTERNAL	formats/elf_format.h	1438;"	d
+STO_MIPS_PLT	formats/elf_format.h	1441;"	d
+STO_MIPS_PROTECTED	formats/elf_format.h	1440;"	d
+STO_MIPS_SC_ALIGN_UNUSED	formats/elf_format.h	1442;"	d
+STROBE	drivers/jtdev.c	54;"	d	file:
+STT_ARM_16BIT	formats/elf_format.h	2270;"	d
+STT_ARM_TFUNC	formats/elf_format.h	2269;"	d
+STT_COMMON	formats/elf32.c	375;"	d	file:
+STT_COMMON	formats/elf_format.h	455;"	d
+STT_FILE	formats/elf_format.h	454;"	d
+STT_FUNC	formats/elf_format.h	452;"	d
+STT_GNU_IFUNC	formats/elf_format.h	459;"	d
+STT_HIOS	formats/elf_format.h	460;"	d
+STT_HIPROC	formats/elf_format.h	462;"	d
+STT_HP_OPAQUE	formats/elf_format.h	1761;"	d
+STT_HP_STUB	formats/elf_format.h	1762;"	d
+STT_LOOS	formats/elf_format.h	458;"	d
+STT_LOPROC	formats/elf_format.h	461;"	d
+STT_NOTYPE	formats/elf_format.h	450;"	d
+STT_NUM	formats/elf_format.h	457;"	d
+STT_OBJECT	formats/elf_format.h	451;"	d
+STT_PARISC_MILLICODE	formats/elf_format.h	1759;"	d
+STT_SECTION	formats/elf_format.h	453;"	d
+STT_SPARC_REGISTER	formats/elf_format.h	1209;"	d
+STT_TLS	formats/elf_format.h	456;"	d
+STV_DEFAULT	formats/elf_format.h	480;"	d
+STV_HIDDEN	formats/elf_format.h	482;"	d
+STV_INTERNAL	formats/elf_format.h	481;"	d
+STV_PROTECTED	formats/elf_format.h	483;"	d
+STYP_BLOCK	formats/coff.c	61;"	d	file:
+STYP_BSS	formats/coff.c	60;"	d	file:
+STYP_CLINK	formats/coff.c	63;"	d	file:
+STYP_COPY	formats/coff.c	57;"	d	file:
+STYP_DATA	formats/coff.c	59;"	d	file:
+STYP_DSECT	formats/coff.c	53;"	d	file:
+STYP_GROUP	formats/coff.c	55;"	d	file:
+STYP_NOLOAD	formats/coff.c	54;"	d	file:
+STYP_PAD	formats/coff.c	56;"	d	file:
+STYP_PADDED	formats/coff.c	65;"	d	file:
+STYP_PASS	formats/coff.c	62;"	d	file:
+STYP_REG	formats/coff.c	52;"	d	file:
+STYP_TEXT	formats/coff.c	58;"	d	file:
+STYP_VECTOR	formats/coff.c	64;"	d	file:
+SUMEXT	simio/simio_hwmult.c	35;"	d	file:
+SYMINFO_BT_LOWRESERVE	formats/elf_format.h	411;"	d
+SYMINFO_BT_PARENT	formats/elf_format.h	410;"	d
+SYMINFO_BT_SELF	formats/elf_format.h	409;"	d
+SYMINFO_CURRENT	formats/elf_format.h	421;"	d
+SYMINFO_FLG_COPY	formats/elf_format.h	416;"	d
+SYMINFO_FLG_DIRECT	formats/elf_format.h	414;"	d
+SYMINFO_FLG_LAZYLOAD	formats/elf_format.h	417;"	d
+SYMINFO_FLG_PASSTHRU	formats/elf_format.h	415;"	d
+SYMINFO_NONE	formats/elf_format.h	420;"	d
+SYMINFO_NUM	formats/elf_format.h	422;"	d
+SYMMAP_H_	formats/symmap.h	20;"	d
+SYM_H_	ui/sym.h	20;"	d
+TACLR	simio/simio_timer.c	35;"	d	file:
+TAIE	simio/simio_timer.c	36;"	d	file:
+TAIFG	simio/simio_timer.c	37;"	d	file:
+TASSEL0	simio/simio_timer.c	30;"	d	file:
+TASSEL1	simio/simio_timer.c	29;"	d	file:
+TASSEL2	simio/simio_timer.c	28;"	d	file:
+TCK	drivers/jtdev.c	65;"	d	file:
+TCLK	drivers/jtdev.c	73;"	d	file:
+TDI	drivers/jtdev.c	63;"	d	file:
+TDO	drivers/jtdev.c	62;"	d	file:
+TEST	drivers/jtdev.c	61;"	d	file:
+THREAD_H_	util/thread.h	20;"	d
+TI3410_H_	transport/ti3410.h	20;"	d
+TIDLL	drivers/tilib.c	33;"	d	file:
+TIDLL	drivers/tilib.c	36;"	d	file:
+TILIB_DEFS_H_	drivers/tilib_defs.h	20;"	d
+TILIB_H_	drivers/tilib.h	20;"	d
+TIMEOUT	transport/cdc_acm.c	50;"	d	file:
+TIMEOUT	transport/ti3410.c	135;"	d	file:
+TIMEOUT_S	transport/cp210x.c	71;"	d	file:
+TIMEOUT_S	transport/ftdi.c	39;"	d	file:
+TIMEOUT_S	util/sport.c	34;"	d	file:
+TITEXT_H_	formats/titext.h	20;"	d
+TI_ACTIVE_CONFIG	transport/ti3410.c	39;"	d	file:
+TI_BOOT_CONFIG	transport/ti3410.c	38;"	d	file:
+TI_CLOSE_PORT	transport/ti3410.c	65;"	d	file:
+TI_DOWNLOAD_MAX_PACKET_SIZE	transport/ti3410.c	115;"	d	file:
+TI_FIRMWARE_BUF_SIZE	transport/ti3410.c	114;"	d	file:
+TI_GET_CONFIG	transport/ti3410.c	62;"	d	file:
+TI_GET_PORT_DEV_INFO	transport/ti3410.c	61;"	d	file:
+TI_GET_PORT_STATUS	transport/ti3410.c	60;"	d	file:
+TI_GET_VERSION	transport/ti3410.c	59;"	d	file:
+TI_I2C_PORT	transport/ti3410.c	48;"	d	file:
+TI_IEEE1284_PORT	transport/ti3410.c	49;"	d	file:
+TI_MCR_DTR	transport/ti3410.c	95;"	d	file:
+TI_MCR_LOOP	transport/ti3410.c	94;"	d	file:
+TI_MCR_RTS	transport/ti3410.c	96;"	d	file:
+TI_OPEN_PORT	transport/ti3410.c	64;"	d	file:
+TI_PIPE_MODE_CONTINOUS	transport/ti3410.c	42;"	d	file:
+TI_PIPE_MODE_MASK	transport/ti3410.c	43;"	d	file:
+TI_PIPE_TIMEOUT_ENABLE	transport/ti3410.c	45;"	d	file:
+TI_PIPE_TIMEOUT_MASK	transport/ti3410.c	44;"	d	file:
+TI_PURGE_INPUT	transport/ti3410.c	56;"	d	file:
+TI_PURGE_OUTPUT	transport/ti3410.c	55;"	d	file:
+TI_PURGE_PORT	transport/ti3410.c	69;"	d	file:
+TI_RAM_PORT	transport/ti3410.c	52;"	d	file:
+TI_READ_DATA	transport/ti3410.c	72;"	d	file:
+TI_REQ_TYPE_CLASS	transport/ti3410.c	73;"	d	file:
+TI_RESET_EXT_DEVICE	transport/ti3410.c	70;"	d	file:
+TI_RW_DATA_ADDR_CODE	transport/ti3410.c	102;"	d	file:
+TI_RW_DATA_ADDR_DSP	transport/ti3410.c	106;"	d	file:
+TI_RW_DATA_ADDR_FLASH	transport/ti3410.c	105;"	d	file:
+TI_RW_DATA_ADDR_GPIO	transport/ti3410.c	103;"	d	file:
+TI_RW_DATA_ADDR_I2C	transport/ti3410.c	104;"	d	file:
+TI_RW_DATA_ADDR_IDATA	transport/ti3410.c	100;"	d	file:
+TI_RW_DATA_ADDR_SFR	transport/ti3410.c	99;"	d	file:
+TI_RW_DATA_ADDR_XDATA	transport/ti3410.c	101;"	d	file:
+TI_RW_DATA_BYTE	transport/ti3410.c	109;"	d	file:
+TI_RW_DATA_DOUBLE_WORD	transport/ti3410.c	111;"	d	file:
+TI_RW_DATA_UNSPECIFIED	transport/ti3410.c	108;"	d	file:
+TI_RW_DATA_WORD	transport/ti3410.c	110;"	d	file:
+TI_SET_CONFIG	transport/ti3410.c	63;"	d	file:
+TI_START_PORT	transport/ti3410.c	66;"	d	file:
+TI_STOP_PORT	transport/ti3410.c	67;"	d	file:
+TI_TEST_PORT	transport/ti3410.c	68;"	d	file:
+TI_TRANSFER_TIMEOUT	transport/ti3410.c	113;"	d	file:
+TI_UART1_PORT	transport/ti3410.c	50;"	d	file:
+TI_UART2_PORT	transport/ti3410.c	51;"	d	file:
+TI_UART_1_5_STOP_BITS	transport/ti3410.c	90;"	d	file:
+TI_UART_1_STOP_BITS	transport/ti3410.c	89;"	d	file:
+TI_UART_2_STOP_BITS	transport/ti3410.c	91;"	d	file:
+TI_UART_5_DATA_BITS	transport/ti3410.c	76;"	d	file:
+TI_UART_6_DATA_BITS	transport/ti3410.c	77;"	d	file:
+TI_UART_7_DATA_BITS	transport/ti3410.c	78;"	d	file:
+TI_UART_8_DATA_BITS	transport/ti3410.c	79;"	d	file:
+TI_UART_EVEN_PARITY	transport/ti3410.c	84;"	d	file:
+TI_UART_MARK_PARITY	transport/ti3410.c	85;"	d	file:
+TI_UART_NO_PARITY	transport/ti3410.c	82;"	d	file:
+TI_UART_ODD_PARITY	transport/ti3410.c	83;"	d	file:
+TI_UART_SPACE_PARITY	transport/ti3410.c	86;"	d	file:
+TI_WRITE_DATA	transport/ti3410.c	71;"	d	file:
+TMS	drivers/jtdev.c	64;"	d	file:
+TRANSPORT_H_	transport/transport.h	20;"	d
+TRANSPORT_MODEM_DTR	transport/transport.h	/^	TRANSPORT_MODEM_DTR = 0x01,$/;"	e	enum:__anon43
+TRANSPORT_MODEM_RTS	transport/transport.h	/^	TRANSPORT_MODEM_RTS = 0x02$/;"	e	enum:__anon43
+TX_BSL_VERSION	drivers/flash_bsl.c	98;"	d	file:
+TX_BUFFER_SIZE	drivers/flash_bsl.c	99;"	d	file:
+TX_DATA_BLOCK	drivers/flash_bsl.c	97;"	d	file:
+TrigerMask	drivers/tilib_defs.h	/^		WORD TrigerMask;$/;"	m	struct:DEVICE_T::__anon45
+ULONG	drivers/tilib_defs.h	/^typedef unsigned long ULONG;$/;"	t
+UNAME_O	Makefile	/^UNAME_O := $(shell sh -c 'uname -o 2> \/dev\/null')$/;"	m
+UNAME_S	Makefile	/^UNAME_S := $(shell sh -c 'uname -s')$/;"	m
+UNLOCK_BSL_MODE	drivers/tilib_defs.h	/^	UNLOCK_BSL_MODE =11,$/;"	e	enum:CONFIG_MODE
+UNLOCK_LOCK_INFO	drivers/flash_bsl.c	93;"	d	file:
+UPDATE_STATUS_MESSAGES	drivers/tilib_defs.h	/^typedef enum UPDATE_STATUS_MESSAGES {$/;"	g
+UPDATE_STATUS_MESSAGES_t	drivers/tilib_defs.h	/^} UPDATE_STATUS_MESSAGES_t;$/;"	t	typeref:enum:UPDATE_STATUS_MESSAGES
+USBUTIL_H_	util/usbutil.h	20;"	d
+USB_CONFIG	transport/ftdi.c	34;"	d	file:
+USB_FDL_INTERFACE	transport/ti3410.c	132;"	d	file:
+USB_FDL_OUT_EP	transport/ti3410.c	133;"	d	file:
+USB_FET_INTERFACE	transport/ti3410.c	127;"	d	file:
+USB_FET_INTERFACE_CLASS	transport/rf2500.c	53;"	d	file:
+USB_FET_INT_EP	transport/ti3410.c	130;"	d	file:
+USB_FET_IN_EP	transport/rf2500.c	55;"	d	file:
+USB_FET_IN_EP	transport/ti3410.c	128;"	d	file:
+USB_FET_OUT_EP	transport/rf2500.c	56;"	d	file:
+USB_FET_OUT_EP	transport/ti3410.c	129;"	d	file:
+USB_FET_PRODUCT	transport/rf2500.c	52;"	d	file:
+USB_FET_PRODUCT	transport/ti3410.c	125;"	d	file:
+USB_FET_VENDOR	transport/rf2500.c	51;"	d	file:
+USB_FET_VENDOR	transport/ti3410.c	124;"	d	file:
+USB_INTERFACE	transport/ftdi.c	33;"	d	file:
+UTIL_H_	util/util.h	20;"	d
+V1_INTERFACE_CLASS	transport/cp210x.c	51;"	d	file:
+V1_IN_EP	transport/cp210x.c	52;"	d	file:
+V1_OUT_EP	transport/cp210x.c	53;"	d	file:
+VCC_RESET	drivers/tilib_defs.h	/^	VCC_RESET   = (1 << 2), \/**< Cycle Vcc (i.e., a "power on") reset *\/$/;"	e	enum:RESET_METHOD
+VECTOR_AT	util/vector.h	61;"	d
+VECTOR_H_	util/vector.h	20;"	d
+VECTOR_PTR	util/vector.h	62;"	d
+VERIFICATION_MODE	drivers/tilib_defs.h	/^        VERIFICATION_MODE = 0,$/;"	e	enum:CONFIG_MODE
+VERIFY	ui/flatfile.c	/^	VERIFY$/;"	e	enum:operation	file:
+VER_DEF_CURRENT	formats/elf_format.h	814;"	d
+VER_DEF_NONE	formats/elf_format.h	813;"	d
+VER_DEF_NUM	formats/elf_format.h	815;"	d
+VER_FLG_BASE	formats/elf_format.h	818;"	d
+VER_FLG_WEAK	formats/elf_format.h	819;"	d
+VER_FLG_WEAK	formats/elf_format.h	898;"	d
+VER_NDX_ELIMINATE	formats/elf_format.h	825;"	d
+VER_NDX_GLOBAL	formats/elf_format.h	823;"	d
+VER_NDX_LOCAL	formats/elf_format.h	822;"	d
+VER_NDX_LORESERVE	formats/elf_format.h	824;"	d
+VER_NEED_CURRENT	formats/elf_format.h	871;"	d
+VER_NEED_NONE	formats/elf_format.h	870;"	d
+VER_NEED_NUM	formats/elf_format.h	872;"	d
+WDTCNTCL	simio/simio_wdt.c	35;"	d	file:
+WDTCTL_ADDR	drivers/sim.c	40;"	d	file:
+WDTHOLD	simio/simio_wdt.c	39;"	d	file:
+WDTIE	simio/simio_wdt.c	43;"	d	file:
+WDTIFG	simio/simio_wdt.c	47;"	d	file:
+WDTIS0	simio/simio_wdt.c	32;"	d	file:
+WDTIS1	simio/simio_wdt.c	33;"	d	file:
+WDTNMI	simio/simio_wdt.c	37;"	d	file:
+WDTNMIES	simio/simio_wdt.c	38;"	d	file:
+WDTNMI_MASK	drivers/sim.c	48;"	d	file:
+WDTPW	simio/simio_wdt.c	40;"	d	file:
+WDTSSEL	simio/simio_wdt.c	34;"	d	file:
+WDTTMSEL	simio/simio_wdt.c	36;"	d	file:
+WORD	drivers/tilib_defs.h	/^typedef uint16_t WORD;$/;"	t
+WRITE	drivers/tilib_defs.h	/^	WRITE = 0,$/;"	e	enum:READ_WRITE
+WRITE_EXTERNAL_MEMORY	drivers/tilib_defs.h	/^	WRITE_EXTERNAL_MEMORY = 13,$/;"	e	enum:CONFIG_MODE
+XOUT	drivers/jtdev.c	66;"	d	file:
+_ELF_H	formats/elf_format.h	22;"	d
+a_type	formats/elf_format.h	/^  uint32_t a_type;		\/* Entry type *\/$/;"	m	struct:__anon27
+a_type	formats/elf_format.h	/^  uint64_t a_type;		\/* Entry type *\/$/;"	m	struct:__anon29
+a_un	formats/elf_format.h	/^    } a_un;$/;"	m	struct:__anon27	typeref:union:__anon27::__anon28
+a_un	formats/elf_format.h	/^    } a_un;$/;"	m	struct:__anon29	typeref:union:__anon29::__anon30
+a_val	formats/elf_format.h	/^      uint32_t a_val;		\/* Integer value *\/$/;"	m	union:__anon27::__anon28
+a_val	formats/elf_format.h	/^      uint64_t a_val;		\/* Integer value *\/$/;"	m	union:__anon29::__anon30
+ack_interrupt	simio/simio_device.h	/^	void (*ack_interrupt)(struct simio_device *dev, int irq);$/;"	m	struct:simio_class
+aclk_counter	simio/simio.c	/^static int aclk_counter;$/;"	v	file:
+active_fperm	drivers/fet_core.c	/^	fperm_t				active_fperm;$/;"	m	struct:fet_device	file:
+active_fperm	drivers/tilib.c	/^	fperm_t			active_fperm;$/;"	m	struct:tilib_device	file:
+add_child	drivers/sim.c	/^void add_child(search_node *parent_node, search_node *new_node)$/;"	f
+add_fet_device	ui/main.c	/^static int add_fet_device(void *user_data, const struct fet_db_record *r)$/;"	f	file:
+add_fet_olimex_device	ui/main.c	/^static int add_fet_olimex_device(void *user_data, const char *name)$/;"	f	file:
+add_history	ui/input_console.c	69;"	d	file:
+add_index	util/dis.c	/^static address_t add_index(address_t reg_base, uint16_t index)$/;"	f	file:
+add_irq_edges	ui/rtools.c	/^static int add_irq_edges(address_t offset, address_t len, uint8_t *memory,$/;"	f	file:
+add_nodes_from_edges	ui/rtools.c	/^static int add_nodes_from_edges(struct call_graph *graph)$/;"	f	file:
+add_symbol	ui/power.c	/^static int add_symbol(void *user_data, const char *name, address_t offset)$/;"	f	file:
+add_symbol_nodes	ui/rtools.c	/^static int add_symbol_nodes(void *user_data, const char *name,$/;"	f	file:
+addbrk	drivers/device.c	/^static int addbrk(device_t dev, address_t addr, device_bptype_t type)$/;"	f	file:
+addr	drivers/device.h	/^	address_t		addr;$/;"	m	struct:device_breakpoint
+addr	formats/binfile.h	/^	address_t		addr;$/;"	m	struct:binfile_chunk
+addr	simio/simio_tracer.c	/^	address_t		addr;$/;"	m	struct:event	file:
+addr	ui/devcmd.c	/^	address_t       addr;$/;"	m	struct:hexout_data	file:
+addr	ui/power.c	/^	address_t		addr;$/;"	m	struct:profile_rec	file:
+addr	util/prog.h	/^	address_t       addr;$/;"	m	struct:prog_data
+addr	util/stab.c	/^	address_t      addr;$/;"	m	struct:addr_key	file:
+addr_exp_data	util/expr.c	/^static int addr_exp_data(struct addr_exp_state *s, const char *text)$/;"	f	file:
+addr_exp_finish	util/expr.c	/^static int addr_exp_finish(struct addr_exp_state *s, address_t *ret)$/;"	f	file:
+addr_exp_op	util/expr.c	/^static int addr_exp_op(struct addr_exp_state *s, char op)$/;"	f	file:
+addr_exp_pop	util/expr.c	/^static int addr_exp_pop(struct addr_exp_state *s)$/;"	f	file:
+addr_exp_state	util/expr.c	/^struct addr_exp_state {$/;"	s	file:
+addr_key	util/stab.c	/^struct addr_key {$/;"	s	file:
+addr_key_compare	util/stab.c	/^static int addr_key_compare(const void *left, const void *right)$/;"	f	file:
+addr_key_init	util/stab.c	/^static void addr_key_init(struct addr_key *key, address_t addr,$/;"	f	file:
+addr_key_zero	util/stab.c	/^static const struct addr_key addr_key_zero = {$/;"	v	typeref:struct:addr_key	file:
+addr_table_def	util/stab.c	/^static const struct btree_def addr_table_def = {$/;"	v	typeref:struct:btree_def	file:
+address_t	util/util.h	/^typedef uint32_t address_t;$/;"	t
+alias	ui/aliasdb.c	/^struct alias {$/;"	s	file:
+alias_list	ui/aliasdb.c	/^static struct vector alias_list = {$/;"	v	typeref:struct:vector	file:
+allocate_page	util/btree.c	/^static struct btree_page *allocate_page(btree_t bt, int height)$/;"	f	file:
+alt_config	ui/main.c	/^	const char		*alt_config;$/;"	m	struct:cmdline_args	file:
+ansi_apply	util/output.c	/^static int ansi_apply(int old_state, int code)$/;"	f	file:
+ansi_mode	util/output.c	/^	int		ansi_mode;$/;"	m	struct:linebuf	file:
+app	drivers/goodfet.c	/^	uint8_t		app;$/;"	m	struct:packet	file:
+argc	drivers/fet_proto.h	/^	int				argc;$/;"	m	struct:fet_proto
+argv	drivers/fet_proto.h	/^	uint32_t			argv[FET_PROTO_MAX_PARAMS];$/;"	m	struct:fet_proto
+async_exit	ui/input_async.c	/^static void async_exit(void) { }$/;"	f	file:
+async_init	ui/input_async.c	/^static int async_init(void)$/;"	f	file:
+async_prompt_abort	ui/input_async.c	/^static int async_prompt_abort(const char *message)$/;"	f	file:
+async_read_command	ui/input_async.c	/^static int async_read_command(char *buf, int max_len)$/;"	f	file:
+base	drivers/bsl.c	/^	struct device   base;$/;"	m	struct:bsl_device	typeref:struct:bsl_device::device	file:
+base	drivers/fet_core.c	/^	struct device                   base;$/;"	m	struct:fet_device	typeref:struct:fet_device::device	file:
+base	drivers/flash_bsl.c	/^	struct device   base;$/;"	m	struct:flash_bsl_device	typeref:struct:flash_bsl_device::device	file:
+base	drivers/gdbc.c	/^	struct device			base;$/;"	m	struct:gdb_client	typeref:struct:gdb_client::device	file:
+base	drivers/goodfet.c	/^	struct device		base;$/;"	m	struct:goodfet	typeref:struct:goodfet::device	file:
+base	drivers/pif.c	/^  struct device		base;$/;"	m	struct:pif_device	typeref:struct:pif_device::device	file:
+base	drivers/sim.c	/^	struct device           base;$/;"	m	struct:sim_device	typeref:struct:sim_device::device	file:
+base	drivers/tilib.c	/^	struct device		base;$/;"	m	struct:tilib_device	typeref:struct:tilib_device::device	file:
+base	simio/simio_console.c	/^	struct simio_device	base;$/;"	m	struct:console	typeref:struct:console::simio_device	file:
+base	simio/simio_gpio.c	/^	struct simio_device	base;$/;"	m	struct:gpio	typeref:struct:gpio::simio_device	file:
+base	simio/simio_hwmult.c	/^	struct simio_device		base;$/;"	m	struct:hwmult	typeref:struct:hwmult::simio_device	file:
+base	simio/simio_timer.c	/^	struct simio_device	base;$/;"	m	struct:timer	typeref:struct:timer::simio_device	file:
+base	simio/simio_tracer.c	/^	struct simio_device	base;$/;"	m	struct:tracer	typeref:struct:tracer::simio_device	file:
+base	simio/simio_wdt.c	/^	struct simio_device		base;$/;"	m	struct:wdt	typeref:struct:wdt::simio_device	file:
+base	transport/cdc_acm.c	/^	struct transport        base;$/;"	m	struct:cdc_acm_transport	typeref:struct:cdc_acm_transport::transport	file:
+base	transport/comport.c	/^	struct transport        base;$/;"	m	struct:comport_transport	typeref:struct:comport_transport::transport	file:
+base	transport/cp210x.c	/^	struct transport        base;$/;"	m	struct:cp210x_transport	typeref:struct:cp210x_transport::transport	file:
+base	transport/ftdi.c	/^	struct transport        base;$/;"	m	struct:ftdi_transport	typeref:struct:ftdi_transport::transport	file:
+base	transport/rf2500.c	/^	struct transport        base;$/;"	m	struct:rf2500_transport	typeref:struct:rf2500_transport::transport	file:
+base	transport/ti3410.c	/^	struct transport        base;$/;"	m	struct:ti3410_transport	typeref:struct:ti3410_transport::transport	file:
+base64_encode	util/util.c	/^int base64_encode(const uint8_t *src, int len, char *dst, int max_len)$/;"	f
+base64_encoded_size	util/util.h	/^static inline int base64_encoded_size(int decoded_size)$/;"	f
+base_addr	simio/simio_console.c	/^	address_t		base_addr;$/;"	m	struct:console	file:
+base_addr	simio/simio_gpio.c	/^	address_t		base_addr;$/;"	m	struct:gpio	file:
+base_addr	simio/simio_timer.c	/^	address_t		base_addr;$/;"	m	struct:timer	file:
+baud_rate	util/sport.c	/^struct baud_rate {$/;"	s	file:
+baud_rates	util/sport.c	/^static const struct baud_rate baud_rates[] = {$/;"	v	typeref:struct:baud_rate	file:
+binfile_chunk	formats/binfile.h	/^struct binfile_chunk {$/;"	s
+binfile_extract	formats/binfile.c	/^int binfile_extract(FILE *in, binfile_imgcb_t cb, void *user_data)$/;"	f
+binfile_imgcb_t	formats/binfile.h	/^typedef int (*binfile_imgcb_t)(void *user_data,$/;"	t
+binfile_info	formats/binfile.c	/^int binfile_info(FILE *in)$/;"	f
+binfile_syms	formats/binfile.c	/^int binfile_syms(FILE *in)$/;"	f
+boolean	util/opdb.h	/^	int             boolean;$/;"	m	union:opdb_value
+bpAccess	drivers/tilib_defs.h	/^	BpAccess_t        bpAccess;$/;"	m	struct:BREAKPOINT
+bpAction	drivers/tilib_defs.h	/^	BpAction_t        bpAction;$/;"	m	struct:BREAKPOINT
+bpCondAccess	drivers/tilib_defs.h	/^	BpAccess_t        bpCondAccess;$/;"	m	struct:BREAKPOINT
+bpCondOperat	drivers/tilib_defs.h	/^	BpOperat_t        bpCondOperat;$/;"	m	struct:BREAKPOINT
+bpCondition	drivers/tilib_defs.h	/^	BpCondition_t     bpCondition;$/;"	m	struct:BREAKPOINT
+bpMode	drivers/tilib_defs.h	/^	BpMode_t          bpMode;$/;"	m	struct:BREAKPOINT
+bpOperat	drivers/tilib_defs.h	/^	BpOperat_t        bpOperat;$/;"	m	struct:BREAKPOINT
+bpRangeAction	drivers/tilib_defs.h	/^	BpRangeAction_t   bpRangeAction;$/;"	m	struct:BREAKPOINT
+bpType	drivers/tilib_defs.h	/^	BpType_t          bpType;$/;"	m	struct:BREAKPOINT
+bp_handles	drivers/tilib.c	/^	uint16_t		bp_handles[DEVICE_MAX_BREAKPOINTS];$/;"	m	struct:tilib_device	file:
+bp_send	drivers/gdbc.c	/^static int bp_send(struct gdb_data *gdb, int c, address_t addr,$/;"	f	file:
+branches	util/btree.h	/^	int             branches;$/;"	m	struct:btree_def
+breakpoints	drivers/device.h	/^	struct device_breakpoint breakpoints[DEVICE_MAX_BREAKPOINTS];$/;"	m	struct:device	typeref:struct:device::device_breakpoint
+bslEnd	drivers/tilib_defs.h	/^		WORD  bslEnd;$/;"	m	struct:DEVICE_T::__anon45
+bslStart	drivers/tilib_defs.h	/^		WORD  bslStart;$/;"	m	struct:DEVICE_T::__anon45
+bsl_ack	drivers/bsl.c	/^static int bsl_ack(struct bsl_device *dev)$/;"	f	file:
+bsl_ctl	drivers/bsl.c	/^static int bsl_ctl(device_t dev_base, device_ctl_t type)$/;"	f	file:
+bsl_destroy	drivers/bsl.c	/^static void bsl_destroy(device_t dev_base)$/;"	f	file:
+bsl_device	drivers/bsl.c	/^struct bsl_device {$/;"	s	file:
+bsl_erase	drivers/bsl.c	/^static int bsl_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+bsl_getregs	drivers/bsl.c	/^static int bsl_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+bsl_open	drivers/bsl.c	/^static device_t bsl_open(const struct device_args *args)$/;"	f	file:
+bsl_poll	drivers/bsl.c	/^static device_status_t bsl_poll(device_t dev_base)$/;"	f	file:
+bsl_readmem	drivers/bsl.c	/^static int bsl_readmem(device_t dev_base,$/;"	f	file:
+bsl_setregs	drivers/bsl.c	/^static int bsl_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+bsl_sync	drivers/bsl.c	/^static int bsl_sync(struct bsl_device *dev)$/;"	f	file:
+bsl_writemem	drivers/bsl.c	/^static int bsl_writemem(device_t dev_base,$/;"	f	file:
+bsl_xfer	drivers/bsl.c	/^static int bsl_xfer(struct bsl_device *dev,$/;"	f	file:
+btree	util/btree.c	/^struct btree {$/;"	s	file:
+btree_alloc	util/btree.c	/^btree_t btree_alloc(const struct btree_def *def)$/;"	f
+btree_clear	util/btree.c	/^void btree_clear(btree_t bt)$/;"	f
+btree_compare_t	util/btree.h	/^typedef int (*btree_compare_t)(const void *left, const void *right);$/;"	t
+btree_def	util/btree.h	/^struct btree_def {$/;"	s
+btree_delete	util/btree.c	/^int btree_delete(btree_t bt, const void *key)$/;"	f
+btree_free	util/btree.c	/^void btree_free(btree_t bt)$/;"	f
+btree_get	util/btree.c	/^int btree_get(btree_t bt, const void *key, void *data)$/;"	f
+btree_page	util/btree.c	/^struct btree_page {$/;"	s	file:
+btree_put	util/btree.c	/^int btree_put(btree_t bt, const void *key, const void *data)$/;"	f
+btree_select	util/btree.c	/^int btree_select(btree_t bt, const void *key, btree_selmode_t mode,$/;"	f
+btree_selmode_t	util/btree.h	/^} btree_selmode_t;$/;"	t	typeref:enum:__anon60
+btree_t	util/btree.h	/^typedef struct btree *btree_t;$/;"	t	typeref:struct:btree
+buf	transport/rf2500.c	/^	uint8_t                 buf[64];$/;"	m	struct:rf2500_transport	file:
+buf	transport/ti3410.c	/^	uint8_t		buf[TI_FIRMWARE_BUF_SIZE];$/;"	m	struct:firmware	file:
+buf	ui/devcmd.c	/^	uint8_t         buf[16];$/;"	m	struct:hexout_data	file:
+buf	ui/gdb.c	/^	char    buf[GDB_MAX_XFER];$/;"	m	struct:monitor_buf	file:
+buf	util/output.c	/^	char		buf[LINEBUF_SIZE];$/;"	m	struct:linebuf	file:
+buf	util/prog.h	/^	uint8_t         buf[PROG_BUFSIZE];$/;"	m	struct:prog_data
+buffer	drivers/tilib_defs.h	/^	CHAR buffer[110];$/;"	m	union:DEVICE_T
+buffer	simio/simio_console.c	/^	char			buffer[256];$/;"	m	struct:console	file:
+buffer_offset	simio/simio_console.c	/^	unsigned		buffer_offset;$/;"	m	struct:console	file:
+build_inverse	ui/rtools.c	/^static int build_inverse(struct call_graph *graph)$/;"	f	file:
+calc_checksum	drivers/fet_proto.c	/^static uint16_t calc_checksum(uint8_t *cp, int len)$/;"	f	file:
+calc_iv	simio/simio_timer.c	/^static uint16_t calc_iv(struct timer *tr, int update)$/;"	f	file:
+call_graph	ui/rtools.c	/^struct call_graph {$/;"	s	file:
+can_push	util/expr.c	/^static int can_push(struct addr_exp_state *s, char op)$/;"	f	file:
+capacity	util/vector.h	/^	int             capacity;$/;"	m	struct:vector
+capture_data	util/output.c	/^static void *capture_data;$/;"	v	file:
+capture_end	util/output.c	/^void capture_end(void)$/;"	f
+capture_func	util/output.c	/^static capture_func_t capture_func;$/;"	v	file:
+capture_func_t	util/output.h	/^typedef void (*capture_func_t)(void *user_data, const char *text);$/;"	t
+capture_start	util/output.c	/^void capture_start(capture_func_t func, void *data)$/;"	f
+ccrs	simio/simio_timer.c	/^	uint16_t		ccrs[MAX_CCRS];$/;"	m	struct:timer	file:
+cdc_acm_class	transport/cdc_acm.c	/^static const struct transport_class cdc_acm_class = {$/;"	v	typeref:struct:transport_class	file:
+cdc_acm_open	transport/cdc_acm.c	/^transport_t cdc_acm_open(const char *devpath, const char *requested_serial,$/;"	f
+cdc_acm_transport	transport/cdc_acm.c	/^struct cdc_acm_transport {$/;"	s	file:
+cg_edge	ui/rtools.c	/^struct cg_edge {$/;"	s	file:
+cg_node	ui/rtools.c	/^struct cg_node {$/;"	s	file:
+cgraph_destroy	ui/rtools.c	/^static void cgraph_destroy(struct call_graph *graph)$/;"	f	file:
+cgraph_func_info	ui/rtools.c	/^static void cgraph_func_info(struct call_graph *graph, address_t addr)$/;"	f	file:
+cgraph_init	ui/rtools.c	/^static int cgraph_init(address_t offset, address_t len, uint8_t *memory,$/;"	f	file:
+cgraph_summary	ui/rtools.c	/^static void cgraph_summary(struct call_graph *graph)$/;"	f	file:
+charge	ui/power.c	/^	unsigned long long	charge;$/;"	m	struct:profile_rec	file:
+check	formats/binfile.c	/^	int (*check)(FILE *in);$/;"	m	struct:file_format	file:
+check_btree	util/btree.c	/^static void check_btree(btree_t bt)$/;"	f	file:
+check_btree	util/btree.c	122;"	d	file:
+check_interrupt	simio/simio_device.h	/^	int (*check_interrupt)(struct simio_device *dev);$/;"	m	struct:simio_class
+check_ok	drivers/gdbc.c	/^static int check_ok(struct gdb_data *gdb)$/;"	f	file:
+check_page	util/btree.c	/^static void check_page(struct btree_page *p,$/;"	f	file:
+class_db	simio/simio.c	/^static const struct simio_class *const class_db[] = {$/;"	v	file:
+clockControl	drivers/tilib_defs.h	/^		WORD  clockControl;$/;"	m	struct:DEVICE_T::__anon45
+clock_input	simio/simio_timer.c	/^	int			clock_input;$/;"	m	struct:timer	file:
+closesocket	util/sockets.h	37;"	d
+cmd	ui/aliasdb.c	/^	const char		*cmd;$/;"	m	struct:recurse_list	file:
+cmd_add	simio/simio.c	/^static int cmd_add(char **arg_text)$/;"	f	file:
+cmd_alias	ui/aliasdb.c	/^int cmd_alias(char **arg)$/;"	f
+cmd_break	ui/devcmd.c	/^int cmd_break(char **arg)$/;"	f
+cmd_cgraph	ui/rtools.c	/^int cmd_cgraph(char **arg)$/;"	f
+cmd_classes	simio/simio.c	/^static int cmd_classes(char **arg_text)$/;"	f	file:
+cmd_config	simio/simio.c	/^static int cmd_config(char **arg_text)$/;"	f	file:
+cmd_del	simio/simio.c	/^static int cmd_del(char **arg_text)$/;"	f	file:
+cmd_delbreak	ui/devcmd.c	/^int cmd_delbreak(char **arg)$/;"	f
+cmd_devices	simio/simio.c	/^static int cmd_devices(char **arg_text)$/;"	f	file:
+cmd_dis	ui/devcmd.c	/^int cmd_dis(char **arg)$/;"	f
+cmd_erase	ui/devcmd.c	/^int cmd_erase(char **arg)$/;"	f
+cmd_eval	ui/sym.c	/^int cmd_eval(char **arg)$/;"	f
+cmd_exit	ui/stdcmd.c	/^int cmd_exit(char **arg)$/;"	f
+cmd_fill	ui/devcmd.c	/^int cmd_fill(char **arg)$/;"	f
+cmd_gdb	ui/gdb.c	/^int cmd_gdb(char **arg)$/;"	f
+cmd_help	simio/simio.c	/^static int cmd_help(char **arg_text)$/;"	f	file:
+cmd_help	ui/stdcmd.c	/^int cmd_help(char **arg)$/;"	f
+cmd_hexout	ui/devcmd.c	/^int cmd_hexout(char **arg)$/;"	f
+cmd_info	simio/simio.c	/^static int cmd_info(char **arg_text)$/;"	f	file:
+cmd_intsc	ui/devcmd.c	/^int cmd_intsc(char **arg)$/;"	f
+cmd_isearch	ui/rtools.c	/^int cmd_isearch(char **arg)$/;"	f
+cmd_load	ui/devcmd.c	/^int cmd_load(char **arg)$/;"	f
+cmd_load_raw	ui/flatfile.c	/^int cmd_load_raw(char **arg)$/;"	f
+cmd_md	ui/devcmd.c	/^int cmd_md(char **arg)$/;"	f
+cmd_mw	ui/devcmd.c	/^int cmd_mw(char **arg)$/;"	f
+cmd_opt	ui/stdcmd.c	/^int cmd_opt(char **arg)$/;"	f
+cmd_power	ui/power.c	/^int cmd_power(char **arg)$/;"	f
+cmd_prog	ui/devcmd.c	/^int cmd_prog(char **arg)$/;"	f
+cmd_prog_feed	ui/devcmd.c	/^static int cmd_prog_feed(void *user_data, const struct binfile_chunk *ch)$/;"	f	file:
+cmd_read	ui/stdcmd.c	/^int cmd_read(char **arg)$/;"	f
+cmd_regs	ui/devcmd.c	/^int cmd_regs(char **arg)$/;"	f
+cmd_reset	ui/devcmd.c	/^int cmd_reset(char **arg)$/;"	f
+cmd_run	ui/devcmd.c	/^int cmd_run(char **arg)$/;"	f
+cmd_save_raw	ui/flatfile.c	/^int cmd_save_raw(char **arg)$/;"	f
+cmd_search	ui/devcmd.c	/^int cmd_search(char **arg)$/;"	f
+cmd_set	ui/devcmd.c	/^int cmd_set(char **arg)$/;"	f
+cmd_setbreak	ui/devcmd.c	/^int cmd_setbreak(char **arg)$/;"	f
+cmd_setwatch	ui/devcmd.c	/^int cmd_setwatch(char **arg)$/;"	f
+cmd_setwatch_r	ui/devcmd.c	/^int cmd_setwatch_r(char **arg)$/;"	f
+cmd_setwatch_w	ui/devcmd.c	/^int cmd_setwatch_w(char **arg)$/;"	f
+cmd_simio	simio/simio.c	/^int cmd_simio(char **arg_text)$/;"	f
+cmd_step	ui/devcmd.c	/^int cmd_step(char **arg)$/;"	f
+cmd_sym	ui/sym.c	/^int cmd_sym(char **arg)$/;"	f
+cmd_sym_del	ui/sym.c	/^static int cmd_sym_del(char **arg)$/;"	f	file:
+cmd_sym_find	ui/sym.c	/^static int cmd_sym_find(char **arg)$/;"	f	file:
+cmd_sym_load_add	ui/sym.c	/^static int cmd_sym_load_add(int clear, char **arg)$/;"	f	file:
+cmd_sym_rename	ui/sym.c	/^static int cmd_sym_rename(char **arg)$/;"	f	file:
+cmd_sym_savemap	ui/sym.c	/^static int cmd_sym_savemap(char **arg)$/;"	f	file:
+cmd_verify	ui/devcmd.c	/^int cmd_verify(char **arg)$/;"	f
+cmd_verify_raw	ui/flatfile.c	/^int cmd_verify_raw(char **arg)$/;"	f
+cmddb_enum	ui/cmddb.c	/^int cmddb_enum(cmddb_enum_func_t func, void *user_data)$/;"	f
+cmddb_enum_func_t	ui/cmddb.h	/^typedef int (*cmddb_enum_func_t)(void *user_data,$/;"	t
+cmddb_func_t	ui/cmddb.h	/^typedef int (*cmddb_func_t)(char **arg);$/;"	t
+cmddb_get	ui/cmddb.c	/^int cmddb_get(const char *name, struct cmddb_record *ret)$/;"	f
+cmddb_record	ui/cmddb.h	/^struct cmddb_record {$/;"	s
+cmdline_args	ui/main.c	/^struct cmdline_args {$/;"	s	file:
+cmp_alias	ui/aliasdb.c	/^static int cmp_alias(const void *a, const void *b)$/;"	f	file:
+cmp_branch_by_dst	ui/rtools.c	/^static int cmp_branch_by_dst(const void *a, const void *b)$/;"	f	file:
+cmp_branch_by_src	ui/rtools.c	/^static int cmp_branch_by_src(const void *a, const void *b)$/;"	f	file:
+cmp_by_addr	ui/power.c	/^static int cmp_by_addr(const void *a, const void *b)$/;"	f	file:
+cmp_by_charge_rev	ui/power.c	/^static int cmp_by_charge_rev(const void *a, const void *b)$/;"	f	file:
+cmp_node	ui/rtools.c	/^static int cmp_node(const void *a, const void *b)$/;"	f	file:
+code	util/sport.c	/^	int             code;$/;"	m	struct:baud_rate	file:
+coff_check	formats/coff.c	/^int coff_check(FILE *in)$/;"	f
+coff_extract	formats/coff.c	/^int coff_extract(FILE *in, binfile_imgcb_t cb, void *user_data)$/;"	f
+coff_header	formats/coff.c	/^struct coff_header {$/;"	s	file:
+coff_syms	formats/coff.c	/^int coff_syms(FILE *in)$/;"	f
+command_code	drivers/fet_proto.h	/^	int				command_code;$/;"	m	struct:fet_proto
+commands	ui/cmddb.c	/^const struct cmddb_record commands[] = {$/;"	v	typeref:struct:cmddb_record
+compare	util/btree.h	/^	btree_compare_t compare;$/;"	m	struct:btree_def
+comport_open	transport/comport.c	/^transport_t comport_open(const char *device, int baud_rate)$/;"	f
+comport_transport	transport/comport.c	/^static const struct transport_class comport_transport = {$/;"	v	typeref:struct:transport_class	file:
+comport_transport	transport/comport.c	/^struct comport_transport {$/;"	s	file:
+cond	ui/input_async.c	/^	thread_cond_t		cond;$/;"	m	struct:mailbox	file:
+config	simio/simio_device.h	/^	int (*config)(struct simio_device *dev, const char *param,$/;"	m	struct:simio_class
+config_addr	simio/simio_console.c	/^static int config_addr(address_t *addr, char **arg_text)$/;"	f	file:
+config_addr	simio/simio_gpio.c	/^static int config_addr(address_t *addr, char **arg_text)$/;"	f	file:
+config_addr	simio/simio_timer.c	/^static int config_addr(address_t *addr, char **arg_text)$/;"	f	file:
+config_channel	simio/simio_gpio.c	/^static int config_channel(struct gpio *g, char **arg_text)$/;"	f	file:
+config_channel	simio/simio_timer.c	/^static int config_channel(struct timer *tr, char **arg_text)$/;"	f	file:
+config_irq	simio/simio_gpio.c	/^static int config_irq(int *irq, char **arg_text)$/;"	f	file:
+config_irq	simio/simio_timer.c	/^static int config_irq(int *irq, char **arg_text)$/;"	f	file:
+configure_ftdi	transport/ftdi.c	/^int configure_ftdi(struct usb_dev_handle *h, int baud_rate)$/;"	f
+configure_port	transport/cdc_acm.c	/^static int configure_port(struct cdc_acm_transport *tr, int baud_rate)$/;"	f	file:
+configure_port	transport/cp210x.c	/^static int configure_port(struct cp210x_transport *tr, int baud_rate)$/;"	f	file:
+connect_to	drivers/gdbc.c	/^static int connect_to(const char *spec)$/;"	f	file:
+console	simio/simio_console.c	/^struct console {$/;"	s	file:
+console_config	simio/simio_console.c	/^static int console_config(struct simio_device *dev,$/;"	f	file:
+console_create	simio/simio_console.c	/^static struct simio_device *console_create(char **arg_text)$/;"	f	file:
+console_destroy	simio/simio_console.c	/^static void console_destroy(struct simio_device *dev)$/;"	f	file:
+console_exit	ui/input_console.c	/^static void console_exit(void) { }$/;"	f	file:
+console_info	simio/simio_console.c	/^static int console_info(struct simio_device *dev)$/;"	f	file:
+console_init	ui/input_console.c	/^static int console_init(void)$/;"	f	file:
+console_prompt_abort	ui/input_console.c	/^static int console_prompt_abort(const char *message)$/;"	f	file:
+console_read_command	ui/input_console.c	/^static int console_read_command(char *out, int max_len)$/;"	f	file:
+console_reset	simio/simio_console.c	/^static void console_reset(struct simio_device *dev)$/;"	f	file:
+console_write_b	simio/simio_console.c	/^static int console_write_b(struct simio_device *dev,$/;"	f	file:
+control_register	drivers/jtdev.h	/^	uint8_t		control_register;$/;"	m	struct:jtdev
+coreIpId	drivers/tilib_defs.h	/^		WORD  coreIpId;$/;"	m	struct:DEVICE_T::__anon45
+count_reg	simio/simio_wdt.c	/^	int				count_reg;$/;"	m	struct:wdt	file:
+counter_t	simio/simio_tracer.c	/^typedef unsigned long long counter_t;$/;"	t	file:
+cp210x_class	transport/cp210x.c	/^static const struct transport_class cp210x_class = {$/;"	v	typeref:struct:transport_class	file:
+cp210x_open	transport/cp210x.c	/^transport_t cp210x_open(const char *devpath, const char *requested_serial,$/;"	f
+cp210x_transport	transport/cp210x.c	/^struct cp210x_transport {$/;"	s	file:
+cpuArch	drivers/tilib_defs.h	/^		BYTE  cpuArch;$/;"	m	struct:DEVICE_T::__anon45
+crc_ccitt	drivers/flash_bsl.c	/^static uint16_t crc_ccitt(const uint8_t *data, int len) {$/;"	f	file:
+crc_selftest	drivers/flash_bsl.c	/^static void crc_selftest(void) {$/;"	f	file:
+create	simio/simio_device.h	/^	struct simio_device *(*create)(char **arg_text);$/;"	m	struct:simio_class	typeref:struct:simio_class::create
+create_interrupt_nodes	drivers/sim.c	/^void create_interrupt_nodes(struct sim_device *dev, search_node *parent_node, interrupt_t type)$/;"	f
+create_node	drivers/sim.c	/^search_node *create_node(interrupt_t type, uint16_t instr_addr, int irq)$/;"	f
+ctl	drivers/device.h	/^	int (*ctl)(device_t dev, device_ctl_t op);$/;"	m	struct:device_class
+ctls	simio/simio_timer.c	/^	uint16_t		ctls[MAX_CCRS];$/;"	m	struct:timer	file:
+ctrlc_check	util/ctrlc.c	/^int ctrlc_check(void)$/;"	f
+ctrlc_clear	util/ctrlc.c	/^void ctrlc_clear(void)$/;"	f
+ctrlc_cs	util/ctrlc.c	/^static CRITICAL_SECTION ctrlc_cs;$/;"	v	file:
+ctrlc_event	util/ctrlc.c	/^static HANDLE ctrlc_event;$/;"	v	file:
+ctrlc_exit	util/ctrlc.c	/^void ctrlc_exit(void)$/;"	f
+ctrlc_flag	util/ctrlc.c	/^static int ctrlc_flag;$/;"	v	file:
+ctrlc_flag	util/ctrlc.c	/^static volatile int ctrlc_flag;$/;"	v	file:
+ctrlc_handler	util/ctrlc.c	/^static WINAPI BOOL ctrlc_handler(DWORD event)$/;"	f	file:
+ctrlc_init	util/ctrlc.c	/^void ctrlc_init(void)$/;"	f
+ctrlc_raise	util/ctrlc.c	/^void ctrlc_raise(void)$/;"	f
+ctrlc_thread	util/ctrlc.c	/^static pthread_t ctrlc_thread;$/;"	v	file:
+ctrlc_win32_event	util/ctrlc.c	/^HANDLE ctrlc_win32_event(void)$/;"	f
+current_head	util/powerbuf.h	/^	unsigned int			current_head;$/;"	m	struct:powerbuf
+current_insn	drivers/sim.c	/^	uint16_t                current_insn;$/;"	m	struct:sim_device	file:
+current_tail	util/powerbuf.h	/^	unsigned int			current_tail;$/;"	m	struct:powerbuf
+current_ua	util/powerbuf.h	/^	unsigned int			*current_ua;$/;"	m	struct:powerbuf
+cursor_first	util/btree.c	/^static void cursor_first(btree_t bt)$/;"	f	file:
+cursor_next	util/btree.c	/^static void cursor_next(btree_t bt)$/;"	f	file:
+cycles	simio/simio_tracer.c	/^	counter_t		cycles[SIMIO_NUM_CLOCKS];$/;"	m	struct:tracer	file:
+d_ptr	formats/elf_format.h	/^      Elf32_Addr d_ptr;			\/* Address value *\/$/;"	m	union:__anon15::__anon16
+d_ptr	formats/elf_format.h	/^      Elf64_Addr d_ptr;			\/* Address value *\/$/;"	m	union:__anon17::__anon18
+d_tag	formats/elf_format.h	/^  Elf32_Sword	d_tag;			\/* Dynamic entry type *\/$/;"	m	struct:__anon15
+d_tag	formats/elf_format.h	/^  Elf64_Sxword	d_tag;			\/* Dynamic entry type *\/$/;"	m	struct:__anon17
+d_un	formats/elf_format.h	/^    } d_un;$/;"	m	struct:__anon15	typeref:union:__anon15::__anon16
+d_un	formats/elf_format.h	/^    } d_un;$/;"	m	struct:__anon17	typeref:union:__anon17::__anon18
+d_val	formats/elf_format.h	/^      Elf32_Word d_val;			\/* Integer value *\/$/;"	m	union:__anon15::__anon16
+d_val	formats/elf_format.h	/^      Elf64_Xword d_val;		\/* Integer value *\/$/;"	m	union:__anon17::__anon18
+data	drivers/fet_proto.h	/^	uint8_t				*data;$/;"	m	struct:fet_proto
+data	drivers/goodfet.c	/^	uint8_t		data[MAX_LEN];$/;"	m	struct:packet	file:
+data	formats/binfile.h	/^	const uint8_t		*data;$/;"	m	struct:binfile_chunk
+data	simio/simio_tracer.c	/^	uint16_t		data;$/;"	m	struct:event	file:
+data_register	drivers/jtdev.h	/^	uint8_t		data_register;$/;"	m	struct:jtdev
+data_size	util/btree.h	/^	int             data_size;$/;"	m	struct:btree_def
+data_stack	util/expr.c	/^	address_t      data_stack[32];$/;"	m	struct:addr_exp_state	file:
+data_stack_size	util/expr.c	/^	int            data_stack_size;$/;"	m	struct:addr_exp_state	file:
+datalen	drivers/fet_proto.h	/^	int				datalen;$/;"	m	struct:fet_proto
+debug_hexdump	util/util.c	/^void debug_hexdump(const char *label, const uint8_t *data, int len)$/;"	f
+decode_00xx	util/dis.c	/^static int decode_00xx(const uint8_t *code, address_t len,$/;"	f	file:
+decode_13xx	util/dis.c	/^static int decode_13xx(const uint8_t *code, address_t len,$/;"	f	file:
+decode_14xx	util/dis.c	/^static int decode_14xx(const uint8_t *code,$/;"	f	file:
+decode_double	util/dis.c	/^static int decode_double(const uint8_t *code, address_t offset,$/;"	f	file:
+decode_jump	util/dis.c	/^static int decode_jump(const uint8_t *code, address_t offset,$/;"	f	file:
+decode_single	util/dis.c	/^static int decode_single(const uint8_t *code, address_t offset,$/;"	f	file:
+def	util/btree.c	/^	const struct btree_def  *def;$/;"	m	struct:btree	typeref:struct:btree::btree_def	file:
+def	util/btree.c	/^	const struct btree_def  *def;$/;"	m	struct:btree_page	typeref:struct:btree_page::btree_def	file:
+defval	util/opdb.h	/^	union opdb_value	defval;$/;"	m	struct:opdb_key	typeref:union:opdb_key::opdb_value
+delay_ms	util/util.c	/^int delay_ms(unsigned int s)$/;"	f
+delay_s	util/util.c	/^int delay_s(unsigned int s)$/;"	f
+delbrk	drivers/device.c	/^static void delbrk(device_t dev, address_t addr, device_bptype_t type)$/;"	f	file:
+delete_item	util/btree.c	/^static void delete_item(struct btree_page *p, int s)$/;"	f	file:
+demangle	util/demangle.c	/^int demangle(const char *raw, char *out, int max_len)$/;"	f
+destroy	drivers/device.h	/^	void (*destroy)(device_t dev);$/;"	m	struct:device_class
+destroy	simio/simio_device.h	/^	void (*destroy)(struct simio_device *dev);$/;"	m	struct:simio_class
+destroy	transport/transport.h	/^	void (*destroy)(transport_t tr);$/;"	m	struct:transport_class
+destroy_device	simio/simio.c	/^static void destroy_device(struct simio_device *dev)$/;"	f	file:
+destroy_page	util/btree.c	/^static void destroy_page(struct btree_page *p)$/;"	f	file:
+dev_id	drivers/device.h	/^	uint8_t				dev_id[3];$/;"	m	struct:device
+devarg	ui/main.c	/^	struct device_args	devarg;$/;"	m	struct:cmdline_args	typeref:struct:cmdline_args::device_args	file:
+device	drivers/device.h	/^struct device {$/;"	s
+deviceIdPtr	drivers/tilib_defs.h	/^		ULONG deviceIdPtr;$/;"	m	struct:DEVICE_T::__anon45
+device_args	drivers/device.h	/^struct device_args {$/;"	s
+device_bptype_t	drivers/device.h	/^} device_bptype_t;$/;"	t	typeref:enum:__anon49
+device_breakpoint	drivers/device.h	/^struct device_breakpoint {$/;"	s
+device_bsl	drivers/bsl.c	/^const struct device_class device_bsl = {$/;"	v	typeref:struct:device_class
+device_class	drivers/device.h	/^struct device_class {$/;"	s
+device_ctl	drivers/device.h	173;"	d
+device_ctl_t	drivers/device.h	/^} device_ctl_t;$/;"	t	typeref:enum:__anon46
+device_default	drivers/device.c	/^device_t device_default;$/;"	v
+device_destroy	drivers/device.h	164;"	d
+device_erase	drivers/device.c	/^int device_erase(device_erase_type_t et, address_t addr)$/;"	f
+device_erase_type_t	drivers/device.h	/^} device_erase_type_t;$/;"	t	typeref:enum:__anon48
+device_flash_bsl	drivers/flash_bsl.c	/^const struct device_class device_flash_bsl = {$/;"	v	typeref:struct:device_class
+device_gdbc	drivers/gdbc.c	/^const struct device_class device_gdbc = {$/;"	v	typeref:struct:device_class
+device_getregs	drivers/device.h	169;"	d
+device_goodfet	drivers/goodfet.c	/^const struct device_class device_goodfet = {$/;"	v	typeref:struct:device_class
+device_help	util/usbutil.c	/^static const char *device_help(const struct usb_device *dev)$/;"	f	file:
+device_id_param	drivers/devicelist.h	/^	uint8_t         device_id_param[9];$/;"	m	struct:device_table
+device_intsc	drivers/device.h	179;"	d
+device_is_fram	drivers/device.c	/^int device_is_fram(device_t dev)$/;"	f
+device_list	simio/simio.c	/^static struct list_node device_list;$/;"	v	typeref:struct:list_node	file:
+device_olimex	drivers/fet.c	/^const struct device_class device_olimex = {$/;"	v	typeref:struct:device_class
+device_olimex_iso	drivers/fet.c	/^const struct device_class device_olimex_iso = {$/;"	v	typeref:struct:device_class
+device_olimex_iso_mk2	drivers/fet.c	/^const struct device_class device_olimex_iso_mk2 = {$/;"	v	typeref:struct:device_class
+device_olimex_v1	drivers/fet.c	/^const struct device_class device_olimex_v1 = {$/;"	v	typeref:struct:device_class
+device_pif	drivers/pif.c	/^const struct device_class device_pif = {$/;"	v	typeref:struct:device_class
+device_poll	drivers/device.h	175;"	d
+device_probe_id	drivers/device.c	/^int device_probe_id(device_t dev)$/;"	f
+device_readmem	drivers/device.h	165;"	d
+device_rf2500	drivers/fet.c	/^const struct device_class device_rf2500 = {$/;"	v	typeref:struct:device_class
+device_search	drivers/device.h	177;"	d
+device_setbrk	drivers/device.c	/^int device_setbrk(device_t dev, int which, int enabled, address_t addr,$/;"	f
+device_setregs	drivers/device.h	171;"	d
+device_sim	drivers/sim.c	/^const struct device_class device_sim = {$/;"	v	typeref:struct:device_class
+device_status_t	drivers/device.h	/^} device_status_t;$/;"	t	typeref:enum:__anon47
+device_t	drivers/device.h	/^typedef struct device *device_t;$/;"	t	typeref:struct:device
+device_table	drivers/devicelist.h	/^struct device_table {$/;"	s
+device_tilib	drivers/tilib.c	/^const struct device_class device_tilib = {$/;"	v	typeref:struct:device_class
+device_type_id	drivers/devicelist.h	/^	uint16_t        device_type_id;$/;"	m	struct:device_table
+device_uif	drivers/fet.c	/^const struct device_class device_uif = {$/;"	v	typeref:struct:device_class
+device_writemem	drivers/device.h	167;"	d
+devicetype_t	drivers/devicelist.h	/^} devicetype_t;$/;"	t	typeref:enum:__anon44
+dis_decode	util/dis.c	/^int dis_decode(const uint8_t *code, address_t offset, address_t len,$/;"	f
+dis_format	util/output_util.c	/^static int dis_format(const struct msp430_instruction *insn)$/;"	f	file:
+dis_opcode_from_name	util/dis.c	/^int dis_opcode_from_name(const char *name)$/;"	f
+dis_opcode_name	util/dis.c	/^const char *dis_opcode_name(msp430_op_t op)$/;"	f
+dis_reg_from_name	util/dis.c	/^int dis_reg_from_name(const char *name)$/;"	f
+dis_reg_name	util/dis.c	/^const char *dis_reg_name(msp430_reg_t reg)$/;"	f
+disassemble	util/output_util.c	/^void disassemble(address_t offset, const uint8_t *data, int length,$/;"	f
+display_option	ui/stdcmd.c	/^static int display_option(void *user_data, const struct opdb_key *key,$/;"	f	file:
+dm_append	util/demangle.c	/^static int dm_append(struct dmbuf *d, const char *text, int len)$/;"	f	file:
+dm_component	util/demangle.c	/^static int dm_component(struct dmbuf *d, const char *text, const char **out)$/;"	f	file:
+dmbuf	util/demangle.c	/^struct dmbuf {$/;"	s	file:
+do_cfg	transport/ftdi.c	/^static int do_cfg(struct usb_dev_handle *handle, const char *what,$/;"	f	file:
+do_cmd_prog	ui/devcmd.c	/^static int do_cmd_prog(char **arg, int prog_flags)$/;"	f	file:
+do_command	ui/reader.c	/^static int do_command(char *arg, int interactive)$/;"	f	file:
+do_configure	drivers/fet_core.c	/^static int do_configure(struct fet_device *dev,$/;"	f	file:
+do_download	transport/ti3410.c	/^static int do_download(struct usb_device *dev, const struct firmware *f)$/;"	f	file:
+do_extract	transport/ti3410.c	/^static int do_extract(void *user_data, const struct binfile_chunk *ch)$/;"	f	file:
+do_findUif	drivers/tilib.c	/^static int do_findUif(struct tilib_device *dev)$/;"	f	file:
+do_flatfile	ui/flatfile.c	/^static int do_flatfile(enum operation op, const char *path, address_t addr, address_t len)$/;"	f	file:
+do_fw_update	drivers/tilib.c	/^static int do_fw_update(struct tilib_device *dev, const char *filename)$/;"	f	file:
+do_halt	drivers/tilib.c	/^static int do_halt(struct tilib_device *dev)$/;"	f	file:
+do_identify	drivers/fet_core.c	/^static int do_identify(struct fet_device *dev, const char *force_id)$/;"	f	file:
+do_init	drivers/tilib.c	/^static int do_init(struct tilib_device *dev, const struct device_args *args)$/;"	f	file:
+do_isearch	ui/rtools.c	/^static int do_isearch(address_t addr, address_t len,$/;"	f	file:
+do_multiply	simio/simio_hwmult.c	/^static void do_multiply(struct hwmult *h)$/;"	f	file:
+do_open_start	transport/ti3410.c	/^static int do_open_start(struct ti3410_transport *tr)$/;"	f	file:
+do_ppwcontrol	drivers/jtdev.c	/^static void do_ppwcontrol(struct jtdev *p)$/;"	f	file:
+do_ppwdata	drivers/jtdev.c	/^static void do_ppwdata(struct jtdev *p)$/;"	f	file:
+do_reset	drivers/gdbc.c	/^static int do_reset(struct gdb_client *dev)$/;"	f	file:
+do_reset	drivers/sim.c	/^static void do_reset(struct sim_device *dev)$/;"	f	file:
+do_run	drivers/fet_core.c	/^static int do_run(struct fet_device *dev, int type)$/;"	f	file:
+do_setbreak	ui/devcmd.c	/^static int do_setbreak(device_bptype_t type, char **arg)$/;"	f	file:
+do_step	drivers/tilib.c	/^static int do_step(struct tilib_device *dev)$/;"	f	file:
+download_firmware	transport/ti3410.c	/^static int download_firmware(struct usb_device *dev)$/;"	f	file:
+driver_name	ui/main.c	/^	const char		*driver_name;$/;"	m	struct:cmdline_args	file:
+driver_table	ui/main.c	/^static const struct device_class *const driver_table[] = {$/;"	v	file:
+dsize	util/dis.h	/^	msp430_dsize_t          dsize;$/;"	m	struct:msp430_instruction
+dst	ui/aliasdb.c	/^	char	dst[256];$/;"	m	struct:alias	file:
+dst	ui/rtools.c	/^	address_t       dst;$/;"	m	struct:cg_edge	file:
+dst_addr	util/dis.h	/^	address_t		dst_addr;$/;"	m	struct:msp430_instruction
+dst_mode	util/dis.h	/^	msp430_amode_t          dst_mode;$/;"	m	struct:msp430_instruction
+dst_reg	util/dis.h	/^	msp430_reg_t            dst_reg;$/;"	m	struct:msp430_instruction
+dump_session_data	ui/power.c	/^static void dump_session_data(powerbuf_t pb, unsigned int s,$/;"	f	file:
+dynload_close	util/dynload.c	/^void dynload_close(dynload_handle_t hnd)$/;"	f
+dynload_error	util/dynload.c	/^const char *dynload_error(void)$/;"	f
+dynload_handle_t	util/dynload.h	/^typedef HMODULE dynload_handle_t;$/;"	t
+dynload_handle_t	util/dynload.h	/^typedef void *dynload_handle_t;$/;"	t
+dynload_open	util/dynload.c	/^dynload_handle_t dynload_open(const char *filename)$/;"	f
+dynload_sym	util/dynload.c	/^void *dynload_sym(dynload_handle_t hnd, const char *name)$/;"	f
+e_ehsize	formats/elf_format.h	/^  Elf32_Half	e_ehsize;		\/* ELF header size in bytes *\/$/;"	m	struct:__anon1
+e_ehsize	formats/elf_format.h	/^  Elf64_Half	e_ehsize;		\/* ELF header size in bytes *\/$/;"	m	struct:__anon2
+e_entry	formats/elf_format.h	/^  Elf32_Addr	e_entry;		\/* Entry point virtual address *\/$/;"	m	struct:__anon1
+e_entry	formats/elf_format.h	/^  Elf64_Addr	e_entry;		\/* Entry point virtual address *\/$/;"	m	struct:__anon2
+e_flags	formats/elf_format.h	/^  Elf32_Word	e_flags;		\/* Processor-specific flags *\/$/;"	m	struct:__anon1
+e_flags	formats/elf_format.h	/^  Elf64_Word	e_flags;		\/* Processor-specific flags *\/$/;"	m	struct:__anon2
+e_ident	formats/elf_format.h	/^  unsigned char	e_ident[EI_NIDENT];	\/* Magic number and other info *\/$/;"	m	struct:__anon1
+e_ident	formats/elf_format.h	/^  unsigned char	e_ident[EI_NIDENT];	\/* Magic number and other info *\/$/;"	m	struct:__anon2
+e_machine	formats/elf_format.h	/^  Elf32_Half	e_machine;		\/* Architecture *\/$/;"	m	struct:__anon1
+e_machine	formats/elf_format.h	/^  Elf64_Half	e_machine;		\/* Architecture *\/$/;"	m	struct:__anon2
+e_phentsize	formats/elf_format.h	/^  Elf32_Half	e_phentsize;		\/* Program header table entry size *\/$/;"	m	struct:__anon1
+e_phentsize	formats/elf_format.h	/^  Elf64_Half	e_phentsize;		\/* Program header table entry size *\/$/;"	m	struct:__anon2
+e_phnum	formats/elf_format.h	/^  Elf32_Half	e_phnum;		\/* Program header table entry count *\/$/;"	m	struct:__anon1
+e_phnum	formats/elf_format.h	/^  Elf64_Half	e_phnum;		\/* Program header table entry count *\/$/;"	m	struct:__anon2
+e_phoff	formats/elf_format.h	/^  Elf32_Off	e_phoff;		\/* Program header table file offset *\/$/;"	m	struct:__anon1
+e_phoff	formats/elf_format.h	/^  Elf64_Off	e_phoff;		\/* Program header table file offset *\/$/;"	m	struct:__anon2
+e_shentsize	formats/elf_format.h	/^  Elf32_Half	e_shentsize;		\/* Section header table entry size *\/$/;"	m	struct:__anon1
+e_shentsize	formats/elf_format.h	/^  Elf64_Half	e_shentsize;		\/* Section header table entry size *\/$/;"	m	struct:__anon2
+e_shnum	formats/elf_format.h	/^  Elf32_Half	e_shnum;		\/* Section header table entry count *\/$/;"	m	struct:__anon1
+e_shnum	formats/elf_format.h	/^  Elf64_Half	e_shnum;		\/* Section header table entry count *\/$/;"	m	struct:__anon2
+e_shoff	formats/elf_format.h	/^  Elf32_Off	e_shoff;		\/* Section header table file offset *\/$/;"	m	struct:__anon1
+e_shoff	formats/elf_format.h	/^  Elf64_Off	e_shoff;		\/* Section header table file offset *\/$/;"	m	struct:__anon2
+e_shstrndx	formats/elf_format.h	/^  Elf32_Half	e_shstrndx;		\/* Section header string table index *\/$/;"	m	struct:__anon1
+e_shstrndx	formats/elf_format.h	/^  Elf64_Half	e_shstrndx;		\/* Section header string table index *\/$/;"	m	struct:__anon2
+e_type	formats/elf_format.h	/^  Elf32_Half	e_type;			\/* Object file type *\/$/;"	m	struct:__anon1
+e_type	formats/elf_format.h	/^  Elf64_Half	e_type;			\/* Object file type *\/$/;"	m	struct:__anon2
+e_version	formats/elf_format.h	/^  Elf32_Word	e_version;		\/* Object file version *\/$/;"	m	struct:__anon1
+e_version	formats/elf_format.h	/^  Elf64_Word	e_version;		\/* Object file version *\/$/;"	m	struct:__anon2
+edge_from	ui/rtools.c	/^	struct vector   edge_from;$/;"	m	struct:call_graph	typeref:struct:call_graph::vector	file:
+edge_to	ui/rtools.c	/^	struct vector   edge_to;$/;"	m	struct:call_graph	typeref:struct:call_graph::vector	file:
+eemVersion	drivers/tilib_defs.h	/^		WORD  eemVersion;$/;"	m	struct:DEVICE_T::__anon45
+elemsize	util/vector.h	/^	int             elemsize;$/;"	m	struct:vector
+elf32_check	formats/elf32.c	/^int elf32_check(FILE *in)$/;"	f
+elf32_extract	formats/elf32.c	/^int elf32_extract(FILE *in, binfile_imgcb_t cb, void *user_data)$/;"	f
+elf32_id	formats/elf32.c	/^static const uint8_t elf32_id[] = {$/;"	v	file:
+elf32_info	formats/elf32.c	/^struct elf32_info {$/;"	s	file:
+elf32_syms	formats/elf32.c	/^int elf32_syms(FILE *in)$/;"	f
+emit_ansi	util/output.c	/^static void emit_ansi(const char *code, int len, int ansi_state, FILE *out)$/;"	f	file:
+emulation	drivers/tilib_defs.h	/^		WORD  emulation;$/;"	m	struct:DEVICE_T::__anon45
+end	ui/sym.c	/^	int     start, end;$/;"	m	struct:rename_record	file:
+endian	drivers/tilib_defs.h	/^		WORD  endian;$/;"	m	struct:DEVICE_T::__anon45
+ensure_room	util/powerbuf.c	/^static void ensure_room(powerbuf_t pb, unsigned int required)$/;"	f	file:
+enter_via_dtr_rts	drivers/flash_bsl.c	/^static int enter_via_dtr_rts(struct flash_bsl_device *dev)$/;"	f	file:
+enter_via_fet	drivers/bsl.c	/^static int enter_via_fet(struct bsl_device *dev)$/;"	f	file:
+entry	drivers/sim.c	/^struct entry {$/;"	s	file:
+entry_delay	drivers/flash_bsl.c	/^static void entry_delay(void)$/;"	f	file:
+erase	drivers/device.h	/^	int (*erase)(device_t dev, device_erase_type_t type,$/;"	m	struct:device_class
+error	drivers/fet_proto.h	/^	int				error;$/;"	m	struct:fet_proto
+error	util/gdb_proto.h	/^	int             error;$/;"	m	struct:gdb_data
+error_save	util/sockets.c	/^static DWORD error_save = 0;$/;"	v	file:
+error_strings	drivers/fet_error.c	/^static const char *error_strings[] =$/;"	v	file:
+event	simio/simio_tracer.c	/^struct event {$/;"	s	file:
+event_fetch	drivers/tilib.c	/^static uint32_t event_fetch(struct tilib_device *dev)$/;"	f	file:
+event_notify	drivers/tilib.c	/^static void event_notify(unsigned int msg_id, unsigned int w_param,$/;"	f	file:
+event_print	simio/simio_tracer.c	/^static void event_print(const struct event *e)$/;"	f	file:
+event_rec	simio/simio_tracer.c	/^static void event_rec(struct tracer *tr, event_type_t what,$/;"	f	file:
+event_type_t	simio/simio_tracer.c	/^} event_type_t;$/;"	t	typeref:enum:__anon64	file:
+exit	ui/input.h	/^	void	(*exit)(void);$/;"	m	struct:input_interface
+exit_via_dtr_rts	drivers/flash_bsl.c	/^static void exit_via_dtr_rts(struct flash_bsl_device *dev)$/;"	f	file:
+expand_tilde	util/util.c	/^char *expand_tilde(const char *path)$/;"	f
+expr_eval	util/expr.c	/^int expr_eval(const char *text, address_t *addr)$/;"	f
+extract	formats/binfile.c	/^	int (*extract)(FILE *in, binfile_imgcb_t cb, void *user_data);$/;"	m	struct:file_format	file:
+failed	drivers/jtdev.h	/^	int		failed;$/;"	m	struct:jtdev
+fcstab	drivers/fet_proto.c	/^static const uint16_t fcstab[256] = {$/;"	v	file:
+feed_line	formats/ihex.c	/^static int feed_line(uint8_t *data, int nbytes, binfile_imgcb_t cb,$/;"	f	file:
+feed_section	formats/elf32.c	/^static int feed_section(struct elf32_info *info,$/;"	f	file:
+fet_buf	drivers/fet_proto.h	/^	uint8_t                         fet_buf[65538];$/;"	m	struct:fet_proto
+fet_ctl	drivers/fet_core.c	/^int fet_ctl(device_t dev_base, device_ctl_t action)$/;"	f
+fet_db	drivers/fet_db.c	/^static const struct fet_db_record fet_db[] = {$/;"	v	typeref:struct:fet_db_record	file:
+fet_db_enum	drivers/fet_db.c	/^int fet_db_enum(fet_db_enum_func_t func, void *user_data)$/;"	f
+fet_db_enum_func_t	drivers/fet_db.h	/^typedef int (*fet_db_enum_func_t)(void *user_data,$/;"	t
+fet_db_find_by_msg28	drivers/fet_db.c	/^const struct fet_db_record *fet_db_find_by_msg28(uint8_t *data, int len)$/;"	f
+fet_db_find_by_name	drivers/fet_db.c	/^const struct fet_db_record *fet_db_find_by_name(const char *name)$/;"	f
+fet_db_get_record	drivers/fet_olimex_db.c	/^const struct fet_olimex_db_record *fet_db_get_record(devicetype_t type)$/;"	f
+fet_db_record	drivers/fet_db.h	/^struct fet_db_record {$/;"	s
+fet_destroy	drivers/fet_core.c	/^void fet_destroy(device_t dev_base)$/;"	f
+fet_device	drivers/fet_core.c	/^struct fet_device {$/;"	s	file:
+fet_erase	drivers/fet_core.c	/^int fet_erase(device_t dev_base, device_erase_type_t type, address_t addr)$/;"	f
+fet_error	drivers/fet_error.c	/^const char *fet_error(int code)$/;"	f
+fet_flags	drivers/fet_core.c	/^	int				fet_flags;$/;"	m	struct:fet_device	file:
+fet_getregs	drivers/fet_core.c	/^int fet_getregs(device_t dev_base, address_t *regs)$/;"	f
+fet_len	drivers/fet_proto.h	/^	int                             fet_len;$/;"	m	struct:fet_proto
+fet_olimex_db	drivers/fet_olimex_db.c	/^static const struct fet_olimex_db_record fet_olimex_db[] = {$/;"	v	typeref:struct:fet_olimex_db_record	file:
+fet_olimex_db_enum	drivers/fet_olimex_db.c	/^int fet_olimex_db_enum(fet_olimex_db_enum_func_t func, void *user_data)$/;"	f
+fet_olimex_db_enum_func_t	drivers/fet_olimex_db.h	/^typedef int (*fet_olimex_db_enum_func_t)(void *user_data, const char *name);$/;"	t
+fet_olimex_db_find_by_name	drivers/fet_olimex_db.c	/^int fet_olimex_db_find_by_name(const char *name)$/;"	f
+fet_olimex_db_identify	drivers/fet_olimex_db.c	/^int fet_olimex_db_identify(const uint8_t *data)$/;"	f
+fet_olimex_db_index_to_type	drivers/fet_olimex_db.c	/^devicetype_t fet_olimex_db_index_to_type(int indx)$/;"	f
+fet_olimex_db_record	drivers/fet_olimex_db.h	/^struct fet_olimex_db_record {$/;"	s
+fet_open	drivers/fet_core.c	/^device_t fet_open(const struct device_args *args,$/;"	f
+fet_open_olimex	drivers/fet.c	/^static device_t fet_open_olimex(const struct device_args *args)$/;"	f	file:
+fet_open_olimex_iso	drivers/fet.c	/^static device_t fet_open_olimex_iso(const struct device_args *args)$/;"	f	file:
+fet_open_olimex_iso_mk2	drivers/fet.c	/^static device_t fet_open_olimex_iso_mk2(const struct device_args *args)$/;"	f	file:
+fet_open_olimex_v1	drivers/fet.c	/^static device_t fet_open_olimex_v1(const struct device_args *args)$/;"	f	file:
+fet_open_rf2500	drivers/fet.c	/^static device_t fet_open_rf2500(const struct device_args *args)$/;"	f	file:
+fet_open_uif	drivers/fet.c	/^static device_t fet_open_uif(const struct device_args *args)$/;"	f	file:
+fet_poll	drivers/fet_core.c	/^device_status_t fet_poll(device_t dev_base)$/;"	f
+fet_proto	drivers/fet_proto.h	/^struct fet_proto {$/;"	s
+fet_proto_init	drivers/fet_proto.c	/^void fet_proto_init(struct fet_proto *dev, transport_t transport,$/;"	f
+fet_proto_xfer	drivers/fet_proto.c	/^int fet_proto_xfer(struct fet_proto *dev,$/;"	f
+fet_readmem	drivers/fet_core.c	/^int fet_readmem(device_t dev_base, address_t addr, uint8_t *buffer,$/;"	f
+fet_setregs	drivers/fet_core.c	/^int fet_setregs(device_t dev_base, const address_t *regs)$/;"	f
+fet_writemem	drivers/fet_core.c	/^int fet_writemem(device_t dev_base, address_t addr,$/;"	f
+fetch_operand	drivers/sim.c	/^static int fetch_operand(struct sim_device *dev,$/;"	f	file:
+fetch_reply	drivers/bsl.c	/^static int fetch_reply(struct bsl_device *dev)$/;"	f	file:
+file	ui/devcmd.c	/^	FILE            *file;$/;"	m	struct:hexout_data	file:
+file_ehdr	formats/elf32.c	/^	Elf32_Ehdr              file_ehdr;$/;"	m	struct:elf32_info	file:
+file_format	formats/binfile.c	/^struct file_format {$/;"	s	file:
+file_phdrs	formats/elf32.c	/^	Elf32_Phdr              file_phdrs[MAX_PHDRS];$/;"	m	struct:elf32_info	file:
+file_shdrs	formats/elf32.c	/^	Elf32_Shdr              file_shdrs[MAX_SHDRS];$/;"	m	struct:elf32_info	file:
+file_to_phys	formats/elf32.c	/^static uint32_t file_to_phys(struct elf32_info *info, uint32_t v)$/;"	f	file:
+find_alias	ui/aliasdb.c	/^static struct alias *find_alias(const char *name)$/;"	f	file:
+find_cgens	util/dis.c	/^static void find_cgens(struct msp430_instruction *insn)$/;"	f	file:
+find_class	simio/simio.c	/^static const struct simio_class *find_class(const char *name)$/;"	f	file:
+find_device	simio/simio.c	/^static struct simio_device *find_device(const char *name)$/;"	f	file:
+find_emulated_ops	util/dis.c	/^static void find_emulated_ops(struct msp430_instruction *insn)$/;"	f	file:
+find_firmware	transport/ti3410.c	/^static FILE *find_firmware(void)$/;"	f	file:
+find_interface	transport/cdc_acm.c	/^static int find_interface(struct cdc_acm_transport *tr,$/;"	f	file:
+find_key_le	util/btree.c	/^static int find_key_le(const struct btree_page *p, const void *key)$/;"	f	file:
+find_mab_ge	util/powerbuf.c	/^static int find_mab_ge(powerbuf_t pb, address_t mab)$/;"	f	file:
+find_possible_edges	ui/rtools.c	/^static int find_possible_edges(int offset, int len, uint8_t *memory,$/;"	f	file:
+find_renames	ui/sym.c	/^static int find_renames(void *user_data, const char *name, address_t value)$/;"	f	file:
+find_shdr	formats/elf32.c	/^static Elf32_Shdr *find_shdr(struct elf32_info *info, Elf32_Word type)$/;"	f	file:
+find_sym	ui/sym.c	/^static int find_sym(void *user_data, const char *name, address_t value)$/;"	f	file:
+firmware	transport/ti3410.c	/^struct firmware {$/;"	s	file:
+flags	drivers/device.h	/^	int			flags;$/;"	m	struct:device_args
+flags	drivers/device.h	/^	int			flags;$/;"	m	struct:device_breakpoint
+flags	formats/coff.c	/^	uint16_t        flags;$/;"	m	struct:coff_header	file:
+flags	ui/main.c	/^	int			flags;$/;"	m	struct:cmdline_args	file:
+flags	ui/rtools.c	/^	int                             flags;$/;"	m	struct:isearch_query	file:
+flags	util/prog.h	/^	int		flags;$/;"	m	struct:prog_data
+flash_bsl_ctl	drivers/flash_bsl.c	/^static int flash_bsl_ctl(device_t dev_base, device_ctl_t type)$/;"	f	file:
+flash_bsl_destroy	drivers/flash_bsl.c	/^static void flash_bsl_destroy(device_t dev_base)$/;"	f	file:
+flash_bsl_device	drivers/flash_bsl.c	/^struct flash_bsl_device {$/;"	s	file:
+flash_bsl_erase	drivers/flash_bsl.c	/^static int flash_bsl_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+flash_bsl_getregs	drivers/flash_bsl.c	/^static int flash_bsl_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+flash_bsl_open	drivers/flash_bsl.c	/^static device_t flash_bsl_open(const struct device_args *args)$/;"	f	file:
+flash_bsl_perror	drivers/flash_bsl.c	/^static void flash_bsl_perror(uint8_t code) {$/;"	f	file:
+flash_bsl_poll	drivers/flash_bsl.c	/^static device_status_t flash_bsl_poll(device_t dev_base)$/;"	f	file:
+flash_bsl_readmem	drivers/flash_bsl.c	/^static int flash_bsl_readmem(device_t dev_base,$/;"	f	file:
+flash_bsl_recv	drivers/flash_bsl.c	/^static int flash_bsl_recv(struct flash_bsl_device *dev,$/;"	f	file:
+flash_bsl_send	drivers/flash_bsl.c	/^static int flash_bsl_send(struct flash_bsl_device *dev,$/;"	f	file:
+flash_bsl_setregs	drivers/flash_bsl.c	/^static int flash_bsl_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+flash_bsl_unlock	drivers/flash_bsl.c	/^static int flash_bsl_unlock(struct flash_bsl_device *dev)$/;"	f	file:
+flash_bsl_writemem	drivers/flash_bsl.c	/^static int flash_bsl_writemem(device_t dev_base,$/;"	f	file:
+flush	transport/transport.h	/^	int (*flush)(transport_t tr);$/;"	m	struct:transport_class
+forced_chip_id	drivers/device.h	/^	const char		*forced_chip_id;$/;"	m	struct:device_args
+format_addr	util/output_util.c	/^static int format_addr(msp430_amode_t amode, address_t addr)$/;"	f	file:
+format_operand	util/output_util.c	/^static int format_operand(msp430_amode_t amode, address_t addr,$/;"	f	file:
+format_reg	util/output_util.c	/^static int format_reg(msp430_amode_t amode, msp430_reg_t reg)$/;"	f	file:
+formats	formats/binfile.c	/^static const struct file_format formats[] = {$/;"	v	typeref:struct:file_format	file:
+fperm_t	util/opdb.h	/^} fperm_t;$/;"	t	typeref:enum:__anon62
+ftdi_class	transport/ftdi.c	/^static const struct transport_class ftdi_class = {$/;"	v	typeref:struct:transport_class	file:
+ftdi_open	transport/ftdi.c	/^transport_t ftdi_open(const char *devpath,$/;"	f
+ftdi_transport	transport/ftdi.c	/^struct ftdi_transport {$/;"	s	file:
+func	ui/cmddb.h	/^        cmddb_func_t            func;$/;"	m	struct:cmddb_record
+fw_progress	drivers/tilib.c	/^static void fw_progress(unsigned int msg_id, unsigned long w_param,$/;"	f	file:
+gdb	drivers/gdbc.c	/^	struct gdb_data			gdb;$/;"	m	struct:gdb_client	typeref:struct:gdb_client::gdb_data	file:
+gdb_client	drivers/gdbc.c	/^struct gdb_client {$/;"	s	file:
+gdb_data	util/gdb_proto.h	/^struct gdb_data {$/;"	s
+gdb_flush	util/gdb_proto.c	/^static int gdb_flush(struct gdb_data *data)$/;"	f	file:
+gdb_flush_ack	util/gdb_proto.c	/^int gdb_flush_ack(struct gdb_data *data)$/;"	f
+gdb_getc	util/gdb_proto.c	/^int gdb_getc(struct gdb_data *data)$/;"	f
+gdb_init	util/gdb_proto.c	/^void gdb_init(struct gdb_data *data, int sock)$/;"	f
+gdb_packet_end	util/gdb_proto.c	/^void gdb_packet_end(struct gdb_data *data)$/;"	f
+gdb_packet_start	util/gdb_proto.c	/^void gdb_packet_start(struct gdb_data *data)$/;"	f
+gdb_peek	util/gdb_proto.c	/^int gdb_peek(struct gdb_data *data, int timeout_ms)$/;"	f
+gdb_printf	util/gdb_proto.c	/^void gdb_printf(struct gdb_data *data, const char *fmt, ...)$/;"	f
+gdb_read	util/gdb_proto.c	/^static int gdb_read(struct gdb_data *data, int timeout_ms)$/;"	f	file:
+gdb_read_packet	util/gdb_proto.c	/^int gdb_read_packet(struct gdb_data *data, char *buf)$/;"	f
+gdb_reader_loop	ui/gdb.c	/^static void gdb_reader_loop(struct gdb_data *data)$/;"	f	file:
+gdb_send	util/gdb_proto.c	/^int gdb_send(struct gdb_data *data, const char *msg)$/;"	f
+gdb_send_empty_threadlist	ui/gdb.c	/^static int gdb_send_empty_threadlist(struct gdb_data *data)$/;"	f	file:
+gdb_send_supported	ui/gdb.c	/^static int gdb_send_supported(struct gdb_data *data)$/;"	f	file:
+gdb_server	ui/gdb.c	/^static int gdb_server(int port)$/;"	f	file:
+gdbc_ctl	drivers/gdbc.c	/^static int gdbc_ctl(device_t dev_base, device_ctl_t op)$/;"	f	file:
+gdbc_destroy	drivers/gdbc.c	/^static void gdbc_destroy(device_t dev_base)$/;"	f	file:
+gdbc_erase	drivers/gdbc.c	/^static int gdbc_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+gdbc_getregs	drivers/gdbc.c	/^static int gdbc_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+gdbc_open	drivers/gdbc.c	/^static device_t gdbc_open(const struct device_args *args)$/;"	f	file:
+gdbc_poll	drivers/gdbc.c	/^static device_status_t gdbc_poll(device_t dev_base)$/;"	f	file:
+gdbc_readmem	drivers/gdbc.c	/^static int gdbc_readmem(device_t dev_base, address_t addr,$/;"	f	file:
+gdbc_setregs	drivers/gdbc.c	/^static int gdbc_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+gdbc_writemem	drivers/gdbc.c	/^static int gdbc_writemem(device_t dev_base, address_t addr,$/;"	f	file:
+get_adjusted_block_size	drivers/fet_core.c	/^static int get_adjusted_block_size(void)$/;"	f	file:
+get_all_funcs	drivers/tilib.c	/^static int get_all_funcs(struct tilib_device *dev)$/;"	f	file:
+get_arg	util/util.c	/^char *get_arg(char **text)$/;"	f
+get_func	drivers/tilib.c	/^static void *get_func(dynload_handle_t hnd, const char *name)$/;"	f	file:
+get_next_instr	drivers/sim.c	/^address_t get_next_instr(struct sim_device *dev)$/;"	f
+get_xfer_size	drivers/gdbc.c	/^static int get_xfer_size(void)$/;"	f	file:
+getregs	drivers/device.h	/^	int (*getregs)(device_t dev, address_t *regs);$/;"	m	struct:device_class
+go_down	simio/simio_timer.c	/^	int			go_down;$/;"	m	struct:timer	file:
+goodfet	drivers/goodfet.c	/^struct goodfet {$/;"	s	file:
+goodfet_ctl	drivers/goodfet.c	/^static int goodfet_ctl(device_t dev_base, device_ctl_t type)$/;"	f	file:
+goodfet_destroy	drivers/goodfet.c	/^static void goodfet_destroy(device_t dev_base)$/;"	f	file:
+goodfet_erase	drivers/goodfet.c	/^static int goodfet_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+goodfet_getregs	drivers/goodfet.c	/^static int goodfet_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+goodfet_halt	drivers/goodfet.c	/^static int goodfet_halt(struct goodfet *gc)$/;"	f	file:
+goodfet_open	drivers/goodfet.c	/^static device_t goodfet_open(const struct device_args *args)$/;"	f	file:
+goodfet_poll	drivers/goodfet.c	/^static device_status_t goodfet_poll(device_t dev_base)$/;"	f	file:
+goodfet_readmem	drivers/goodfet.c	/^static int goodfet_readmem(device_t dev_base, address_t addr,$/;"	f	file:
+goodfet_reset	drivers/goodfet.c	/^static int goodfet_reset(struct goodfet *gc)$/;"	f	file:
+goodfet_run	drivers/goodfet.c	/^static int goodfet_run(struct goodfet *gc)$/;"	f	file:
+goodfet_setregs	drivers/goodfet.c	/^static int goodfet_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+goodfet_writemem	drivers/goodfet.c	/^static int goodfet_writemem(device_t dev_base, address_t addr,$/;"	f	file:
+gpio	simio/simio_gpio.c	/^struct gpio {$/;"	s	file:
+gpio_check_interrupt	simio/simio_gpio.c	/^static int gpio_check_interrupt(struct simio_device *dev)$/;"	f	file:
+gpio_config	simio/simio_gpio.c	/^static int gpio_config(struct simio_device *dev,$/;"	f	file:
+gpio_create	simio/simio_gpio.c	/^static struct simio_device *gpio_create(char **arg_text)$/;"	f	file:
+gpio_destroy	simio/simio_gpio.c	/^static void gpio_destroy(struct simio_device *dev)$/;"	f	file:
+gpio_info	simio/simio_gpio.c	/^static int gpio_info(struct simio_device *dev)$/;"	f	file:
+gpio_read_b	simio/simio_gpio.c	/^static int gpio_read_b(struct simio_device *dev,$/;"	f	file:
+gpio_reset	simio/simio_gpio.c	/^static void gpio_reset(struct simio_device *dev)$/;"	f	file:
+gpio_write_b	simio/simio_gpio.c	/^static int gpio_write_b(struct simio_device *dev,$/;"	f	file:
+gt_bytes	formats/elf_format.h	/^      Elf32_Word gt_bytes;		\/* This many bytes would be used *\/$/;"	m	struct:__anon35::__anon37
+gt_current_g_value	formats/elf_format.h	/^      Elf32_Word gt_current_g_value;	\/* -G value used for compilation *\/$/;"	m	struct:__anon35::__anon36
+gt_entry	formats/elf_format.h	/^    } gt_entry;				\/* Subsequent entries in section *\/$/;"	m	union:__anon35	typeref:struct:__anon35::__anon37
+gt_g_value	formats/elf_format.h	/^      Elf32_Word gt_g_value;		\/* If this value were used for -G *\/$/;"	m	struct:__anon35::__anon37
+gt_header	formats/elf_format.h	/^    } gt_header;			\/* First entry in section *\/$/;"	m	union:__anon35	typeref:struct:__anon35::__anon36
+gt_unused	formats/elf_format.h	/^      Elf32_Word gt_unused;		\/* Not used *\/$/;"	m	struct:__anon35::__anon36
+handle	transport/cdc_acm.c	/^	struct usb_dev_handle   *handle;$/;"	m	struct:cdc_acm_transport	typeref:struct:cdc_acm_transport::usb_dev_handle	file:
+handle	transport/cp210x.c	/^	struct usb_dev_handle   *handle;$/;"	m	struct:cp210x_transport	typeref:struct:cp210x_transport::usb_dev_handle	file:
+handle	transport/ftdi.c	/^	struct usb_dev_handle   *handle;$/;"	m	struct:ftdi_transport	typeref:struct:ftdi_transport::usb_dev_handle	file:
+handle	transport/rf2500.c	/^	struct usb_dev_handle   *handle;$/;"	m	struct:rf2500_transport	typeref:struct:rf2500_transport::usb_dev_handle	file:
+handle_command	ui/input_async.c	/^static void handle_command(const char *text)$/;"	f	file:
+handle_line	util/output.c	/^static void handle_line(const char *text, FILE *out, char sigil)$/;"	f	file:
+handle_special	ui/input_async.c	/^static void handle_special(const char *text)$/;"	f	file:
+hasTestVpp	drivers/tilib_defs.h	/^		WORD  hasTestVpp;$/;"	m	struct:DEVICE_T::__anon45
+have_erased	util/prog.h	/^	int             have_erased;$/;"	m	struct:prog_data
+head	simio/simio_tracer.c	/^	int			head;$/;"	m	struct:tracer	file:
+head	util/gdb_proto.h	/^	int             head;$/;"	m	struct:gdb_data
+heap_extract	util/powerbuf.c	/^static void heap_extract(powerbuf_t pb, int num_samples)$/;"	f	file:
+heapify	util/powerbuf.c	/^static void heapify(powerbuf_t pb, int num_samples)$/;"	f	file:
+height	util/btree.c	/^	int                     height;$/;"	m	struct:btree_page	file:
+help	drivers/device.h	/^	const char		*help;$/;"	m	struct:device_class
+help	simio/simio_device.h	/^	const char          *help;$/;"	m	struct:simio_class
+help	ui/cmddb.h	/^	const char		*help;$/;"	m	struct:cmddb_record
+help	util/opdb.h	/^	const char		*help;$/;"	m	struct:opdb_key
+hexdump	util/output_util.c	/^void hexdump(address_t addr, const uint8_t *data, int data_len)$/;"	f
+hexout_data	ui/devcmd.c	/^struct hexout_data {$/;"	s	file:
+hexout_feed	ui/devcmd.c	/^static int hexout_feed(struct hexout_data *hexout,$/;"	f	file:
+hexout_flush	ui/devcmd.c	/^static int hexout_flush(struct hexout_data *hexout)$/;"	f	file:
+hexout_start	ui/devcmd.c	/^static int hexout_start(struct hexout_data *hexout, const char *filename)$/;"	f	file:
+hexout_write	ui/devcmd.c	/^static int hexout_write(FILE *out, uint8_t type, int len, uint16_t addr,$/;"	f	file:
+hexval	util/util.c	/^int hexval(int c)$/;"	f
+history	simio/simio_tracer.c	/^	struct event		*history;$/;"	m	struct:tracer	typeref:struct:tracer::event	file:
+hnd	drivers/tilib.c	/^	dynload_handle_t	hnd;$/;"	m	struct:tilib_device	file:
+hnd	transport/ti3410.c	/^	struct usb_dev_handle	*hnd;$/;"	m	struct:ti3410_transport	typeref:struct:ti3410_transport::usb_dev_handle	file:
+hwmult	simio/simio_hwmult.c	/^struct hwmult {$/;"	s	file:
+hwmult_create	simio/simio_hwmult.c	/^struct simio_device *hwmult_create(char **arg_text)$/;"	f
+hwmult_destroy	simio/simio_hwmult.c	/^static void hwmult_destroy(struct simio_device *dev)$/;"	f	file:
+hwmult_read	simio/simio_hwmult.c	/^static int hwmult_read(struct simio_device *dev, address_t addr, uint16_t *data)$/;"	f	file:
+hwmult_write	simio/simio_hwmult.c	/^static int hwmult_write(struct simio_device *dev, address_t addr, uint16_t data)$/;"	f	file:
+hwp_flags1	formats/elf_format.h	/^  Elf32_Word hwp_flags1;	\/* Extra flags.  *\/$/;"	m	struct:__anon40
+hwp_flags2	formats/elf_format.h	/^  Elf32_Word hwp_flags2;	\/* Extra flags.  *\/$/;"	m	struct:__anon40
+id	drivers/tilib_defs.h	/^		WORD  id;$/;"	m	struct:DEVICE_T::__anon45
+identify	formats/binfile.c	/^static const struct file_format *identify(FILE *in)$/;"	f	file:
+identify_new	drivers/fet_core.c	/^static int identify_new(struct fet_device *dev, const char *force_id)$/;"	f	file:
+identify_old	drivers/fet_core.c	/^static int identify_old(struct fet_device *dev)$/;"	f	file:
+identify_olimex	drivers/fet_core.c	/^static int identify_olimex(struct fet_device *dev, const char *force_id)$/;"	f	file:
+ihex_check	formats/ihex.c	/^int ihex_check(FILE *in)$/;"	f
+ihex_extract	formats/ihex.c	/^int ihex_extract(FILE *in, binfile_imgcb_t cb, void *user_data)$/;"	f
+in_ep	transport/cdc_acm.c	/^	int			in_ep;$/;"	m	struct:cdc_acm_transport	file:
+in_reader_loop	ui/reader.c	/^static int in_reader_loop;$/;"	v	file:
+increment_bv	drivers/sim.c	/^int increment_bv(	uint64_t *bv, 	\/* bit vector to increment *\/ $/;"	f
+info	formats/elf_format.h	/^  Elf32_Word info;		\/* Kind-specific information.  *\/$/;"	m	struct:__anon39
+info	simio/simio_device.h	/^	int (*info)(struct simio_device *dev);$/;"	m	struct:simio_class
+infoEnd	drivers/tilib_defs.h	/^		WORD  infoEnd;$/;"	m	struct:DEVICE_T::__anon45
+infoStart	drivers/tilib_defs.h	/^		WORD  infoStart;$/;"	m	struct:DEVICE_T::__anon45
+init	ui/input.h	/^	int	(*init)(void);$/;"	m	struct:input_interface
+init_device	drivers/goodfet.c	/^static int init_device(sport_t fd)$/;"	f	file:
+init_device	drivers/pif.c	/^static int init_device(struct jtdev *p)$/;"	f	file:
+input_async	ui/input_async.c	/^const struct input_interface input_async = {$/;"	v	typeref:struct:input_interface
+input_console	ui/input_console.c	/^const struct input_interface input_console = {$/;"	v	typeref:struct:input_interface
+input_interface	ui/input.h	/^struct input_interface {$/;"	s
+input_module	ui/input.c	/^const struct input_interface *input_module = &input_console;$/;"	v	typeref:struct:input_interface
+inscount	simio/simio_tracer.c	/^	counter_t		inscount;$/;"	m	struct:tracer	file:
+insert_data	util/btree.c	/^static void insert_data(struct btree_page *p, int s,$/;"	f	file:
+insert_ptr	util/btree.c	/^static void insert_ptr(struct btree_page *p, int s,$/;"	f	file:
+insn	ui/rtools.c	/^	struct msp430_instruction       insn;$/;"	m	struct:isearch_query	typeref:struct:isearch_query::msp430_instruction	file:
+instr_addr	drivers/sim.c	/^	uint16_t instr_addr; \/* used only if this is not an interrupt *\/$/;"	m	struct:search_node	file:
+instr_after_jmp	drivers/sim.c	/^uint16_t instr_after_jmp(struct sim_device *dev, uint16_t ins)$/;"	f
+int_number	transport/cdc_acm.c	/^	int                     int_number;$/;"	m	struct:cdc_acm_transport	file:
+int_number	transport/cp210x.c	/^	int                     int_number;$/;"	m	struct:cp210x_transport	file:
+int_number	transport/rf2500.c	/^	int                     int_number;$/;"	m	struct:rf2500_transport	file:
+interrupt_flush	transport/ti3410.c	/^static int interrupt_flush(struct ti3410_transport *tr)$/;"	f	file:
+interrupt_offsets	drivers/sim.c	/^static int interrupt_offsets[INTERRUPT_TOTAL_NUM+1] =$/;"	v	file:
+interrupt_t	drivers/sim.c	/^} interrupt_t;$/;"	t	typeref:enum:__anon50	file:
+interval_shift	drivers/obl.c	/^	int		interval_shift;$/;"	m	struct:progress_meter	file:
+interval_us	util/powerbuf.h	/^	unsigned int			interval_us;$/;"	m	struct:powerbuf
+intsc	drivers/device.h	/^	int (*intsc)(device_t dev_base, address_t vector_addr, address_t sfr_addr, address_t sfr_mask);$/;"	m	struct:device_class
+io_worker	ui/input_async.c	/^static void io_worker(void *thread_arg)$/;"	f	file:
+irq	drivers/sim.c	/^	int irq;$/;"	m	struct:search_node	file:
+irq	simio/simio_gpio.c	/^	int			irq;$/;"	m	struct:gpio	file:
+irq0	simio/simio_timer.c	/^	int			irq0;$/;"	m	struct:timer	file:
+irq1	simio/simio_timer.c	/^	int			irq1;$/;"	m	struct:timer	file:
+irq_request	simio/simio_tracer.c	/^	int			irq_request;$/;"	m	struct:tracer	file:
+is_address_line	formats/titext.c	/^static int is_address_line(const char *text)$/;"	f	file:
+is_data_line	formats/titext.c	/^static int is_data_line(const char *text)$/;"	f	file:
+is_embedded_mode	util/output.c	/^static int is_embedded_mode;$/;"	v	file:
+is_new_olimex	drivers/fet_core.c	/^static int is_new_olimex(const struct fet_device *dev)$/;"	f	file:
+is_running	drivers/gdbc.c	/^	int				is_running;$/;"	m	struct:gdb_client	file:
+is_tail_call	ui/rtools.c	/^	int             is_tail_call;$/;"	m	struct:cg_edge	file:
+isearch_addr	ui/rtools.c	/^static int isearch_addr(const char *term, char **arg,$/;"	f	file:
+isearch_bw	ui/rtools.c	/^static int isearch_bw(const char *term, char **arg,$/;"	f	file:
+isearch_match	ui/rtools.c	/^static int isearch_match(const struct msp430_instruction *insn,$/;"	f	file:
+isearch_mode	ui/rtools.c	/^static int isearch_mode(const char *term, char **arg,$/;"	f	file:
+isearch_opcode	ui/rtools.c	/^static int isearch_opcode(const char *term, char **arg,$/;"	f	file:
+isearch_query	ui/rtools.c	/^struct isearch_query {$/;"	s	file:
+isearch_reg	ui/rtools.c	/^static int isearch_reg(const char *term, char **arg,$/;"	f	file:
+isearch_type	ui/rtools.c	/^static int isearch_type(const char *term, char **arg,$/;"	f	file:
+ishex	util/util.h	/^static inline int ishex(int c)$/;"	f
+itype	util/dis.h	/^	msp430_itype_t          itype;$/;"	m	struct:msp430_instruction
+iv_addr	simio/simio_timer.c	/^	address_t		iv_addr;$/;"	m	struct:timer	file:
+jtag	drivers/pif.c	/^  struct jtdev		jtag;$/;"	m	struct:pif_device	typeref:struct:pif_device::jtdev	file:
+jtagId	drivers/tilib_defs.h	/^		BYTE  jtagId;$/;"	m	struct:DEVICE_T::__anon45
+jtag_chip_id	drivers/jtaglib.c	/^unsigned int jtag_chip_id(struct jtdev *p)$/;"	f
+jtag_dr_shift	drivers/jtaglib.c	/^static unsigned int jtag_dr_shift( struct jtdev *p, unsigned int data )$/;"	f	file:
+jtag_erase_check	drivers/jtaglib.c	/^int jtag_erase_check( struct jtdev *p,$/;"	f
+jtag_erase_flash	drivers/jtaglib.c	/^void jtag_erase_flash( struct jtdev *p, unsigned int erase_mode,$/;"	f
+jtag_execute_puc	drivers/jtaglib.c	/^unsigned int jtag_execute_puc(struct jtdev *p)$/;"	f
+jtag_get_device	drivers/jtaglib.c	/^unsigned int jtag_get_device(struct jtdev *p)$/;"	f
+jtag_halt_cpu	drivers/jtaglib.c	/^static void jtag_halt_cpu(struct jtdev *p)$/;"	f	file:
+jtag_init	drivers/jtaglib.c	/^unsigned int jtag_init (struct jtdev *p)$/;"	f
+jtag_ir_shift	drivers/jtaglib.c	/^static unsigned int jtag_ir_shift(struct jtdev *p, unsigned int instruction)$/;"	f	file:
+jtag_is_fuse_blown	drivers/jtaglib.c	/^int jtag_is_fuse_blown (struct jtdev *p)$/;"	f
+jtag_led_green_off	drivers/jtaglib.c	71;"	d	file:
+jtag_led_green_on	drivers/jtaglib.c	70;"	d	file:
+jtag_led_red_off	drivers/jtaglib.c	73;"	d	file:
+jtag_led_red_on	drivers/jtaglib.c	72;"	d	file:
+jtag_read_mem	drivers/jtaglib.c	/^uint16_t jtag_read_mem( struct jtdev *p,$/;"	f
+jtag_read_mem_quick	drivers/jtaglib.c	/^void jtag_read_mem_quick( struct jtdev *p,$/;"	f
+jtag_read_reg	drivers/jtaglib.c	/^address_t jtag_read_reg( struct jtdev *p, int reg )$/;"	f
+jtag_release_cpu	drivers/jtaglib.c	/^static void jtag_release_cpu(struct jtdev *p)$/;"	f	file:
+jtag_release_device	drivers/jtaglib.c	/^void jtag_release_device( struct jtdev *p, address_t address )$/;"	f
+jtag_reset_tap	drivers/jtaglib.c	/^static void jtag_reset_tap(struct jtdev *p)$/;"	f	file:
+jtag_rst_clr	drivers/jtaglib.c	66;"	d	file:
+jtag_rst_set	drivers/jtaglib.c	65;"	d	file:
+jtag_set_instruction_fetch	drivers/jtaglib.c	/^static int jtag_set_instruction_fetch(struct jtdev *p)$/;"	f	file:
+jtag_shift	drivers/jtaglib.c	/^static unsigned int jtag_shift( struct jtdev *p,$/;"	f	file:
+jtag_tck_clr	drivers/jtaglib.c	60;"	d	file:
+jtag_tck_set	drivers/jtaglib.c	59;"	d	file:
+jtag_tclk_clr	drivers/jtaglib.c	64;"	d	file:
+jtag_tclk_prep	drivers/jtaglib.c	/^static void jtag_tclk_prep (struct jtdev *p)$/;"	f	file:
+jtag_tclk_set	drivers/jtaglib.c	63;"	d	file:
+jtag_tdi_clr	drivers/jtaglib.c	62;"	d	file:
+jtag_tdi_set	drivers/jtaglib.c	61;"	d	file:
+jtag_tms_clr	drivers/jtaglib.c	58;"	d	file:
+jtag_tms_set	drivers/jtaglib.c	57;"	d	file:
+jtag_tst_clr	drivers/jtaglib.c	68;"	d	file:
+jtag_tst_set	drivers/jtaglib.c	67;"	d	file:
+jtag_verify_mem	drivers/jtaglib.c	/^int jtag_verify_mem( struct jtdev *p,$/;"	f
+jtag_verify_psa	drivers/jtaglib.c	/^static int jtag_verify_psa( struct jtdev *p,$/;"	f	file:
+jtag_write_flash	drivers/jtaglib.c	/^void jtag_write_flash( struct jtdev *p,$/;"	f
+jtag_write_mem	drivers/jtaglib.c	/^void jtag_write_mem( struct jtdev *p,$/;"	f
+jtag_write_mem_quick	drivers/jtaglib.c	/^void jtag_write_mem_quick( struct jtdev *p,$/;"	f
+jtag_write_reg	drivers/jtaglib.c	/^void jtag_write_reg( struct jtdev *p, int reg, address_t value )$/;"	f
+jtdev	drivers/jtdev.h	/^struct jtdev {$/;"	s
+jtdev_close	drivers/jtdev.c	/^void jtdev_close(struct jtdev *p) { }$/;"	f
+jtdev_close	drivers/jtdev.c	/^void jtdev_close(struct jtdev *p)$/;"	f
+jtdev_connect	drivers/jtdev.c	/^void jtdev_connect(struct jtdev *p) { }$/;"	f
+jtdev_connect	drivers/jtdev.c	/^void jtdev_connect(struct jtdev *p)$/;"	f
+jtdev_led_green	drivers/jtdev.c	/^void jtdev_led_green(struct jtdev *p, int out) { }$/;"	f
+jtdev_led_green	drivers/jtdev.c	/^void jtdev_led_green(struct jtdev *p, int out)$/;"	f
+jtdev_led_red	drivers/jtdev.c	/^void jtdev_led_red(struct jtdev *p, int out) { }$/;"	f
+jtdev_led_red	drivers/jtdev.c	/^void jtdev_led_red(struct jtdev *p, int out)$/;"	f
+jtdev_open	drivers/jtdev.c	/^int jtdev_open(struct jtdev *p, const char *device)$/;"	f
+jtdev_power_off	drivers/jtdev.c	/^void jtdev_power_off(struct jtdev *p) { }$/;"	f
+jtdev_power_off	drivers/jtdev.c	/^void jtdev_power_off(struct jtdev *p)$/;"	f
+jtdev_power_on	drivers/jtdev.c	/^void jtdev_power_on(struct jtdev *p) { }$/;"	f
+jtdev_power_on	drivers/jtdev.c	/^void jtdev_power_on(struct jtdev *p)$/;"	f
+jtdev_release	drivers/jtdev.c	/^void jtdev_release(struct jtdev *p) { }$/;"	f
+jtdev_release	drivers/jtdev.c	/^void jtdev_release(struct jtdev *p)$/;"	f
+jtdev_rst	drivers/jtdev.c	/^void jtdev_rst(struct jtdev *p, int out) { }$/;"	f
+jtdev_rst	drivers/jtdev.c	/^void jtdev_rst(struct jtdev *p, int out)$/;"	f
+jtdev_tck	drivers/jtdev.c	/^void jtdev_tck(struct jtdev *p, int out) { }$/;"	f
+jtdev_tck	drivers/jtdev.c	/^void jtdev_tck(struct jtdev *p, int out)$/;"	f
+jtdev_tclk	drivers/jtdev.c	/^void jtdev_tclk(struct jtdev *p, int out) { }$/;"	f
+jtdev_tclk	drivers/jtdev.c	/^void jtdev_tclk(struct jtdev *p, int out)$/;"	f
+jtdev_tclk_get	drivers/jtdev.c	/^int jtdev_tclk_get(struct jtdev *p) { return 0; }$/;"	f
+jtdev_tclk_get	drivers/jtdev.c	/^int jtdev_tclk_get(struct jtdev *p)$/;"	f
+jtdev_tclk_strobe	drivers/jtdev.c	/^void jtdev_tclk_strobe(struct jtdev *p, unsigned int count) { }$/;"	f
+jtdev_tclk_strobe	drivers/jtdev.c	/^void jtdev_tclk_strobe(struct jtdev *p, unsigned int count)$/;"	f
+jtdev_tdi	drivers/jtdev.c	/^void jtdev_tdi(struct jtdev *p, int out) { }$/;"	f
+jtdev_tdi	drivers/jtdev.c	/^void jtdev_tdi(struct jtdev *p, int out)$/;"	f
+jtdev_tdo_get	drivers/jtdev.c	/^int jtdev_tdo_get(struct jtdev *p) { return 0; }$/;"	f
+jtdev_tdo_get	drivers/jtdev.c	/^int jtdev_tdo_get(struct jtdev *p)$/;"	f
+jtdev_tms	drivers/jtdev.c	/^void jtdev_tms(struct jtdev *p, int out) { }$/;"	f
+jtdev_tms	drivers/jtdev.c	/^void jtdev_tms(struct jtdev *p, int out)$/;"	f
+jtdev_tst	drivers/jtdev.c	/^void jtdev_tst(struct jtdev *p, int out) { }$/;"	f
+jtdev_tst	drivers/jtdev.c	/^void jtdev_tst(struct jtdev *p, int out)$/;"	f
+key_size	util/btree.h	/^	int             key_size;$/;"	m	struct:btree_def
+keys	util/opdb.c	/^static const struct opdb_key keys[] = {$/;"	v	typeref:struct:opdb_key	file:
+kind	formats/elf_format.h	/^  unsigned char kind;		\/* Determines interpretation of the$/;"	m	struct:__anon39
+lAddrVal	drivers/tilib_defs.h	/^	LONG              lAddrVal;$/;"	m	struct:BREAKPOINT
+lCondMask	drivers/tilib_defs.h	/^	LONG              lCondMask;$/;"	m	struct:BREAKPOINT
+lCondMdbVal	drivers/tilib_defs.h	/^	ULONG             lCondMdbVal;$/;"	m	struct:BREAKPOINT
+lMask	drivers/tilib_defs.h	/^	LONG              lMask;$/;"	m	struct:BREAKPOINT
+lRangeEndAdVa	drivers/tilib_defs.h	/^	LONG              lRangeEndAdVa;$/;"	m	struct:BREAKPOINT
+lReg	drivers/tilib_defs.h	/^	LONG              lReg;$/;"	m	struct:BREAKPOINT
+l_checksum	formats/elf_format.h	/^  Elf32_Word l_checksum;	\/* Checksum *\/$/;"	m	struct:__anon41
+l_checksum	formats/elf_format.h	/^  Elf64_Word l_checksum;	\/* Checksum *\/$/;"	m	struct:__anon42
+l_child	drivers/sim.c	/^	struct search_node *l_child;$/;"	m	struct:search_node	typeref:struct:search_node::search_node	file:
+l_flags	formats/elf_format.h	/^  Elf32_Word l_flags;		\/* Flags *\/$/;"	m	struct:__anon41
+l_flags	formats/elf_format.h	/^  Elf64_Word l_flags;		\/* Flags *\/$/;"	m	struct:__anon42
+l_name	formats/elf_format.h	/^  Elf32_Word l_name;		\/* Name (string table index) *\/$/;"	m	struct:__anon41
+l_name	formats/elf_format.h	/^  Elf64_Word l_name;		\/* Name (string table index) *\/$/;"	m	struct:__anon42
+l_time_stamp	formats/elf_format.h	/^  Elf32_Word l_time_stamp;	\/* Timestamp *\/$/;"	m	struct:__anon41
+l_time_stamp	formats/elf_format.h	/^  Elf64_Word l_time_stamp;	\/* Timestamp *\/$/;"	m	struct:__anon42
+l_version	formats/elf_format.h	/^  Elf32_Word l_version;		\/* Interface version *\/$/;"	m	struct:__anon41
+l_version	formats/elf_format.h	/^  Elf64_Word l_version;		\/* Interface version *\/$/;"	m	struct:__anon42
+last	drivers/obl.c	/^	uint32_t	last;$/;"	m	struct:progress_meter	file:
+last_bps	drivers/gdbc.c	/^	struct device_breakpoint	last_bps[DEVICE_MAX_BREAKPOINTS];$/;"	m	struct:gdb_client	typeref:struct:gdb_client::device_breakpoint	file:
+last_error	util/util.c	/^const char *last_error(void)$/;"	f
+last_operator	util/expr.c	/^	int            last_operator;$/;"	m	struct:addr_exp_state	file:
+lb_debug	util/output.c	/^static struct linebuf lb_debug;$/;"	v	typeref:struct:linebuf	file:
+lb_error	util/output.c	/^static struct linebuf lb_error;$/;"	v	typeref:struct:linebuf	file:
+lb_normal	util/output.c	/^static struct linebuf lb_normal;$/;"	v	typeref:struct:linebuf	file:
+lb_shell	util/output.c	/^static struct linebuf lb_shell;$/;"	v	typeref:struct:linebuf	file:
+lcdEnd	drivers/tilib_defs.h	/^		WORD  lcdEnd;$/;"	m	struct:DEVICE_T::__anon45
+lcdStart	drivers/tilib_defs.h	/^		WORD  lcdStart;$/;"	m	struct:DEVICE_T::__anon45
+len	drivers/goodfet.c	/^	uint16_t	len;$/;"	m	struct:packet	file:
+len	formats/binfile.h	/^	int			len;$/;"	m	struct:binfile_chunk
+len	transport/rf2500.c	/^	int                     len;$/;"	m	struct:rf2500_transport	file:
+len	ui/devcmd.c	/^	int             len;$/;"	m	struct:hexout_data	file:
+len	ui/gdb.c	/^	int     len;$/;"	m	struct:monitor_buf	file:
+len	ui/rtools.c	/^	int             len;$/;"	m	struct:call_graph	file:
+len	util/demangle.c	/^	int		len;$/;"	m	struct:dmbuf	file:
+len	util/dis.h	/^	int                     len;$/;"	m	struct:msp430_instruction
+len	util/output.c	/^	int		len;$/;"	m	struct:linebuf	file:
+len	util/prog.h	/^	int             len;$/;"	m	struct:prog_data
+linebox	ui/input_async.c	/^static struct mailbox linebox;$/;"	v	typeref:struct:mailbox	file:
+linebuf	util/output.c	/^struct linebuf {$/;"	s	file:
+list	ui/sym.c	/^	struct vector   list;$/;"	m	struct:rename_data	typeref:struct:rename_data::vector	file:
+list_devices	ui/main.c	/^static int list_devices(void)$/;"	f	file:
+list_init	util/list.c	/^void list_init(struct list_node *head)$/;"	f
+list_insert	util/list.c	/^void list_insert(struct list_node *item, struct list_node *after)$/;"	f
+list_is_sorted	ui/aliasdb.c	/^static int list_is_sorted;$/;"	v	file:
+list_node	util/list.h	/^struct list_node {$/;"	s
+list_remove	util/list.c	/^void list_remove(struct list_node *item)$/;"	f
+load_break	drivers/tilib.c	/^static void load_break(BpParameter_t *param, address_t addr)$/;"	f	file:
+load_complex	drivers/tilib.c	/^static void load_complex(BpParameter_t *param, address_t addr,$/;"	f	file:
+load_firmware	transport/ti3410.c	/^static int load_firmware(struct firmware *f)$/;"	f	file:
+load_image	drivers/obl.c	/^static int load_image(transport_t trans, const uint8_t *file_data,$/;"	f	file:
+load_section	formats/coff.c	/^static int load_section(FILE *in, uint32_t addr, uint32_t offset,$/;"	f	file:
+load_strings	formats/elf32.c	/^static int load_strings(struct elf32_info *info, FILE *in, Elf32_Shdr *s)$/;"	f	file:
+lock	ui/input_async.c	/^	thread_lock_t		lock;$/;"	m	struct:mailbox	file:
+long_password	drivers/flash_bsl.c	/^	int		long_password;$/;"	m	struct:flash_bsl_device	file:
+m_info	formats/elf_format.h	/^  Elf32_Word m_info;		\/* Size and index.  *\/$/;"	m	struct:__anon33
+m_info	formats/elf_format.h	/^  Elf64_Xword m_info;		\/* Size and index.  *\/$/;"	m	struct:__anon34
+m_poffset	formats/elf_format.h	/^  Elf32_Word m_poffset;		\/* Symbol offset.  *\/$/;"	m	struct:__anon33
+m_poffset	formats/elf_format.h	/^  Elf64_Xword m_poffset;	\/* Symbol offset.  *\/$/;"	m	struct:__anon34
+m_repeat	formats/elf_format.h	/^  Elf32_Half m_repeat;		\/* Repeat count.  *\/$/;"	m	struct:__anon33
+m_repeat	formats/elf_format.h	/^  Elf64_Half m_repeat;		\/* Repeat count.  *\/$/;"	m	struct:__anon34
+m_stride	formats/elf_format.h	/^  Elf32_Half m_stride;		\/* Stride info.  *\/$/;"	m	struct:__anon33
+m_stride	formats/elf_format.h	/^  Elf64_Half m_stride;		\/* Stride info.  *\/$/;"	m	struct:__anon34
+m_value	formats/elf_format.h	/^  Elf32_Xword m_value;		\/* Symbol value.  *\/$/;"	m	struct:__anon33
+m_value	formats/elf_format.h	/^  Elf64_Xword m_value;		\/* Symbol value.  *\/$/;"	m	struct:__anon34
+mab	util/powerbuf.h	/^	address_t			*mab;$/;"	m	struct:powerbuf
+mailbox	drivers/tilib.c	/^	uint32_t		mailbox;$/;"	m	struct:tilib_device	file:
+mailbox	ui/input_async.c	/^struct mailbox {$/;"	s	file:
+mailbox_state_t	ui/input_async.c	/^} mailbox_state_t;$/;"	t	typeref:enum:__anon65	file:
+main	ui/main.c	/^int main(int argc, char **argv)$/;"	f
+mainEnd	drivers/tilib_defs.h	/^		ULONG mainEnd;$/;"	m	struct:DEVICE_T::__anon45
+mainStart	drivers/tilib_defs.h	/^		WORD  mainStart;$/;"	m	struct:DEVICE_T::__anon45
+mark_modified	ui/reader.c	/^void mark_modified(int flags)$/;"	f
+max_breakpoints	drivers/device.h	/^	int max_breakpoints;$/;"	m	struct:device
+max_len	util/demangle.c	/^	int		max_len;$/;"	m	struct:dmbuf	file:
+max_samples	util/powerbuf.h	/^	unsigned int			max_samples;$/;"	m	struct:powerbuf
+mb_lock	drivers/tilib.c	/^	thread_lock_t		mb_lock;$/;"	m	struct:tilib_device	file:
+memory	drivers/sim.c	/^	uint8_t                 memory[MEM_SIZE];$/;"	m	struct:sim_device	file:
+merge_pages	util/btree.c	/^static void merge_pages(struct btree_page *lower,$/;"	f	file:
+merge_power	ui/power.c	/^static void merge_power(struct vector *list, powerbuf_t pb)$/;"	f	file:
+mnemonic	util/dis.c	/^	const char      *mnemonic;$/;"	m	struct:__anon53	file:
+mode	simio/simio_hwmult.c	/^	int				mode;$/;"	m	struct:hwmult	file:
+modify_flags	ui/reader.c	/^static int modify_flags;$/;"	v	file:
+monitor_buf	ui/gdb.c	/^struct monitor_buf {$/;"	s	file:
+monitor_capture	ui/gdb.c	/^static void monitor_capture(void *user_data, const char *text)$/;"	f	file:
+monitor_command	ui/gdb.c	/^static int monitor_command(struct gdb_data *data, char *buf)$/;"	f	file:
+move_item	util/btree.c	/^static void move_item(struct btree_page *from, int from_pos,$/;"	f	file:
+msg28_data	drivers/fet_db.h	/^	uint8_t         msg28_data[FET_DB_MSG28_LEN];$/;"	m	struct:fet_db_record
+msg29_data	drivers/fet_db.h	/^	uint8_t         msg29_data[FET_DB_MSG29_LEN];$/;"	m	struct:fet_db_record
+msg29_data	drivers/fet_olimex_db.h	/^	uint8_t         msg29_data[FET_OLIMEX_DB_MSG29_LEN];$/;"	m	struct:fet_olimex_db_record
+msg29_params	drivers/fet_db.h	/^	int             msg29_params[FET_DB_MSG29_PARAMS];$/;"	m	struct:fet_db_record
+msg29_params	drivers/fet_olimex_db.h	/^	int             msg29_params[FET_OLIMEX_DB_MSG29_PARAMS];$/;"	m	struct:fet_olimex_db_record
+msg2b_data	drivers/fet_db.h	/^	uint8_t         msg2b_data[FET_DB_MSG2B_LEN];$/;"	m	struct:fet_db_record
+msg2b_data	drivers/fet_olimex_db.h	/^	uint8_t         msg2b_data[FET_OLIMEX_DB_MSG2B_LEN];$/;"	m	struct:fet_olimex_db_record
+msg2b_len	drivers/fet_db.h	/^	int             msg2b_len;$/;"	m	struct:fet_db_record
+msg2b_len	drivers/fet_olimex_db.h	/^	int             msg2b_len;$/;"	m	struct:fet_olimex_db_record
+msp430_amode_t	util/dis.h	/^} msp430_amode_t;$/;"	t	typeref:enum:__anon54
+msp430_dsize_t	util/dis.h	/^} msp430_dsize_t;$/;"	t	typeref:enum:__anon57
+msp430_instruction	util/dis.h	/^struct msp430_instruction {$/;"	s
+msp430_itype_t	util/dis.h	/^} msp430_itype_t;$/;"	t	typeref:enum:__anon56
+msp430_op_t	util/dis.h	/^} msp430_op_t;$/;"	t	typeref:enum:__anon58
+msp430_reg_names	util/dis.c	/^static const char *const msp430_reg_names[] = {$/;"	v	file:
+msp430_reg_t	util/dis.h	/^} msp430_reg_t;$/;"	t	typeref:enum:__anon55
+my_message_ids	drivers/tilib.c	/^static const MessageID_t my_message_ids = {$/;"	v	file:
+nBreakpoints	drivers/tilib_defs.h	/^		WORD  nBreakpoints;$/;"	m	struct:DEVICE_T::__anon45
+nBreakpointsDma	drivers/tilib_defs.h	/^		WORD nBreakpointsDma;$/;"	m	struct:DEVICE_T::__anon45
+nBreakpointsOptions	drivers/tilib_defs.h	/^		WORD nBreakpointsOptions;$/;"	m	struct:DEVICE_T::__anon45
+nBreakpointsReadWrite	drivers/tilib_defs.h	/^		WORD nBreakpointsReadWrite;$/;"	m	struct:DEVICE_T::__anon45
+nCombinations	drivers/tilib_defs.h	/^		WORD  nCombinations;$/;"	m	struct:DEVICE_T::__anon45
+nCycleCounter	drivers/tilib_defs.h	/^		WORD nCycleCounter;$/;"	m	struct:DEVICE_T::__anon45
+nCycleCounterOperations	drivers/tilib_defs.h	/^		WORD nCycleCounterOperations;$/;"	m	struct:DEVICE_T::__anon45
+nRegTrigger	drivers/tilib_defs.h	/^		WORD  nRegTrigger;$/;"	m	struct:DEVICE_T::__anon45
+nRegTriggerOperations	drivers/tilib_defs.h	/^		WORD nRegTriggerOperations;$/;"	m	struct:DEVICE_T::__anon45
+nSequencer	drivers/tilib_defs.h	/^		WORD nSequencer;$/;"	m	struct:DEVICE_T::__anon45
+nStateStorage	drivers/tilib_defs.h	/^		WORD nStateStorage ;$/;"	m	struct:DEVICE_T::__anon45
+n_descsz	formats/elf_format.h	/^  Elf32_Word n_descsz;			\/* Length of the note's descriptor.  *\/$/;"	m	struct:__anon31
+n_descsz	formats/elf_format.h	/^  Elf64_Word n_descsz;			\/* Length of the note's descriptor.  *\/$/;"	m	struct:__anon32
+n_namesz	formats/elf_format.h	/^  Elf32_Word n_namesz;			\/* Length of the note's name.  *\/$/;"	m	struct:__anon31
+n_namesz	formats/elf_format.h	/^  Elf64_Word n_namesz;			\/* Length of the note's name.  *\/$/;"	m	struct:__anon32
+n_type	formats/elf_format.h	/^  Elf32_Word n_type;			\/* Type of the note.  *\/$/;"	m	struct:__anon31
+n_type	formats/elf_format.h	/^  Elf64_Word n_type;			\/* Type of the note.  *\/$/;"	m	struct:__anon32
+name	drivers/device.h	/^	const char		*name;$/;"	m	struct:device_class
+name	drivers/devicelist.h	/^	const char	*name;$/;"	m	struct:device_table
+name	drivers/fet_db.h	/^	const char      *name;$/;"	m	struct:fet_db_record
+name	drivers/fet_olimex_db.h	/^	const char      *name;$/;"	m	struct:fet_olimex_db_record
+name	formats/binfile.h	/^	const char		*name;$/;"	m	struct:binfile_chunk
+name	simio/simio_device.h	/^	char				name[64];$/;"	m	struct:simio_device
+name	simio/simio_device.h	/^	const char          *name;$/;"	m	struct:simio_class
+name	ui/cmddb.h	/^	const char		*name;$/;"	m	struct:cmddb_record
+name	ui/power.c	/^	char			name[64];$/;"	m	struct:profile_rec	file:
+name	util/opdb.h	/^	const char		*name;$/;"	m	struct:opdb_key
+name	util/stab.c	/^	char           name[MAX_SYMBOL_LENGTH];$/;"	m	struct:addr_key	file:
+name	util/stab.c	/^	char name[MAX_SYMBOL_LENGTH];$/;"	m	struct:sym_key	file:
+namelist_cmp	util/output_util.c	/^static int namelist_cmp(const void *a, const void *b)$/;"	f	file:
+namelist_print	util/output_util.c	/^void namelist_print(struct vector *v)$/;"	f
+next	ui/aliasdb.c	/^	struct recurse_list	*next;$/;"	m	struct:recurse_list	typeref:struct:recurse_list::recurse_list	file:
+next	util/list.h	/^	struct list_node	*next;$/;"	m	struct:list_node	typeref:struct:list_node::list_node
+next_instr_addr	util/output_util.c	/^address_t next_instr_addr(address_t offset, const uint8_t *data, int length)$/;"	f
+node	drivers/sim.c	/^  search_node *node;$/;"	m	struct:entry	file:
+node	simio/simio_device.h	/^	struct list_node		node;$/;"	m	struct:simio_device	typeref:struct:simio_device::list_node
+node_list	ui/rtools.c	/^	struct vector   node_list;$/;"	m	struct:call_graph	typeref:struct:call_graph::vector	file:
+num_children	util/btree.c	/^	int                     num_children;$/;"	m	struct:btree_page	file:
+numeric	util/opdb.h	/^	address_t       numeric;$/;"	m	union:opdb_value
+obl_cmd_t	drivers/obl.c	/^} obl_cmd_t;$/;"	t	typeref:enum:__anon51	file:
+obl_get_version	drivers/obl.c	/^int obl_get_version(transport_t tr, uint32_t *ver_ret)$/;"	f
+obl_read_mem	drivers/obl.c	/^static int obl_read_mem(transport_t tr, uint32_t addr,$/;"	f	file:
+obl_reset	drivers/obl.c	/^int obl_reset(transport_t trans)$/;"	f
+obl_result_t	drivers/obl.c	/^} obl_result_t;$/;"	t	typeref:enum:__anon52	file:
+obl_update	drivers/obl.c	/^int obl_update(transport_t trans, const char *image_filename)$/;"	f
+obl_write_flash	drivers/obl.c	/^static int obl_write_flash(transport_t tr, uint32_t addr,$/;"	f	file:
+obl_xfer	drivers/obl.c	/^static int obl_xfer(transport_t tr, const uint8_t *command, int cmd_len,$/;"	f	file:
+offset	transport/rf2500.c	/^	int                     offset;$/;"	m	struct:rf2500_transport	file:
+offset	ui/rtools.c	/^	address_t      offset;$/;"	m	struct:cg_node	file:
+offset	ui/rtools.c	/^	int             offset;$/;"	m	struct:call_graph	file:
+offset	util/dis.h	/^	address_t               offset;$/;"	m	struct:msp430_instruction
+old_name	ui/sym.c	/^	char    old_name[MAX_SYMBOL_LENGTH];$/;"	m	struct:rename_record	file:
+op	util/dis.c	/^	msp430_op_t     op;$/;"	m	struct:__anon53	file:
+op	util/dis.h	/^	msp430_op_t             op;$/;"	m	struct:msp430_instruction
+op1	simio/simio_hwmult.c	/^	uint16_t			op1;$/;"	m	struct:hwmult	file:
+op2	simio/simio_hwmult.c	/^	uint16_t			op2;$/;"	m	struct:hwmult	file:
+op_stack	util/expr.c	/^	int            op_stack[32];$/;"	m	struct:addr_exp_state	file:
+op_stack_size	util/expr.c	/^	int            op_stack_size;$/;"	m	struct:addr_exp_state	file:
+opcode_names	util/dis.c	/^} opcode_names[] = {$/;"	v	typeref:struct:__anon53	file:
+opdb_enum	util/opdb.c	/^int opdb_enum(opdb_enum_func_t func, void *user_data)$/;"	f
+opdb_enum_func_t	util/opdb.h	/^typedef int (*opdb_enum_func_t)(void *user_data, const struct opdb_key *key,$/;"	t
+opdb_find	util/opdb.c	/^static int opdb_find(const char *name)$/;"	f	file:
+opdb_get	util/opdb.c	/^int opdb_get(const char *name, struct opdb_key *key,$/;"	f
+opdb_get_boolean	util/opdb.c	/^int opdb_get_boolean(const char *name)$/;"	f
+opdb_get_numeric	util/opdb.c	/^address_t opdb_get_numeric(const char *name)$/;"	f
+opdb_get_string	util/opdb.c	/^const char *opdb_get_string(const char *name)$/;"	f
+opdb_key	util/opdb.h	/^struct opdb_key {$/;"	s
+opdb_read_fperm	util/opdb.c	/^fperm_t opdb_read_fperm(void)$/;"	f
+opdb_reset	util/opdb.c	/^void opdb_reset(void)$/;"	f
+opdb_set	util/opdb.c	/^int opdb_set(const char *name, const union opdb_value *value)$/;"	f
+opdb_type_t	util/opdb.h	/^} opdb_type_t;$/;"	t	typeref:enum:__anon61
+opdb_value	util/opdb.h	/^union opdb_value {$/;"	u
+open	drivers/device.h	/^	device_t (*open)(const struct device_args *args);$/;"	m	struct:device_class
+open_device	transport/cp210x.c	/^static int open_device(struct cp210x_transport *tr, struct usb_device *dev,$/;"	f	file:
+open_device	transport/ftdi.c	/^static int open_device(struct ftdi_transport *tr, struct usb_device *dev,$/;"	f	file:
+open_device	transport/rf2500.c	/^static int open_device(struct rf2500_transport *tr,$/;"	f	file:
+open_device	transport/ti3410.c	/^static int open_device(struct ti3410_transport *tr,$/;"	f	file:
+open_interface	transport/cdc_acm.c	/^static int open_interface(struct cdc_acm_transport *tr,$/;"	f	file:
+open_interface	transport/cp210x.c	/^static int open_interface(struct cp210x_transport *tr,$/;"	f	file:
+open_interface	transport/rf2500.c	/^static int open_interface(struct rf2500_transport *tr,$/;"	f	file:
+operation	ui/flatfile.c	/^enum operation {$/;"	g	file:
+ops	transport/transport.h	/^	const struct transport_class	*ops;$/;"	m	struct:transport	typeref:struct:transport::transport_class
+opt_bytes	formats/coff.c	/^	int             opt_bytes;$/;"	m	struct:coff_header	file:
+out	util/demangle.c	/^	char		*out;$/;"	m	struct:dmbuf	file:
+out_ep	transport/cdc_acm.c	/^	int			out_ep;$/;"	m	struct:cdc_acm_transport	file:
+outbuf	util/gdb_proto.h	/^	char            outbuf[GDB_BUF_SIZE];$/;"	m	struct:gdb_data
+outlen	util/gdb_proto.h	/^	int             outlen;$/;"	m	struct:gdb_data
+output_set_embedded	util/output.c	/^void output_set_embedded(int enable)$/;"	f
+owner	util/btree.c	/^	struct btree            *owner;$/;"	m	struct:btree_page	typeref:struct:btree_page::btree	file:
+p_align	formats/elf_format.h	/^  Elf32_Word	p_align;		\/* Segment alignment *\/$/;"	m	struct:__anon13
+p_align	formats/elf_format.h	/^  Elf64_Xword	p_align;		\/* Segment alignment *\/$/;"	m	struct:__anon14
+p_filesz	formats/elf_format.h	/^  Elf32_Word	p_filesz;		\/* Segment size in file *\/$/;"	m	struct:__anon13
+p_filesz	formats/elf_format.h	/^  Elf64_Xword	p_filesz;		\/* Segment size in file *\/$/;"	m	struct:__anon14
+p_flags	formats/elf_format.h	/^  Elf32_Word	p_flags;		\/* Segment flags *\/$/;"	m	struct:__anon13
+p_flags	formats/elf_format.h	/^  Elf64_Word	p_flags;		\/* Segment flags *\/$/;"	m	struct:__anon14
+p_memsz	formats/elf_format.h	/^  Elf32_Word	p_memsz;		\/* Segment size in memory *\/$/;"	m	struct:__anon13
+p_memsz	formats/elf_format.h	/^  Elf64_Xword	p_memsz;		\/* Segment size in memory *\/$/;"	m	struct:__anon14
+p_offset	formats/elf_format.h	/^  Elf32_Off	p_offset;		\/* Segment file offset *\/$/;"	m	struct:__anon13
+p_offset	formats/elf_format.h	/^  Elf64_Off	p_offset;		\/* Segment file offset *\/$/;"	m	struct:__anon14
+p_paddr	formats/elf_format.h	/^  Elf32_Addr	p_paddr;		\/* Segment physical address *\/$/;"	m	struct:__anon13
+p_paddr	formats/elf_format.h	/^  Elf64_Addr	p_paddr;		\/* Segment physical address *\/$/;"	m	struct:__anon14
+p_type	formats/elf_format.h	/^  Elf32_Word	p_type;			\/* Segment type *\/$/;"	m	struct:__anon13
+p_type	formats/elf_format.h	/^  Elf64_Word	p_type;			\/* Segment type *\/$/;"	m	struct:__anon14
+p_vaddr	formats/elf_format.h	/^  Elf32_Addr	p_vaddr;		\/* Segment virtual address *\/$/;"	m	struct:__anon13
+p_vaddr	formats/elf_format.h	/^  Elf64_Addr	p_vaddr;		\/* Segment virtual address *\/$/;"	m	struct:__anon14
+packet	drivers/goodfet.c	/^struct packet {$/;"	s	file:
+parent	drivers/sim.c	/^	struct search_node *parent;$/;"	m	struct:search_node	typeref:struct:search_node::search_node	file:
+parse_ansi	util/output.c	/^static int parse_ansi(const char *text, int *ansi_state)$/;"	f	file:
+parse_cmdline_args	ui/main.c	/^static int parse_cmdline_args(int argc, char **argv,$/;"	f	file:
+parse_ehdr	formats/elf32.c	/^static int parse_ehdr(Elf32_Ehdr *e, FILE *in)$/;"	f	file:
+parse_granularity	ui/power.c	/^static int parse_granularity(powerbuf_t pb, char **arg, int *gran_out)$/;"	f	file:
+parse_header	formats/coff.c	/^static void parse_header(const uint8_t *data, struct coff_header *hdr)$/;"	f	file:
+parse_int	simio/simio_wdt.c	/^static int parse_int(int *val, char **arg_text)$/;"	f	file:
+parse_option	ui/stdcmd.c	/^static int parse_option(opdb_type_t type, union opdb_value *value,$/;"	f	file:
+parse_packet	drivers/fet_proto.c	/^static int parse_packet(struct fet_proto *dev, int plen)$/;"	f	file:
+parse_phdr	formats/elf32.c	/^static int parse_phdr(Elf32_Phdr *p, FILE *in)$/;"	f	file:
+parse_shdr	formats/elf32.c	/^static int parse_shdr(Elf32_Shdr *s, FILE *in)$/;"	f	file:
+parse_sym	formats/elf32.c	/^static int parse_sym(Elf32_Sym *s, FILE *in)$/;"	f	file:
+parse_text	util/output.c	/^static int parse_text(const char *text)$/;"	f	file:
+path	drivers/device.h	/^	const char		*path;$/;"	m	struct:device_args
+path	util/btree.c	/^	struct btree_page       *path[MAX_HEIGHT];$/;"	m	struct:btree	typeref:struct:btree::btree_page	file:
+pif_ctl	drivers/pif.c	/^static int pif_ctl(device_t dev_base, device_ctl_t type)$/;"	f	file:
+pif_destroy	drivers/pif.c	/^static void pif_destroy(device_t dev_base)$/;"	f	file:
+pif_device	drivers/pif.c	/^struct pif_device {$/;"	s	file:
+pif_erase	drivers/pif.c	/^static int pif_erase( device_t dev_base,$/;"	f	file:
+pif_getregs	drivers/pif.c	/^static int pif_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+pif_open	drivers/pif.c	/^static device_t pif_open(const struct device_args *args)$/;"	f	file:
+pif_poll	drivers/pif.c	/^static device_status_t pif_poll(device_t dev_base)$/;"	f	file:
+pif_readmem	drivers/pif.c	/^static int pif_readmem( device_t  dev_base,$/;"	f	file:
+pif_setregs	drivers/pif.c	/^static int pif_setregs( device_t dev_base, const address_t* regs )$/;"	f	file:
+pif_writemem	drivers/pif.c	/^static int pif_writemem( device_t       dev_base,$/;"	f	file:
+pin_state	simio/simio_wdt.c	/^	int				pin_state;$/;"	m	struct:wdt	file:
+poll	drivers/device.h	/^	device_status_t (*poll)(device_t dev);$/;"	m	struct:device_class
+poll_enable	drivers/fet_core.c	/^	int				poll_enable;$/;"	m	struct:fet_device	file:
+pop	drivers/sim.c	/^struct search_node *pop () {$/;"	f
+pop_oldest_session	util/powerbuf.c	/^static void pop_oldest_session(powerbuf_t pb)$/;"	f	file:
+port	drivers/jtdev.h	/^	int		port;$/;"	m	struct:jtdev
+port_map	simio/simio_gpio.c	/^static int port_map(struct gpio *g, address_t addr)$/;"	f	file:
+power_buf	drivers/device.h	/^	powerbuf_t power_buf;$/;"	m	struct:device
+power_end	drivers/fet_core.c	/^static int power_end(struct fet_device *dev)$/;"	f	file:
+power_init	drivers/fet_core.c	/^static void power_init(struct fet_device *dev)$/;"	f	file:
+power_poll	drivers/fet_core.c	/^static int power_poll(struct fet_device *dev)$/;"	f	file:
+power_start	drivers/fet_core.c	/^static int power_start(struct fet_device *dev)$/;"	f	file:
+powerbuf	util/powerbuf.h	/^struct powerbuf {$/;"	s
+powerbuf_add_samples	util/powerbuf.c	/^void powerbuf_add_samples(powerbuf_t pb, unsigned int count,$/;"	f
+powerbuf_begin_session	util/powerbuf.c	/^void powerbuf_begin_session(powerbuf_t pb, time_t when)$/;"	f
+powerbuf_clear	util/powerbuf.c	/^void powerbuf_clear(powerbuf_t pb)$/;"	f
+powerbuf_end_session	util/powerbuf.c	/^void powerbuf_end_session(powerbuf_t pb)$/;"	f
+powerbuf_free	util/powerbuf.c	/^void powerbuf_free(powerbuf_t pb)$/;"	f
+powerbuf_get_by_mab	util/powerbuf.c	/^int powerbuf_get_by_mab(powerbuf_t pb, address_t mab,$/;"	f
+powerbuf_last_mab	util/powerbuf.c	/^address_t powerbuf_last_mab(powerbuf_t pb)$/;"	f
+powerbuf_new	util/powerbuf.c	/^powerbuf_t powerbuf_new(unsigned int max_samples, unsigned int interval_us)$/;"	f
+powerbuf_num_sessions	util/powerbuf.c	/^unsigned int powerbuf_num_sessions(powerbuf_t pb)$/;"	f
+powerbuf_session	util/powerbuf.h	/^struct powerbuf_session {$/;"	s
+powerbuf_session_info	util/powerbuf.c	/^const struct powerbuf_session *powerbuf_session_info(powerbuf_t pb,$/;"	f
+powerbuf_sort	util/powerbuf.c	/^void powerbuf_sort(powerbuf_t pb)$/;"	f
+powerbuf_t	util/powerbuf.h	/^typedef struct powerbuf *powerbuf_t;$/;"	t	typeref:struct:powerbuf
+pr_error	util/output.c	/^void pr_error(const char *prefix)$/;"	f
+preg	ui/sym.c	/^	regex_t         preg;$/;"	m	struct:rename_data	file:
+prepare_firmware	transport/ti3410.c	/^static void prepare_firmware(struct firmware *f)$/;"	f	file:
+prev	util/list.h	/^	struct list_node	*prev;$/;"	m	struct:list_node	typeref:struct:list_node::list_node
+print_address	util/output_util.c	/^int print_address(address_t addr, char *out, int max_len,$/;"	f
+print_address_flags_t	util/output_util.h	/^} print_address_flags_t;$/;"	t	typeref:enum:__anon59
+print_header	ui/power.c	/^static void print_header(powerbuf_t pb, unsigned int s)$/;"	f	file:
+print_profile	ui/power.c	/^static void print_profile(int interval_us, const struct vector *list)$/;"	f	file:
+print_sym	ui/sym.c	/^static int print_sym(void *user_data, const char *name, address_t value)$/;"	f	file:
+print_tristate	simio/simio_gpio.c	/^static void print_tristate(uint8_t mask, uint8_t value)$/;"	f	file:
+printc	util/output.c	/^int printc(const char *fmt, ...)$/;"	f
+printc_dbg	util/output.c	/^int printc_dbg(const char *fmt, ...)$/;"	f
+printc_err	util/output.c	/^int printc_err(const char *fmt, ...)$/;"	f
+printc_shell	util/output.c	/^int printc_shell(const char *fmt, ...)$/;"	f
+process_command	ui/reader.c	/^int process_command(char *cmd)$/;"	f
+process_data_line	formats/titext.c	/^static int process_data_line(address_t address, const char *buf,$/;"	f	file:
+process_file	ui/reader.c	/^int process_file(const char *filename, int show)$/;"	f
+process_gdb_command	ui/gdb.c	/^static int process_gdb_command(struct gdb_data *data, char *buf)$/;"	f	file:
+process_rc_file	ui/main.c	/^static void process_rc_file(const char *config)$/;"	f	file:
+profile_rec	ui/power.c	/^struct profile_rec {$/;"	s	file:
+prog_data	util/prog.h	/^struct prog_data {$/;"	s
+prog_feed	util/prog.c	/^int prog_feed(struct prog_data *prog, const struct binfile_chunk *ch)$/;"	f
+prog_flush	util/prog.c	/^int prog_flush(struct prog_data *prog)$/;"	f
+prog_init	util/prog.c	/^void prog_init(struct prog_data *prog, int flags)$/;"	f
+progress_init	drivers/obl.c	/^static void progress_init(struct progress_meter *m, uint32_t size)$/;"	f	file:
+progress_meter	drivers/obl.c	/^struct progress_meter {$/;"	s	file:
+progress_update	drivers/obl.c	/^static void progress_update(struct progress_meter *m, const char *label,$/;"	f	file:
+prompt_abort	ui/input.h	/^	int	(*prompt_abort)(const char *message);$/;"	m	struct:input_interface
+prompt_abort	ui/reader.c	/^int prompt_abort(int flags)$/;"	f
+proto	drivers/fet_core.c	/^	struct fet_proto		proto;$/;"	m	struct:fet_device	typeref:struct:fet_device::fet_proto	file:
+proto_flags	drivers/fet_proto.h	/^	int				proto_flags;$/;"	m	struct:fet_proto
+ptr	util/vector.h	/^	void            *ptr;$/;"	m	struct:vector
+push	drivers/sim.c	/^void push( struct search_node *node ) {$/;"	f
+push_command_name	ui/stdcmd.c	/^static int push_command_name(void *user_data, const struct cmddb_record *rec)$/;"	f	file:
+push_option_name	ui/stdcmd.c	/^static int push_option_name(void *user_data, const struct opdb_key *key,$/;"	f	file:
+r_addend	formats/elf_format.h	/^  Elf32_Sword	r_addend;		\/* Addend *\/$/;"	m	struct:__anon11
+r_addend	formats/elf_format.h	/^  Elf64_Sxword	r_addend;		\/* Addend *\/$/;"	m	struct:__anon12
+r_info	formats/elf_format.h	/^  Elf32_Word	r_info;			\/* Relocation type and symbol index *\/$/;"	m	struct:__anon11
+r_info	formats/elf_format.h	/^  Elf32_Word	r_info;			\/* Relocation type and symbol index *\/$/;"	m	struct:__anon9
+r_info	formats/elf_format.h	/^  Elf64_Xword	r_info;			\/* Relocation type and symbol index *\/$/;"	m	struct:__anon10
+r_info	formats/elf_format.h	/^  Elf64_Xword	r_info;			\/* Relocation type and symbol index *\/$/;"	m	struct:__anon12
+r_offset	formats/elf_format.h	/^  Elf32_Addr	r_offset;		\/* Address *\/$/;"	m	struct:__anon11
+r_offset	formats/elf_format.h	/^  Elf32_Addr	r_offset;		\/* Address *\/$/;"	m	struct:__anon9
+r_offset	formats/elf_format.h	/^  Elf64_Addr	r_offset;		\/* Address *\/$/;"	m	struct:__anon10
+r_offset	formats/elf_format.h	/^  Elf64_Addr	r_offset;		\/* Address *\/$/;"	m	struct:__anon12
+ram2End	drivers/tilib_defs.h	/^		WORD  ram2End;$/;"	m	struct:DEVICE_T::__anon45
+ram2Start	drivers/tilib_defs.h	/^		WORD  ram2Start;$/;"	m	struct:DEVICE_T::__anon45
+ramEnd	drivers/tilib_defs.h	/^		WORD  ramEnd;$/;"	m	struct:DEVICE_T::__anon45
+ramStart	drivers/tilib_defs.h	/^		WORD  ramStart;$/;"	m	struct:DEVICE_T::__anon45
+rate	util/sport.c	/^	int             rate;$/;"	m	struct:baud_rate	file:
+rate_to_code	util/sport.c	/^static int rate_to_code(int rate)$/;"	f	file:
+rbuf	transport/cdc_acm.c	/^	char			rbuf[READ_BUFFER_SIZE];$/;"	m	struct:cdc_acm_transport	file:
+rbuf_len	transport/cdc_acm.c	/^	int			rbuf_len;$/;"	m	struct:cdc_acm_transport	file:
+rbuf_ptr	transport/cdc_acm.c	/^	int			rbuf_ptr;$/;"	m	struct:cdc_acm_transport	file:
+read	simio/simio_device.h	/^	int (*read)(struct simio_device *dev,$/;"	m	struct:simio_class
+read_all	formats/elf32.c	/^static int read_all(struct elf32_info *info, FILE *in)$/;"	f	file:
+read_b	simio/simio_device.h	/^	int (*read_b)(struct simio_device *dev,$/;"	m	struct:simio_class
+read_block	formats/coff.c	/^static int read_block(FILE *in, int offset, int size, void *buf)$/;"	f	file:
+read_byte	drivers/fet_core.c	/^static int read_byte(struct fet_device *dev, address_t addr, uint8_t *out)$/;"	f	file:
+read_command	ui/input.h	/^	int	(*read_command)(char *buf, int max_len);$/;"	m	struct:input_interface
+read_ehdr	formats/elf32.c	/^static int read_ehdr(struct elf32_info *info, FILE *in)$/;"	f	file:
+read_file	drivers/obl.c	/^static uint8_t *read_file(const char *filename, unsigned int *len_ret)$/;"	f	file:
+read_flatfile	ui/flatfile.c	/^static int read_flatfile(const char *path, uint8_t **buf, address_t *len)$/;"	f	file:
+read_header	formats/coff.c	/^static int read_header(FILE *in, struct coff_header *hdr)$/;"	f	file:
+read_memory	ui/gdb.c	/^static int read_memory(struct gdb_data *data, char *text)$/;"	f	file:
+read_phdr	formats/elf32.c	/^static int read_phdr(struct elf32_info *info, FILE *in)$/;"	f	file:
+read_registers	ui/gdb.c	/^static int read_registers(struct gdb_data *data)$/;"	f	file:
+read_sechdrs	formats/coff.c	/^static int read_sechdrs(FILE *in, const struct coff_header *hdr,$/;"	f	file:
+read_serial	util/usbutil.c	/^static int read_serial(struct usb_device *dev, char *buf, int max_len)$/;"	f	file:
+read_shdr	formats/elf32.c	/^static int read_shdr(struct elf32_info *info, FILE *in)$/;"	f	file:
+read_strtab	formats/coff.c	/^static int read_strtab(FILE *in, const struct coff_header *hdr,$/;"	f	file:
+read_symtab	formats/coff.c	/^static int read_symtab(FILE *in, const struct coff_header *hdr,$/;"	f	file:
+read_words	drivers/goodfet.c	/^static int read_words(sport_t fd, address_t addr,$/;"	f	file:
+read_words	drivers/pif.c	/^static int read_words( struct jtdev *p, address_t addr,$/;"	f	file:
+reader_exit	ui/reader.c	/^void reader_exit(void)$/;"	f
+reader_loop	ui/reader.c	/^void reader_loop(void)$/;"	f
+reader_set_repeat	ui/reader.c	/^void reader_set_repeat(const char *fmt, ...)$/;"	f
+readline	ui/input_console.c	/^static char *readline(const char *prompt)$/;"	f	file:
+readmem	drivers/device.h	/^	int (*readmem)(device_t dev, address_t addr,$/;"	m	struct:device_class
+recurse_list	ui/aliasdb.c	/^struct recurse_list {$/;"	s	file:
+recv	transport/transport.h	/^	int (*recv)(transport_t tr, uint8_t *data, int max_len);$/;"	m	struct:transport_class
+recv_packet	drivers/fet_proto.c	/^static int recv_packet(struct fet_proto *dev)$/;"	f	file:
+recv_packet	drivers/goodfet.c	/^static int recv_packet(sport_t fd, struct packet *pkt)$/;"	f	file:
+refresh_bps	drivers/fet_core.c	/^static int refresh_bps(struct fet_device *dev)$/;"	f	file:
+refresh_bps	drivers/gdbc.c	/^static int refresh_bps(struct gdb_client *dev)$/;"	f	file:
+refresh_bps	drivers/tilib.c	/^static int refresh_bps(struct tilib_device *dev)$/;"	f	file:
+refresh_fperm	drivers/fet_core.c	/^static int refresh_fperm(struct fet_device *dev)$/;"	f	file:
+refresh_fperm	drivers/tilib.c	/^static int refresh_fperm(struct tilib_device *dev)$/;"	f	file:
+regs	drivers/sim.c	/^	uint16_t                regs[DEVICE_NUM_REGS];$/;"	m	struct:sim_device	file:
+regs	simio/simio_gpio.c	/^	uint8_t			regs[8];$/;"	m	struct:gpio	file:
+relabel_sources	ui/rtools.c	/^static void relabel_sources(struct call_graph *graph)$/;"	f	file:
+remap_cgen	util/dis.c	/^static void remap_cgen(msp430_amode_t *mode,$/;"	f	file:
+remove_duplicate_edges	ui/rtools.c	/^static void remove_duplicate_edges(struct call_graph *graph)$/;"	f	file:
+remove_duplicate_nodes	ui/rtools.c	/^static void remove_duplicate_nodes(struct call_graph *graph)$/;"	f	file:
+rename_data	ui/sym.c	/^struct rename_data {$/;"	s	file:
+rename_record	ui/sym.c	/^struct rename_record {$/;"	s	file:
+renames_do	ui/sym.c	/^static int renames_do(struct rename_data *rename, const char *replace)$/;"	f	file:
+rep_index	util/dis.h	/^	int			rep_index;$/;"	m	struct:msp430_instruction
+rep_register	util/dis.h	/^	int			rep_register;$/;"	m	struct:msp430_instruction
+repeat_buf	ui/reader.c	/^static char repeat_buf[MAX_READER_LINE];$/;"	v	file:
+reply_buf	drivers/bsl.c	/^	uint8_t         reply_buf[256];$/;"	m	struct:bsl_device	file:
+reply_len	drivers/bsl.c	/^	int             reply_len;$/;"	m	struct:bsl_device	file:
+report_error	drivers/tilib.c	/^static void report_error(struct tilib_device *dev, const char *what)$/;"	f	file:
+requested_serial	drivers/device.h	/^	const char		*requested_serial;$/;"	m	struct:device_args
+require_fwupdate	drivers/device.h	/^	const char		*require_fwupdate;$/;"	m	struct:device_args
+reset	simio/simio_device.h	/^	void (*reset)(struct simio_device *dev);$/;"	m	struct:simio_class
+reset_sequence	drivers/goodfet.c	/^static int reset_sequence(sport_t fd)$/;"	f	file:
+reset_triggered	simio/simio_wdt.c	/^	int				reset_triggered;$/;"	m	struct:wdt	file:
+restart_program	ui/gdb.c	/^static int restart_program(struct gdb_data *data)$/;"	f	file:
+result	simio/simio_hwmult.c	/^	uint32_t			result;$/;"	m	struct:hwmult	file:
+rev_bits	util/output.c	/^static int rev_bits(int n)$/;"	f	file:
+rev_index	util/powerbuf.c	/^static unsigned int rev_index(powerbuf_t pb, unsigned int n)$/;"	f	file:
+rf2500_open	transport/rf2500.c	/^transport_t rf2500_open(const char *devpath, const char *requested_serial)$/;"	f
+rf2500_transport	transport/rf2500.c	/^static const struct transport_class rf2500_transport = {$/;"	v	typeref:struct:transport_class	file:
+rf2500_transport	transport/rf2500.c	/^struct rf2500_transport {$/;"	s	file:
+ri_cprmask	formats/elf_format.h	/^  Elf32_Word	ri_cprmask[4];		\/* Coprocessor registers used *\/$/;"	m	struct:__anon38
+ri_gp_value	formats/elf_format.h	/^  Elf32_Sword	ri_gp_value;		\/* $gp register value *\/$/;"	m	struct:__anon38
+ri_gprmask	formats/elf_format.h	/^  Elf32_Word	ri_gprmask;		\/* General registers used *\/$/;"	m	struct:__anon38
+root	util/btree.c	/^	struct btree_page       *root;$/;"	m	struct:btree	typeref:struct:btree::btree_page	file:
+run	ui/gdb.c	/^static int run(struct gdb_data *data, char *buf)$/;"	f	file:
+run_final_status	ui/gdb.c	/^static int run_final_status(struct gdb_data *data)$/;"	f	file:
+run_set_pc	ui/gdb.c	/^static int run_set_pc(char *buf)$/;"	f	file:
+running	drivers/sim.c	/^	int                     running;$/;"	m	struct:sim_device	file:
+samples	ui/power.c	/^	int			samples;$/;"	m	struct:profile_rec	file:
+savemap_cb	ui/sym.c	/^static int savemap_cb(void *user_data, const char *name, address_t value)$/;"	f	file:
+sc_all	ui/power.c	/^static int sc_all(powerbuf_t pb, char **arg)$/;"	f	file:
+sc_clear	ui/power.c	/^static int sc_clear(powerbuf_t pb)$/;"	f	file:
+sc_export_csv	ui/power.c	/^static int sc_export_csv(powerbuf_t pb, char **arg)$/;"	f	file:
+sc_info	ui/power.c	/^static int sc_info(powerbuf_t pb)$/;"	f	file:
+sc_profile	ui/power.c	/^static int sc_profile(powerbuf_t pb)$/;"	f	file:
+sc_session	ui/power.c	/^static int sc_session(powerbuf_t pb, char **arg)$/;"	f	file:
+sdeviceID	drivers/devicelist.c	/^const struct device_table sdeviceID[289] =$/;"	v	typeref:struct:device_table
+search	drivers/device.h	/^	int (*search)(device_t dev_base, address_t num_instr, int is_reg, address_t reg_mem, address_t reg_val);$/;"	m	struct:device_class
+search_node	drivers/sim.c	/^typedef struct search_node {$/;"	s	file:
+search_node	drivers/sim.c	/^} search_node;$/;"	t	typeref:struct:search_node	file:
+sec_count	formats/coff.c	/^	int             sec_count;$/;"	m	struct:coff_header	file:
+section	formats/elf_format.h	/^  Elf32_Section section;	\/* Section header index of section affected,$/;"	m	struct:__anon39
+section	util/prog.h	/^	char		section[64];$/;"	m	struct:prog_data
+segoff	ui/devcmd.c	/^	uint16_t        segoff;$/;"	m	struct:hexout_data	file:
+send	transport/transport.h	/^	int (*send)(transport_t tr, const uint8_t *data, int len);$/;"	m	struct:transport_class
+send_command	drivers/bsl.c	/^static int send_command(struct bsl_device *dev,$/;"	f	file:
+send_command	drivers/fet_proto.c	/^static int send_command(struct fet_proto *dev, int command_code,$/;"	f	file:
+send_packet	drivers/goodfet.c	/^static int send_packet(sport_t fd,$/;"	f	file:
+send_rf2500_data	drivers/fet_proto.c	/^static int send_rf2500_data(struct fet_proto *dev,$/;"	f	file:
+serial	drivers/bsl.c	/^	transport_t     serial;$/;"	m	struct:bsl_device	file:
+serial_destroy	transport/comport.c	/^static void serial_destroy(transport_t tr_base)$/;"	f	file:
+serial_fd	drivers/flash_bsl.c	/^	sport_t		serial_fd;$/;"	m	struct:flash_bsl_device	file:
+serial_fd	drivers/goodfet.c	/^	sport_t			serial_fd;$/;"	m	struct:goodfet	file:
+serial_fd	transport/comport.c	/^	sport_t                 serial_fd;$/;"	m	struct:comport_transport	file:
+serial_flush	transport/comport.c	/^static int serial_flush(transport_t tr_base)$/;"	f	file:
+serial_recv	transport/comport.c	/^static int serial_recv(transport_t tr_base, uint8_t *data, int max_len)$/;"	f	file:
+serial_send	transport/comport.c	/^static int serial_send(transport_t tr_base, const uint8_t *data, int len)$/;"	f	file:
+serial_set_modem	transport/comport.c	/^static int serial_set_modem(transport_t tr_base, transport_modem_t state)$/;"	f	file:
+session_head	util/powerbuf.h	/^	unsigned int			session_head;$/;"	m	struct:powerbuf
+session_length	util/powerbuf.c	/^static unsigned int session_length(powerbuf_t pb, unsigned int idx)$/;"	f	file:
+session_tail	util/powerbuf.h	/^	unsigned int			session_tail;$/;"	m	struct:powerbuf
+sessions	util/powerbuf.h	/^	struct powerbuf_session		sessions[POWERBUF_MAX_SESSIONS];$/;"	m	struct:powerbuf	typeref:struct:powerbuf::powerbuf_session
+set_breakpoint	ui/gdb.c	/^static int set_breakpoint(struct gdb_data *data, int enable, char *buf)$/;"	f	file:
+set_mcr	transport/ti3410.c	/^static int set_mcr(struct ti3410_transport *tr)$/;"	f	file:
+set_modem	transport/transport.h	/^	int (*set_modem)(transport_t tr, transport_modem_t state);$/;"	m	struct:transport_class
+set_nonstandard_rate	util/sport.c	/^static int set_nonstandard_rate(int fd, struct termios *attr, int rate)$/;"	f	file:
+set_termios	transport/ti3410.c	/^static int set_termios(struct ti3410_transport *tr)$/;"	f	file:
+setregs	drivers/device.h	/^	int (*setregs)(device_t dev, const address_t *regs);$/;"	m	struct:device_class
+setup_driver	ui/main.c	/^int setup_driver(struct cmdline_args *args)$/;"	f
+setup_port	transport/ti3410.c	/^static int setup_port(struct ti3410_transport *tr)$/;"	f	file:
+sfr_data	simio/simio.c	/^static uint8_t sfr_data[16];$/;"	v	file:
+sh_addr	formats/elf_format.h	/^  Elf32_Addr	sh_addr;		\/* Section virtual addr at execution *\/$/;"	m	struct:__anon3
+sh_addr	formats/elf_format.h	/^  Elf64_Addr	sh_addr;		\/* Section virtual addr at execution *\/$/;"	m	struct:__anon4
+sh_addralign	formats/elf_format.h	/^  Elf32_Word	sh_addralign;		\/* Section alignment *\/$/;"	m	struct:__anon3
+sh_addralign	formats/elf_format.h	/^  Elf64_Xword	sh_addralign;		\/* Section alignment *\/$/;"	m	struct:__anon4
+sh_entsize	formats/elf_format.h	/^  Elf32_Word	sh_entsize;		\/* Entry size if section holds table *\/$/;"	m	struct:__anon3
+sh_entsize	formats/elf_format.h	/^  Elf64_Xword	sh_entsize;		\/* Entry size if section holds table *\/$/;"	m	struct:__anon4
+sh_flags	formats/elf_format.h	/^  Elf32_Word	sh_flags;		\/* Section flags *\/$/;"	m	struct:__anon3
+sh_flags	formats/elf_format.h	/^  Elf64_Xword	sh_flags;		\/* Section flags *\/$/;"	m	struct:__anon4
+sh_info	formats/elf_format.h	/^  Elf32_Word	sh_info;		\/* Additional section information *\/$/;"	m	struct:__anon3
+sh_info	formats/elf_format.h	/^  Elf64_Word	sh_info;		\/* Additional section information *\/$/;"	m	struct:__anon4
+sh_link	formats/elf_format.h	/^  Elf32_Word	sh_link;		\/* Link to another section *\/$/;"	m	struct:__anon3
+sh_link	formats/elf_format.h	/^  Elf64_Word	sh_link;		\/* Link to another section *\/$/;"	m	struct:__anon4
+sh_name	formats/elf_format.h	/^  Elf32_Word	sh_name;		\/* Section name (string tbl index) *\/$/;"	m	struct:__anon3
+sh_name	formats/elf_format.h	/^  Elf64_Word	sh_name;		\/* Section name (string tbl index) *\/$/;"	m	struct:__anon4
+sh_offset	formats/elf_format.h	/^  Elf32_Off	sh_offset;		\/* Section file offset *\/$/;"	m	struct:__anon3
+sh_offset	formats/elf_format.h	/^  Elf64_Off	sh_offset;		\/* Section file offset *\/$/;"	m	struct:__anon4
+sh_size	formats/elf_format.h	/^  Elf32_Word	sh_size;		\/* Section size in bytes *\/$/;"	m	struct:__anon3
+sh_size	formats/elf_format.h	/^  Elf64_Xword	sh_size;		\/* Section size in bytes *\/$/;"	m	struct:__anon4
+sh_type	formats/elf_format.h	/^  Elf32_Word	sh_type;		\/* Section type *\/$/;"	m	struct:__anon3
+sh_type	formats/elf_format.h	/^  Elf64_Word	sh_type;		\/* Section type *\/$/;"	m	struct:__anon4
+shell_power	drivers/fet_core.c	/^static void shell_power(const uint8_t *data, int len)$/;"	f	file:
+show_dev_info	drivers/fet_core.c	/^static void show_dev_info(const char *name, const struct fet_device *dev)$/;"	f	file:
+show_regs	util/output_util.c	/^void show_regs(const address_t *regs)$/;"	f
+si_boundto	formats/elf_format.h	/^  Elf32_Half si_boundto;		\/* Direct bindings, symbol bound to *\/$/;"	m	struct:__anon7
+si_boundto	formats/elf_format.h	/^  Elf64_Half si_boundto;		\/* Direct bindings, symbol bound to *\/$/;"	m	struct:__anon8
+si_flags	formats/elf_format.h	/^  Elf32_Half si_flags;			\/* Per symbol flags *\/$/;"	m	struct:__anon7
+si_flags	formats/elf_format.h	/^  Elf64_Half si_flags;			\/* Per symbol flags *\/$/;"	m	struct:__anon8
+sibling	drivers/sim.c	/^	struct search_node *sibling;$/;"	m	struct:search_node	typeref:struct:search_node::search_node	file:
+sift_down	util/powerbuf.c	/^static void sift_down(powerbuf_t pb, int start, int end)$/;"	f	file:
+sigint_handler	util/ctrlc.c	/^static void sigint_handler(int signum)$/;"	f	file:
+sim_ctl	drivers/sim.c	/^static int sim_ctl(device_t dev_base, device_ctl_t op)$/;"	f	file:
+sim_destroy	drivers/sim.c	/^static void sim_destroy(device_t dev_base)$/;"	f	file:
+sim_device	drivers/sim.c	/^struct sim_device {$/;"	s	file:
+sim_erase	drivers/sim.c	/^static int sim_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+sim_getregs	drivers/sim.c	/^static int sim_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+sim_intsc	drivers/sim.c	/^static int sim_intsc(device_t dev_base, address_t vector_addr,$/;"	f	file:
+sim_open	drivers/sim.c	/^static device_t sim_open(const struct device_args *args)$/;"	f	file:
+sim_poll	drivers/sim.c	/^static device_status_t sim_poll(device_t dev_base)$/;"	f	file:
+sim_readmem	drivers/sim.c	/^static int sim_readmem(device_t dev_base, address_t addr,$/;"	f	file:
+sim_search	drivers/sim.c	/^static int sim_search(device_t dev_base, address_t num_instr, $/;"	f	file:
+sim_search2	drivers/sim.c	/^static int sim_search2(device_t dev_base, address_t num_instr, $/;"	f	file:
+sim_setregs	drivers/sim.c	/^static int sim_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+sim_writemem	drivers/sim.c	/^static int sim_writemem(device_t dev_base, address_t addr,$/;"	f	file:
+simio_ack_interrupt	simio/simio.c	/^void simio_ack_interrupt(int irq)$/;"	f
+simio_check_interrupt	simio/simio.c	/^int simio_check_interrupt(void)$/;"	f
+simio_class	simio/simio_device.h	/^struct simio_class {$/;"	s
+simio_clock_t	simio/simio_device.h	/^} simio_clock_t;$/;"	t	typeref:enum:__anon63
+simio_console	simio/simio_console.c	/^const struct simio_class simio_console = {$/;"	v	typeref:struct:simio_class
+simio_device	simio/simio_device.h	/^struct simio_device {$/;"	s
+simio_exit	simio/simio.c	/^void simio_exit(void)$/;"	f
+simio_gpio	simio/simio_gpio.c	/^const struct simio_class simio_gpio = {$/;"	v	typeref:struct:simio_class
+simio_hwmult	simio/simio_hwmult.c	/^const struct simio_class simio_hwmult = {$/;"	v	typeref:struct:simio_class
+simio_init	simio/simio.c	/^void simio_init(void)$/;"	f
+simio_read_b	simio/simio.c	/^int simio_read_b(address_t addr, uint8_t *data)$/;"	f
+simio_reset	simio/simio.c	/^void simio_reset(void)$/;"	f
+simio_sfr_get	simio/simio.c	/^uint8_t simio_sfr_get(address_t which)$/;"	f
+simio_sfr_modify	simio/simio.c	/^void simio_sfr_modify(address_t which, uint8_t mask, uint8_t bits)$/;"	f
+simio_step	simio/simio.c	/^void simio_step(uint16_t status_register, int cycles)$/;"	f
+simio_timer	simio/simio_timer.c	/^const struct simio_class simio_timer = {$/;"	v	typeref:struct:simio_class
+simio_tracer	simio/simio_tracer.c	/^const struct simio_class simio_tracer = {$/;"	v	typeref:struct:simio_class
+simio_wdt	simio/simio_wdt.c	/^const struct simio_class simio_wdt = {$/;"	v	typeref:struct:simio_class
+single_step	ui/gdb.c	/^static int single_step(struct gdb_data *data, char *buf)$/;"	f	file:
+size	formats/elf_format.h	/^  unsigned char size;		\/* Size of descriptor, including header.  *\/$/;"	m	struct:__anon39
+size	simio/simio_timer.c	/^	int			size;$/;"	m	struct:timer	file:
+size	simio/simio_tracer.c	/^	int			size;$/;"	m	struct:tracer	file:
+size	transport/ti3410.c	/^	unsigned int	size;$/;"	m	struct:firmware	file:
+size	util/vector.h	/^	int             size;$/;"	m	struct:vector
+size_for	util/vector.c	/^static int size_for(struct vector *v, int needed)$/;"	f	file:
+slot	util/btree.c	/^	int                     slot[MAX_HEIGHT];$/;"	m	struct:btree	file:
+sock	util/gdb_proto.h	/^	int             sock;$/;"	m	struct:gdb_data
+sockets_accept	util/sockets.c	/^SOCKET sockets_accept(SOCKET s, struct sockaddr *addr, socklen_t *addrlen)$/;"	f
+sockets_begin	util/sockets.c	/^static void sockets_begin(SOCKET s, DWORD event)$/;"	f	file:
+sockets_connect	util/sockets.c	/^int sockets_connect(SOCKET s, const struct sockaddr *addr, socklen_t addrlen)$/;"	f
+sockets_end	util/sockets.c	/^static void sockets_end(SOCKET s)$/;"	f	file:
+sockets_exit	ui/main.c	/^static void sockets_exit(void) { }$/;"	f	file:
+sockets_exit	ui/main.c	/^static void sockets_exit(void)$/;"	f	file:
+sockets_init	ui/main.c	/^static int sockets_init(void) { return 0; }$/;"	f	file:
+sockets_init	ui/main.c	/^static int sockets_init(void)$/;"	f	file:
+sockets_recv	util/sockets.c	/^ssize_t sockets_recv(SOCKET s, void *buf, size_t buf_len, int flags,$/;"	f
+sockets_recv	util/sockets.c	/^ssize_t sockets_recv(SOCKET s, void *buf, size_t len, int flags,$/;"	f
+sockets_send	util/sockets.c	/^ssize_t sockets_send(SOCKET s, const void *buf, size_t len, int flags)$/;"	f
+sockets_wait	util/sockets.c	/^static int sockets_wait(DWORD timeout)$/;"	f	file:
+socklen_t	util/sockets.h	/^typedef int socklen_t;$/;"	t
+sort_valid	util/powerbuf.h	/^	int				sort_valid;$/;"	m	struct:powerbuf
+sorted	util/powerbuf.h	/^	unsigned int			*sorted;$/;"	m	struct:powerbuf
+split_page	util/btree.c	/^static void split_page(struct btree_page *op, struct btree_page *np)$/;"	f	file:
+sport_close	util/sport.c	/^void sport_close(sport_t s)$/;"	f
+sport_flush	util/sport.c	/^int sport_flush(sport_t s)$/;"	f
+sport_open	util/sport.c	/^sport_t sport_open(const char *device, int rate, int flags)$/;"	f
+sport_read	util/sport.c	/^int sport_read(sport_t s, uint8_t *data, int len)$/;"	f
+sport_read_all	util/sport.c	/^int sport_read_all(sport_t s, uint8_t *data, int len)$/;"	f
+sport_set_modem	util/sport.c	/^int sport_set_modem(sport_t s, int bits)$/;"	f
+sport_t	util/sport.h	/^typedef HANDLE sport_t;$/;"	t
+sport_t	util/sport.h	/^typedef int sport_t;$/;"	t
+sport_write	util/sport.c	/^int sport_write(sport_t s, const uint8_t *data, int len)$/;"	f
+sport_write_all	util/sport.c	/^int sport_write_all(sport_t s, const uint8_t *data, int len)$/;"	f
+src	ui/aliasdb.c	/^	char	src[256];$/;"	m	struct:alias	file:
+src	ui/rtools.c	/^	address_t       src;$/;"	m	struct:cg_edge	file:
+src_addr	util/dis.h	/^	address_t               src_addr;$/;"	m	struct:msp430_instruction
+src_mode	util/dis.h	/^	msp430_amode_t          src_mode;$/;"	m	struct:msp430_instruction
+src_reg	util/dis.h	/^	msp430_reg_t            src_reg;$/;"	m	struct:msp430_instruction
+srec_check	formats/srec.c	/^int srec_check(FILE *in)$/;"	f
+srec_extract	formats/srec.c	/^int srec_extract(FILE *in, binfile_imgcb_t cb, void *user_data)$/;"	f
+st_info	formats/elf_format.h	/^  unsigned char	st_info;		\/* Symbol type and binding *\/$/;"	m	struct:__anon5
+st_info	formats/elf_format.h	/^  unsigned char	st_info;		\/* Symbol type and binding *\/$/;"	m	struct:__anon6
+st_name	formats/elf_format.h	/^  Elf32_Word	st_name;		\/* Symbol name (string tbl index) *\/$/;"	m	struct:__anon5
+st_name	formats/elf_format.h	/^  Elf64_Word	st_name;		\/* Symbol name (string tbl index) *\/$/;"	m	struct:__anon6
+st_other	formats/elf_format.h	/^  unsigned char	st_other;		\/* Symbol visibility *\/$/;"	m	struct:__anon5
+st_other	formats/elf_format.h	/^  unsigned char st_other;		\/* Symbol visibility *\/$/;"	m	struct:__anon6
+st_shndx	formats/elf_format.h	/^  Elf32_Section	st_shndx;		\/* Section index *\/$/;"	m	struct:__anon5
+st_shndx	formats/elf_format.h	/^  Elf64_Section	st_shndx;		\/* Section index *\/$/;"	m	struct:__anon6
+st_size	formats/elf_format.h	/^  Elf32_Word	st_size;		\/* Symbol size *\/$/;"	m	struct:__anon5
+st_size	formats/elf_format.h	/^  Elf64_Xword	st_size;		\/* Symbol size *\/$/;"	m	struct:__anon6
+st_value	formats/elf_format.h	/^  Elf32_Addr	st_value;		\/* Symbol value *\/$/;"	m	struct:__anon5
+st_value	formats/elf_format.h	/^  Elf64_Addr	st_value;		\/* Symbol value *\/$/;"	m	struct:__anon6
+stab_addr	util/stab.c	/^static btree_t         stab_addr;$/;"	v	file:
+stab_callback_t	util/stab.h	/^typedef int (*stab_callback_t)(void *user_data,$/;"	t
+stab_clear	util/stab.c	/^void stab_clear(void)$/;"	f
+stab_count	formats/coff.c	/^	int             stab_count;$/;"	m	struct:coff_header	file:
+stab_del	util/stab.c	/^int stab_del(const char *name)$/;"	f
+stab_enum	util/stab.c	/^int stab_enum(stab_callback_t cb, void *user_data)$/;"	f
+stab_exit	util/stab.c	/^void stab_exit(void)$/;"	f
+stab_get	util/stab.c	/^int stab_get(const char *name, address_t *value)$/;"	f
+stab_init	util/stab.c	/^int stab_init(void)$/;"	f
+stab_nearest	util/stab.c	/^int stab_nearest(address_t addr, char *ret_name, int max_len,$/;"	f
+stab_set	util/stab.c	/^int stab_set(const char *name, int value)$/;"	f
+stab_start	formats/coff.c	/^	int             stab_start;$/;"	m	struct:coff_header	file:
+stab_sym	util/stab.c	/^static btree_t         stab_sym;$/;"	v	file:
+start	ui/sym.c	/^	int     start, end;$/;"	m	struct:rename_record	file:
+start_index	util/powerbuf.h	/^	unsigned int		start_index;$/;"	m	struct:powerbuf_session
+state	drivers/fet_proto.h	/^	int				state;$/;"	m	struct:fet_proto
+state	ui/input_async.c	/^	mailbox_state_t		state;$/;"	m	struct:mailbox	file:
+step	simio/simio_device.h	/^	void (*step)(struct simio_device *dev,$/;"	m	struct:simio_class
+step_cpu	drivers/sim.c	/^static int step_cpu(struct sim_device *dev)$/;"	f	file:
+step_double	drivers/sim.c	/^static int step_double(struct sim_device *dev, uint16_t ins)$/;"	f	file:
+step_jump	drivers/sim.c	/^static int step_jump(struct sim_device *dev, uint16_t ins)$/;"	f	file:
+step_single	drivers/sim.c	/^static int step_single(struct sim_device *dev, uint16_t ins)$/;"	f	file:
+step_system	drivers/sim.c	/^static int step_system(struct sim_device *dev)$/;"	f	file:
+store_operand	drivers/sim.c	/^static int store_operand(struct sim_device *dev,$/;"	f	file:
+string	drivers/tilib_defs.h	/^		BYTE  string[32];$/;"	m	struct:DEVICE_T::__anon45
+string	util/opdb.h	/^	char            string[128];$/;"	m	union:opdb_value
+string_len	formats/elf32.c	/^	int                     string_len;$/;"	m	struct:elf32_info	file:
+string_tab	formats/elf32.c	/^	char                    *string_tab;$/;"	m	struct:elf32_info	file:
+strsep	util/util.c	/^char *strsep(char **strp, const char *delim)$/;"	f
+sumext	simio/simio_hwmult.c	/^	uint16_t			sumext;$/;"	m	struct:hwmult	file:
+sym_key	util/stab.c	/^struct sym_key {$/;"	s	file:
+sym_key_compare	util/stab.c	/^static int sym_key_compare(const void *left, const void *right)$/;"	f	file:
+sym_key_init	util/stab.c	/^static void sym_key_init(struct sym_key *key, const char *text)$/;"	f	file:
+sym_key_zero	util/stab.c	/^static const struct sym_key sym_key_zero = {$/;"	v	typeref:struct:sym_key	file:
+sym_table_def	util/stab.c	/^static const struct btree_def sym_table_def = {$/;"	v	typeref:struct:btree_def	file:
+symmap_check	formats/symmap.c	/^int symmap_check(FILE *in)$/;"	f
+symmap_syms	formats/symmap.c	/^int symmap_syms(FILE *in)$/;"	f
+syms	formats/binfile.c	/^	int (*syms)(FILE *in);$/;"	m	struct:file_format	file:
+syms_load_syms	formats/elf32.c	/^static int syms_load_syms(struct elf32_info *info, FILE *in,$/;"	f	file:
+tactl	simio/simio_timer.c	/^	uint16_t		tactl;$/;"	m	struct:timer	file:
+tail	simio/simio_tracer.c	/^	int			tail;$/;"	m	struct:tracer	file:
+tail	util/gdb_proto.h	/^	int             tail;$/;"	m	struct:gdb_data
+tar	simio/simio_timer.c	/^	uint16_t		tar;$/;"	m	struct:timer	file:
+tar_step	simio/simio_timer.c	/^static void tar_step(struct timer *tr)$/;"	f	file:
+target_id	formats/coff.c	/^	uint16_t        target_id;$/;"	m	struct:coff_header	file:
+teardown_port	transport/ti3410.c	/^static void teardown_port(struct ti3410_transport *tr)$/;"	f	file:
+text	ui/input_async.c	/^	char			text[MAX_LINE_LENGTH];$/;"	m	struct:mailbox	file:
+thread_cond_destroy	util/thread.h	/^static inline void thread_cond_destroy(thread_cond_t *c) {$/;"	f
+thread_cond_destroy	util/thread.h	/^static inline void thread_cond_destroy(thread_cond_t *c)$/;"	f
+thread_cond_init	util/thread.h	/^static inline void thread_cond_init(thread_cond_t *c)$/;"	f
+thread_cond_notify	util/thread.h	/^static inline void thread_cond_notify(thread_cond_t *c)$/;"	f
+thread_cond_t	util/thread.h	/^typedef HANDLE thread_cond_t;$/;"	t
+thread_cond_t	util/thread.h	/^typedef pthread_cond_t thread_cond_t;$/;"	t
+thread_cond_wait	util/thread.h	/^static inline void thread_cond_wait(thread_cond_t *c, thread_lock_t *m)$/;"	f
+thread_create	util/thread.h	/^static inline int thread_create(thread_t *t, thread_func_t func, void *arg)$/;"	f
+thread_func_t	util/thread.h	/^typedef void (*thread_func_t)(void *user_data);$/;"	t
+thread_join	util/thread.h	/^static inline void thread_join(thread_t t)$/;"	f
+thread_lock_acquire	util/thread.h	/^static inline void thread_lock_acquire(thread_lock_t *lock)$/;"	f
+thread_lock_destroy	util/thread.h	/^static inline void thread_lock_destroy(thread_lock_t *lock)$/;"	f
+thread_lock_init	util/thread.h	/^static inline void thread_lock_init(thread_lock_t *lock)$/;"	f
+thread_lock_release	util/thread.h	/^static inline void thread_lock_release(thread_lock_t *lock)$/;"	f
+thread_lock_t	util/thread.h	/^typedef CRITICAL_SECTION thread_lock_t;$/;"	t
+thread_lock_t	util/thread.h	/^typedef pthread_mutex_t thread_lock_t;$/;"	t
+thread_t	util/thread.h	/^typedef HANDLE thread_t;$/;"	t
+thread_t	util/thread.h	/^typedef pthread_t thread_t;$/;"	t
+ti3410_destroy	transport/ti3410.c	/^static void ti3410_destroy(transport_t tr_base)$/;"	f	file:
+ti3410_flush	transport/ti3410.c	/^static int ti3410_flush(transport_t tr_base)$/;"	f	file:
+ti3410_open	transport/ti3410.c	/^transport_t ti3410_open(const char *devpath, const char *requested_serial)$/;"	f
+ti3410_recv	transport/ti3410.c	/^static int ti3410_recv(transport_t tr_base, uint8_t *databuf, int max_len)$/;"	f	file:
+ti3410_send	transport/ti3410.c	/^static int ti3410_send(transport_t tr_base, const uint8_t *data, int len)$/;"	f	file:
+ti3410_set_modem	transport/ti3410.c	/^static int ti3410_set_modem(transport_t tr_base, transport_modem_t state)$/;"	f	file:
+ti3410_transport	transport/ti3410.c	/^static const struct transport_class ti3410_transport = {$/;"	v	typeref:struct:transport_class	file:
+ti3410_transport	transport/ti3410.c	/^struct ti3410_transport {$/;"	s	file:
+ti_erase_type	drivers/tilib.c	/^static long ti_erase_type(device_erase_type_t e)$/;"	f	file:
+tilib_ctl	drivers/tilib.c	/^static int tilib_ctl(device_t dev_base, device_ctl_t op)$/;"	f	file:
+tilib_destroy	drivers/tilib.c	/^static void tilib_destroy(device_t dev_base)$/;"	f	file:
+tilib_device	drivers/tilib.c	/^struct tilib_device {$/;"	s	file:
+tilib_erase	drivers/tilib.c	/^static int tilib_erase(device_t dev_base, device_erase_type_t type,$/;"	f	file:
+tilib_filename	drivers/tilib.c	/^static const char tilib_filename[] = "MSP430.DLL";$/;"	v	file:
+tilib_filename	drivers/tilib.c	/^static const char tilib_filename[] = "libmsp430.so";$/;"	v	file:
+tilib_getregs	drivers/tilib.c	/^static int tilib_getregs(device_t dev_base, address_t *regs)$/;"	f	file:
+tilib_open	drivers/tilib.c	/^static device_t tilib_open(const struct device_args *args)$/;"	f	file:
+tilib_poll	drivers/tilib.c	/^static device_status_t tilib_poll(device_t dev_base)$/;"	f	file:
+tilib_readmem	drivers/tilib.c	/^static int tilib_readmem(device_t dev_base, address_t addr,$/;"	f	file:
+tilib_setregs	drivers/tilib.c	/^static int tilib_setregs(device_t dev_base, const address_t *regs)$/;"	f	file:
+tilib_writemem	drivers/tilib.c	/^static int tilib_writemem(device_t dev_base, address_t addr,$/;"	f	file:
+timer	simio/simio_timer.c	/^struct timer {$/;"	s	file:
+timer_ack_interrupt	simio/simio_timer.c	/^static void timer_ack_interrupt(struct simio_device *dev, int irq)$/;"	f	file:
+timer_check_interrupt	simio/simio_timer.c	/^static int timer_check_interrupt(struct simio_device *dev)$/;"	f	file:
+timer_config	simio/simio_timer.c	/^static int timer_config(struct simio_device *dev,$/;"	f	file:
+timer_create	simio/simio_timer.c	/^static struct simio_device *timer_create(char **arg_text)$/;"	f	file:
+timer_destroy	simio/simio_timer.c	/^static void timer_destroy(struct simio_device *dev)$/;"	f	file:
+timer_info	simio/simio_timer.c	/^static int timer_info(struct simio_device *dev)$/;"	f	file:
+timer_read	simio/simio_timer.c	/^static int timer_read(struct simio_device *dev,$/;"	f	file:
+timer_reset	simio/simio_timer.c	/^static void timer_reset(struct simio_device *dev)$/;"	f	file:
+timer_step	simio/simio_timer.c	/^static void timer_step(struct simio_device *dev,$/;"	f	file:
+timer_write	simio/simio_timer.c	/^static int timer_write(struct simio_device *dev,$/;"	f	file:
+timestamp	formats/coff.c	/^	uint32_t        timestamp;$/;"	m	struct:coff_header	file:
+titext_check	formats/titext.c	/^int titext_check(FILE *in)$/;"	f
+titext_extract	formats/titext.c	/^int titext_extract(FILE *in, binfile_imgcb_t cb, void *user_data)$/;"	f
+total	drivers/obl.c	/^	uint32_t	total;$/;"	m	struct:progress_meter	file:
+total_ua	util/powerbuf.h	/^	unsigned long long	total_ua;$/;"	m	struct:powerbuf_session
+total_written	util/prog.h	/^	address_t	total_written;$/;"	m	struct:prog_data
+tr_destroy	transport/ftdi.c	/^static void tr_destroy(transport_t tr_base)$/;"	f	file:
+tr_flush	transport/ftdi.c	/^static int tr_flush(transport_t tr_base)$/;"	f	file:
+tr_recv	transport/ftdi.c	/^static int tr_recv(transport_t tr_base, uint8_t *databuf, int max_len)$/;"	f	file:
+tr_send	transport/ftdi.c	/^static int tr_send(transport_t tr_base, const uint8_t *databuf, int len)$/;"	f	file:
+tr_set_modem	transport/ftdi.c	/^static int tr_set_modem(transport_t tr_base, transport_modem_t state)$/;"	f	file:
+trace_path	util/btree.c	/^static int trace_path(btree_t bt, const void *key,$/;"	f	file:
+tracer	simio/simio_tracer.c	/^struct tracer {$/;"	s	file:
+tracer_ack_interrupt	simio/simio_tracer.c	/^static void tracer_ack_interrupt(struct simio_device *dev, int irq)$/;"	f	file:
+tracer_check_interrupt	simio/simio_tracer.c	/^static int tracer_check_interrupt(struct simio_device *dev)$/;"	f	file:
+tracer_config	simio/simio_tracer.c	/^static int tracer_config(struct simio_device *dev,$/;"	f	file:
+tracer_create	simio/simio_tracer.c	/^static struct simio_device *tracer_create(char **arg_text)$/;"	f	file:
+tracer_destroy	simio/simio_tracer.c	/^static void tracer_destroy(struct simio_device *dev)$/;"	f	file:
+tracer_info	simio/simio_tracer.c	/^static int tracer_info(struct simio_device *dev)$/;"	f	file:
+tracer_read	simio/simio_tracer.c	/^static int tracer_read(struct simio_device *dev,$/;"	f	file:
+tracer_read_b	simio/simio_tracer.c	/^static int tracer_read_b(struct simio_device *dev,$/;"	f	file:
+tracer_reset	simio/simio_tracer.c	/^static void tracer_reset(struct simio_device *dev)$/;"	f	file:
+tracer_step	simio/simio_tracer.c	/^static void tracer_step(struct simio_device *dev,$/;"	f	file:
+tracer_write	simio/simio_tracer.c	/^static int tracer_write(struct simio_device *dev,$/;"	f	file:
+tracer_write_b	simio/simio_tracer.c	/^static int tracer_write_b(struct simio_device *dev,$/;"	f	file:
+translate_alias	ui/aliasdb.c	/^int translate_alias(const char *command, const char *args,$/;"	f
+translate_rec	ui/aliasdb.c	/^static int translate_rec(struct recurse_list *l,$/;"	f	file:
+transport	drivers/fet_proto.h	/^	transport_t			transport;$/;"	m	struct:fet_proto
+transport	transport/transport.h	/^struct transport {$/;"	s
+transport_class	transport/transport.h	/^struct transport_class {$/;"	s
+transport_modem_t	transport/transport.h	/^} transport_modem_t;$/;"	t	typeref:enum:__anon43
+transport_read_all	drivers/obl.c	/^static int transport_read_all(transport_t tr, uint8_t *data, int len)$/;"	f	file:
+transport_t	transport/transport.h	/^typedef struct transport *transport_t;$/;"	t	typeref:struct:transport
+trigger_interrupt	drivers/sim.c	/^void trigger_interrupt(struct sim_device *dev, int irq)$/;"	f
+trigger_interrupt_set_flags	drivers/sim.c	/^void trigger_interrupt_set_flags(struct sim_device *dev, int irq, interrupt_t type)$/;"	f
+trunc	ui/gdb.c	/^	int	trunc;$/;"	m	struct:monitor_buf	file:
+try_new	drivers/fet_core.c	/^static int try_new(struct fet_device *dev, const char *force_id)$/;"	f	file:
+try_open	drivers/fet_core.c	/^int try_open(struct fet_device *dev, const struct device_args *args,$/;"	f
+type	drivers/device.h	/^	const struct device_class	*type;$/;"	m	struct:device	typeref:struct:device::device_class
+type	drivers/device.h	/^	device_bptype_t		type;$/;"	m	struct:device_breakpoint
+type	drivers/sim.c	/^	interrupt_t type;$/;"	m	struct:search_node	file:
+type	simio/simio_device.h	/^	const struct simio_class	*type;$/;"	m	struct:simio_device	typeref:struct:simio_device::simio_class
+type	util/opdb.h	/^	opdb_type_t		type;$/;"	m	struct:opdb_key
+type_text	ui/stdcmd.c	/^static const char *type_text(opdb_type_t type)$/;"	f	file:
+uiMsgIdBreakpoint	drivers/tilib_defs.h	/^	ULONG	uiMsgIdBreakpoint;$/;"	m	struct:MESSAGE_ID
+uiMsgIdCPUStopped	drivers/tilib_defs.h	/^	ULONG	uiMsgIdCPUStopped;$/;"	m	struct:MESSAGE_ID
+uiMsgIdSingleStep	drivers/tilib_defs.h	/^	ULONG	uiMsgIdSingleStep;$/;"	m	struct:MESSAGE_ID
+uiMsgIdState	drivers/tilib_defs.h	/^	ULONG	uiMsgIdState;$/;"	m	struct:MESSAGE_ID
+uiMsgIdStorage	drivers/tilib_defs.h	/^	ULONG	uiMsgIdStorage;$/;"	m	struct:MESSAGE_ID
+uiMsgIdWarning	drivers/tilib_defs.h	/^	ULONG	uiMsgIdWarning;$/;"	m	struct:MESSAGE_ID
+uifPath	drivers/tilib.c	/^	char			uifPath[1024];$/;"	m	struct:tilib_device	file:
+unmark_modified	ui/reader.c	/^void unmark_modified(int flags)$/;"	f
+usage	ui/main.c	/^static void usage(const char *progname)$/;"	f	file:
+usbtr_destroy	transport/cdc_acm.c	/^static void usbtr_destroy(transport_t tr_base)$/;"	f	file:
+usbtr_destroy	transport/cp210x.c	/^static void usbtr_destroy(transport_t tr_base)$/;"	f	file:
+usbtr_destroy	transport/rf2500.c	/^static void usbtr_destroy(transport_t tr_base)$/;"	f	file:
+usbtr_flush	transport/cdc_acm.c	/^static int usbtr_flush(transport_t tr_base)$/;"	f	file:
+usbtr_flush	transport/cp210x.c	/^static int usbtr_flush(transport_t tr_base)$/;"	f	file:
+usbtr_flush	transport/rf2500.c	/^static int usbtr_flush(transport_t tr_base)$/;"	f	file:
+usbtr_recv	transport/cdc_acm.c	/^static int usbtr_recv(transport_t tr_base, uint8_t *databuf, int len)$/;"	f	file:
+usbtr_recv	transport/cp210x.c	/^static int usbtr_recv(transport_t tr_base, uint8_t *databuf, int max_len)$/;"	f	file:
+usbtr_recv	transport/rf2500.c	/^static int usbtr_recv(transport_t tr_base, uint8_t *databuf, int max_len)$/;"	f	file:
+usbtr_send	transport/cdc_acm.c	/^static int usbtr_send(transport_t tr_base, const uint8_t *data, int len)$/;"	f	file:
+usbtr_send	transport/cp210x.c	/^static int usbtr_send(transport_t tr_base, const uint8_t *data, int len)$/;"	f	file:
+usbtr_send	transport/rf2500.c	/^static int usbtr_send(transport_t tr_base, const uint8_t *data, int len)$/;"	f	file:
+usbtr_set_modem	transport/cdc_acm.c	/^static int usbtr_set_modem(transport_t tr_base, transport_modem_t state)$/;"	f	file:
+usbtr_set_modem	transport/cp210x.c	/^static int usbtr_set_modem(transport_t tr_base, transport_modem_t state)$/;"	f	file:
+usbtr_set_modem	transport/rf2500.c	/^static int usbtr_set_modem(transport_t tr_base, transport_modem_t state)$/;"	f	file:
+usbutil_find_by_id	util/usbutil.c	/^struct usb_device *usbutil_find_by_id(int vendor, int product,$/;"	f
+usbutil_find_by_loc	util/usbutil.c	/^struct usb_device *usbutil_find_by_loc(const char *loc)$/;"	f
+usbutil_list	util/usbutil.c	/^void usbutil_list(void)$/;"	f
+values	util/opdb.c	/^static union opdb_value values[ARRAY_LEN(keys)];$/;"	v	typeref:union:opdb_value	file:
+vccMaxOp	drivers/tilib_defs.h	/^		WORD  vccMaxOp;$/;"	m	struct:DEVICE_T::__anon45
+vccMinOp	drivers/tilib_defs.h	/^		WORD  vccMinOp;$/;"	m	struct:DEVICE_T::__anon45
+vcc_mv	drivers/device.h	/^	int			vcc_mv;$/;"	m	struct:device_args
+vd_aux	formats/elf_format.h	/^  Elf32_Word	vd_aux;			\/* Offset in bytes to verdaux array *\/$/;"	m	struct:__anon19
+vd_aux	formats/elf_format.h	/^  Elf64_Word	vd_aux;			\/* Offset in bytes to verdaux array *\/$/;"	m	struct:__anon20
+vd_cnt	formats/elf_format.h	/^  Elf32_Half	vd_cnt;			\/* Number of associated aux entries *\/$/;"	m	struct:__anon19
+vd_cnt	formats/elf_format.h	/^  Elf64_Half	vd_cnt;			\/* Number of associated aux entries *\/$/;"	m	struct:__anon20
+vd_flags	formats/elf_format.h	/^  Elf32_Half	vd_flags;		\/* Version information *\/$/;"	m	struct:__anon19
+vd_flags	formats/elf_format.h	/^  Elf64_Half	vd_flags;		\/* Version information *\/$/;"	m	struct:__anon20
+vd_hash	formats/elf_format.h	/^  Elf32_Word	vd_hash;		\/* Version name hash value *\/$/;"	m	struct:__anon19
+vd_hash	formats/elf_format.h	/^  Elf64_Word	vd_hash;		\/* Version name hash value *\/$/;"	m	struct:__anon20
+vd_ndx	formats/elf_format.h	/^  Elf32_Half	vd_ndx;			\/* Version Index *\/$/;"	m	struct:__anon19
+vd_ndx	formats/elf_format.h	/^  Elf64_Half	vd_ndx;			\/* Version Index *\/$/;"	m	struct:__anon20
+vd_next	formats/elf_format.h	/^  Elf32_Word	vd_next;		\/* Offset in bytes to next verdef$/;"	m	struct:__anon19
+vd_next	formats/elf_format.h	/^  Elf64_Word	vd_next;		\/* Offset in bytes to next verdef$/;"	m	struct:__anon20
+vd_version	formats/elf_format.h	/^  Elf32_Half	vd_version;		\/* Version revision *\/$/;"	m	struct:__anon19
+vd_version	formats/elf_format.h	/^  Elf64_Half	vd_version;		\/* Version revision *\/$/;"	m	struct:__anon20
+vda_name	formats/elf_format.h	/^  Elf32_Word	vda_name;		\/* Version or dependency names *\/$/;"	m	struct:__anon21
+vda_name	formats/elf_format.h	/^  Elf64_Word	vda_name;		\/* Version or dependency names *\/$/;"	m	struct:__anon22
+vda_next	formats/elf_format.h	/^  Elf32_Word	vda_next;		\/* Offset in bytes to next verdaux$/;"	m	struct:__anon21
+vda_next	formats/elf_format.h	/^  Elf64_Word	vda_next;		\/* Offset in bytes to next verdaux$/;"	m	struct:__anon22
+vector	util/vector.h	/^struct vector {$/;"	s
+vector_destroy	util/vector.c	/^void vector_destroy(struct vector *v)$/;"	f
+vector_init	util/vector.c	/^void vector_init(struct vector *v, int elemsize)$/;"	f
+vector_pop	util/vector.c	/^void vector_pop(struct vector *v)$/;"	f
+vector_push	util/vector.c	/^int vector_push(struct vector *v, const void *data, int count)$/;"	f
+vector_realloc	util/vector.c	/^int vector_realloc(struct vector *v, int capacity)$/;"	f
+verb	drivers/goodfet.c	/^	uint8_t		verb;$/;"	m	struct:packet	file:
+verbose	simio/simio_gpio.c	/^	int			verbose;$/;"	m	struct:gpio	file:
+verbose	simio/simio_tracer.c	/^	int			verbose;$/;"	m	struct:tracer	file:
+verify_checksum	drivers/bsl.c	/^static int verify_checksum(struct bsl_device *dev)$/;"	f	file:
+verify_image	drivers/obl.c	/^static int verify_image(transport_t tr, uint32_t addr, uint32_t size,$/;"	f	file:
+version	drivers/fet_core.c	/^	int                             version;$/;"	m	struct:fet_device	file:
+version	formats/coff.c	/^	uint16_t        version;$/;"	m	struct:coff_header	file:
+version_text	ui/main.c	/^static const char *version_text =$/;"	v	file:
+vn_aux	formats/elf_format.h	/^  Elf32_Word	vn_aux;			\/* Offset in bytes to vernaux array *\/$/;"	m	struct:__anon23
+vn_aux	formats/elf_format.h	/^  Elf64_Word	vn_aux;			\/* Offset in bytes to vernaux array *\/$/;"	m	struct:__anon24
+vn_cnt	formats/elf_format.h	/^  Elf32_Half	vn_cnt;			\/* Number of associated aux entries *\/$/;"	m	struct:__anon23
+vn_cnt	formats/elf_format.h	/^  Elf64_Half	vn_cnt;			\/* Number of associated aux entries *\/$/;"	m	struct:__anon24
+vn_file	formats/elf_format.h	/^  Elf32_Word	vn_file;		\/* Offset of filename for this$/;"	m	struct:__anon23
+vn_file	formats/elf_format.h	/^  Elf64_Word	vn_file;		\/* Offset of filename for this$/;"	m	struct:__anon24
+vn_next	formats/elf_format.h	/^  Elf32_Word	vn_next;		\/* Offset in bytes to next verneed$/;"	m	struct:__anon23
+vn_next	formats/elf_format.h	/^  Elf64_Word	vn_next;		\/* Offset in bytes to next verneed$/;"	m	struct:__anon24
+vn_version	formats/elf_format.h	/^  Elf32_Half	vn_version;		\/* Version of structure *\/$/;"	m	struct:__anon23
+vn_version	formats/elf_format.h	/^  Elf64_Half	vn_version;		\/* Version of structure *\/$/;"	m	struct:__anon24
+vna_flags	formats/elf_format.h	/^  Elf32_Half	vna_flags;		\/* Dependency specific information *\/$/;"	m	struct:__anon25
+vna_flags	formats/elf_format.h	/^  Elf64_Half	vna_flags;		\/* Dependency specific information *\/$/;"	m	struct:__anon26
+vna_hash	formats/elf_format.h	/^  Elf32_Word	vna_hash;		\/* Hash value of dependency name *\/$/;"	m	struct:__anon25
+vna_hash	formats/elf_format.h	/^  Elf64_Word	vna_hash;		\/* Hash value of dependency name *\/$/;"	m	struct:__anon26
+vna_name	formats/elf_format.h	/^  Elf32_Word	vna_name;		\/* Dependency name string offset *\/$/;"	m	struct:__anon25
+vna_name	formats/elf_format.h	/^  Elf64_Word	vna_name;		\/* Dependency name string offset *\/$/;"	m	struct:__anon26
+vna_next	formats/elf_format.h	/^  Elf32_Word	vna_next;		\/* Offset in bytes to next vernaux$/;"	m	struct:__anon25
+vna_next	formats/elf_format.h	/^  Elf64_Word	vna_next;		\/* Offset in bytes to next vernaux$/;"	m	struct:__anon26
+vna_other	formats/elf_format.h	/^  Elf32_Half	vna_other;		\/* Unused *\/$/;"	m	struct:__anon25
+vna_other	formats/elf_format.h	/^  Elf64_Half	vna_other;		\/* Unused *\/$/;"	m	struct:__anon26
+wExtCombine	drivers/tilib_defs.h	/^	WORD              wExtCombine;$/;"	m	struct:BREAKPOINT
+wall_clock	util/powerbuf.h	/^	time_t			wall_clock;$/;"	m	struct:powerbuf_session
+want_exit	ui/reader.c	/^static int want_exit;$/;"	v	file:
+watchpoint_check	drivers/sim.c	/^static void watchpoint_check(struct sim_device *dev, uint16_t addr,$/;"	f	file:
+watchpoint_hit	drivers/sim.c	/^	int			watchpoint_hit;$/;"	m	struct:sim_device	file:
+wdt	simio/simio_wdt.c	/^struct wdt {$/;"	s	file:
+wdt_ack_interrupt	simio/simio_wdt.c	/^static void wdt_ack_interrupt(struct simio_device *dev, int irq)$/;"	f	file:
+wdt_check_interrupt	simio/simio_wdt.c	/^static int wdt_check_interrupt(struct simio_device *dev)$/;"	f	file:
+wdt_config	simio/simio_wdt.c	/^static int wdt_config(struct simio_device *dev, const char *param,$/;"	f	file:
+wdt_create	simio/simio_wdt.c	/^struct simio_device *wdt_create(char **arg_text)$/;"	f
+wdt_destroy	simio/simio_wdt.c	/^static void wdt_destroy(struct simio_device *dev)$/;"	f	file:
+wdt_info	simio/simio_wdt.c	/^static int wdt_info(struct simio_device *dev)$/;"	f	file:
+wdt_irq	simio/simio_wdt.c	/^	int				wdt_irq;$/;"	m	struct:wdt	file:
+wdt_read	simio/simio_wdt.c	/^static int wdt_read(struct simio_device *dev, address_t addr, uint16_t *data)$/;"	f	file:
+wdt_reset	simio/simio_wdt.c	/^static void wdt_reset(struct simio_device *dev) {$/;"	f	file:
+wdt_step	simio/simio_wdt.c	/^static void wdt_step(struct simio_device *dev, uint16_t status_register,$/;"	f	file:
+wdt_write	simio/simio_wdt.c	/^static int wdt_write(struct simio_device *dev, address_t addr, uint16_t data)$/;"	f	file:
+wdtctl	simio/simio_wdt.c	/^	uint8_t				wdtctl;$/;"	m	struct:wdt	file:
+what	simio/simio_tracer.c	/^	event_type_t		what;$/;"	m	struct:event	file:
+when	simio/simio_tracer.c	/^	counter_t		when;$/;"	m	struct:event	file:
+write	simio/simio_device.h	/^	int (*write)(struct simio_device *dev,$/;"	m	struct:simio_class
+write_b	simio/simio_device.h	/^	int (*write_b)(struct simio_device *dev,$/;"	m	struct:simio_class
+write_byte	drivers/fet_core.c	/^static int write_byte(struct fet_device *dev, address_t addr, uint8_t value)$/;"	f	file:
+write_byte	drivers/goodfet.c	/^static int write_byte(sport_t fd, address_t addr, uint8_t value)$/;"	f	file:
+write_byte	drivers/pif.c	/^static int write_byte( struct jtdev *p,$/;"	f	file:
+write_flash_block	drivers/goodfet.c	/^static int write_flash_block(sport_t fd, address_t addr,$/;"	f	file:
+write_flash_block	drivers/pif.c	/^static int write_flash_block( struct jtdev *p, address_t addr,$/;"	f	file:
+write_flatfile	ui/flatfile.c	/^static int write_flatfile(const char *path, uint8_t *buf, address_t len)$/;"	f	file:
+write_image	drivers/obl.c	/^static int write_image(transport_t tr, uint32_t addr, uint32_t size,$/;"	f	file:
+write_memory	ui/gdb.c	/^static int write_memory(struct gdb_data *data, char *text)$/;"	f	file:
+write_ram_word	drivers/goodfet.c	/^static int write_ram_word(sport_t fd, address_t addr, uint16_t value)$/;"	f	file:
+write_ram_word	drivers/pif.c	/^int write_ram_word( struct jtdev *p, address_t addr,$/;"	f
+write_registers	ui/gdb.c	/^static int write_registers(struct gdb_data *data, char *buf)$/;"	f	file:
+write_text	util/output.c	/^static int write_text(struct linebuf *ob, const char *text,$/;"	f	file:
+write_valid_size	drivers/obl.c	/^static int write_valid_size(transport_t tr, uint32_t size)$/;"	f	file:
+writemem	drivers/device.h	/^	int (*writemem)(device_t dev, address_t addr,$/;"	m	struct:device_class
+xbuf	util/gdb_proto.h	/^	char            xbuf[1024];$/;"	m	struct:gdb_data
+xfer	drivers/goodfet.c	/^static int xfer(sport_t fd,$/;"	f	file:
+xfer_wait	util/sport.c	/^static int xfer_wait(sport_t s, LPOVERLAPPED ovl)$/;"	f	file:
+zero	util/btree.h	/^	const void      *zero;$/;"	m	struct:btree_def
diff -ruN mspdebug-0.22/ui/cmddb.c mspdebug-0.22-new/ui/cmddb.c
--- mspdebug-0.22/ui/cmddb.c	2013-07-17 20:23:16.000000000 -0400
+++ mspdebug-0.22-new/ui/cmddb.c	2014-03-03 17:49:57.000000000 -0500
@@ -345,6 +345,29 @@
 "    Write session data for the given session to a CSV file.\n"
 "power profile\n"
 "    List power profile data by symbol.\n"
+	},
+	{
+		.name = "search",
+		.func = cmd_search,
+		.help =
+"search <register> <value> <num instructions>\n"
+"    Search all interleavings of interrupts in the first n instructions\n"
+"	 for a path where the specified register contans the specified value\n"
+	},
+	{
+		.name = "intsc",
+		.func = cmd_intsc,
+		.help =
+"intsc <interrupt_vector> <sfr_addr> <sfr_mask>\n"
+"    Executes the interrupt handler pointed to by interrupt_vector and\n"
+"	 displays the CPU state changes induced by the interrupt handler.\n"
+"	 Choose between interrupts that share the same handler entry point by\n"
+"	 setting flags in the flag register (the value in the register at sfr_addr\n"
+"    is logically OR-ing with the sfr_mask to set these flags).\n"
+"	 If no interrupt flags need to be set, sfr_mask should be 0\n"
+"intsc <interrupt_vector> <sfr_addr> <sfr_mask> <num_iter>\n"
+"    Same as the above but executes the interrupt num_iter times before reporting\n"
+"	 state changes.\n"
 	}
 };
 
diff -ruN mspdebug-0.22/ui/devcmd.c mspdebug-0.22-new/ui/devcmd.c
--- mspdebug-0.22/ui/devcmd.c	2013-07-17 20:23:16.000000000 -0400
+++ mspdebug-0.22-new/ui/devcmd.c	2014-03-03 17:49:45.000000000 -0500
@@ -832,3 +832,112 @@
 
 	return 0;
 }
+
+/* Added by Samuel Tan */
+int cmd_search(char **arg)
+{
+	char *reg_mem_text = get_arg(arg);
+	char *val_text = get_arg(arg);
+	char *num_instr_text = get_arg(arg);
+	int is_reg = 1;
+	address_t reg;
+	address_t mem_addr;
+	address_t num_instr;
+	address_t value = 0;
+
+	if (!(num_instr_text && reg_mem_text && val_text)) {
+		printc_err("search: must specify number of instructions, register and a value\n");
+		return -1;
+	}
+
+	reg = dis_reg_from_name(reg_mem_text);
+	if (reg < 0) {
+		if (expr_eval(reg_mem_text, &mem_addr) < 0) {
+			printc_err("search: unknown register or memory address: %s\n", reg_mem_text);
+			return -1;
+		}
+		if ( (mem_addr >= 65536) || (mem_addr < 0) ) {
+			printc_err("search: memory address out of bounds: %s\n", reg_mem_text);
+			return -1;
+		}
+		is_reg = 0;
+	}
+
+	if (expr_eval(val_text, &value) < 0) {
+		printc_err("search: can't parse value: %s\n", val_text);
+		return -1;
+	}
+
+	if (expr_eval(num_instr_text, &num_instr) < 0) {
+		printc_err("search: can't parse value: %s\n", num_instr_text);
+		return -1;
+	}	
+
+	if (num_instr < 1) {
+		printc_err("search: cannot search less than 1 instruction\n");
+		return -1;
+	}
+
+	/* Perform/call search function here */
+	return device_search(num_instr, is_reg, (is_reg ? reg : mem_addr), value);
+}
+
+/* Added by Samuel Tan */
+int cmd_intsc(char **arg)
+{
+	char *vector_addr_text = get_arg(arg);
+	char *sfr_addr_text = get_arg(arg);
+	char *sfr_mask_text = get_arg(arg);
+	char *num_iter_text = get_arg(arg);
+	address_t vector_addr;
+	address_t sfr_addr;
+	address_t sfr_mask;
+	address_t num_iter;
+
+	if (!(vector_addr_text && sfr_addr_text && sfr_mask_text)) {
+		printc_err("intsc: must pass all three arguments. Refer to help for more information.\n");
+		return -1;
+	}
+
+	if (!num_iter_text) {
+		num_iter = 1;
+	} 
+	else {
+		if (expr_eval(num_iter_text, &num_iter) < 0) {
+			printc_err("intsc: can't parse value: %s\n", num_iter_text);
+			return -1;
+		}
+		if ( num_iter < 1 ) {
+			printc_err("intsc: number of iterations cannot be less than 1\n");
+			return -1;	
+		}
+
+	}
+
+	if (expr_eval(vector_addr_text, &vector_addr) < 0) {
+		printc_err("intsc: can't parse value: %s\n", vector_addr_text);
+		return -1;
+	}
+
+	if (expr_eval(sfr_addr_text, &sfr_addr) < 0) {
+		printc_err("intsc: can't parse value: %s\n", sfr_addr_text);
+		return -1;
+	}
+
+	if ( (sfr_addr >= 65536) || (sfr_addr < 0) ) {
+		printc_err("intsc: sfr_addr %04x out of bounds\n", sfr_addr);
+		return -1;
+	}
+
+	if (expr_eval(sfr_mask_text, &sfr_mask) < 0) {
+		printc_err("intsc: can't parse value: %s\n", sfr_mask_text);
+		return -1;
+	}
+
+	if (sfr_mask > 0xffff) {
+		printc_err("intsc: sfr_mask %04x cannot be larger than 2 bytes\n", sfr_mask);
+		return -1;
+	}
+
+	return device_intsc(vector_addr, sfr_addr, sfr_mask, num_iter);
+}
diff -ruN mspdebug-0.22/ui/devcmd.h mspdebug-0.22-new/ui/devcmd.h
--- mspdebug-0.22/ui/devcmd.h	2013-07-17 20:23:16.000000000 -0400
+++ mspdebug-0.22-new/ui/devcmd.h	2014-03-03 17:49:49.000000000 -0500
@@ -39,5 +39,7 @@
 int cmd_delbreak(char **arg);
 int cmd_break(char **arg);
 int cmd_fill(char **arg);
+int cmd_search(char **arg);
+int cmd_intsc(char **arg);
 
 #endif
diff -ruN mspdebug-0.22/util/output_util.c mspdebug-0.22-new/util/output_util.c
--- mspdebug-0.22/util/output_util.c	2013-07-17 20:23:16.000000000 -0400
+++ mspdebug-0.22-new/util/output_util.c	2014-01-22 10:30:27.000000000 -0500
@@ -159,6 +159,39 @@
 	return len;
 }
 
+/* Added by Samuel Tan */
+/* Modified disassemble to only iterate once and not print anything */
+address_t next_instr_addr(address_t offset, const uint8_t *data, int length)
+{
+	int first_line = 1;
+	int num_iterations = 0;
+
+	while (length && (num_iterations < 1)) {
+		struct msp430_instruction insn = {0};
+		int retval;
+		int count;
+		address_t oboff;
+		char obname[MAX_SYMBOL_LENGTH];
+
+		if (first_line ||
+			(!stab_nearest(offset, obname, sizeof(obname), &oboff) &&
+			 !oboff)) {}
+		first_line = 0;
+
+		retval = dis_decode(data, offset, length, &insn);
+		count = retval > 0 ? retval : 2;
+		if (count > length)
+			count = length;
+
+		offset += count;
+		length -= count;
+		data += count;
+		++num_iterations;
+	}
+
+	return offset;
+}
+
 void disassemble(address_t offset, const uint8_t *data, int length,
 		 powerbuf_t power)
 {
diff -ruN mspdebug-0.22/util/output_util.h mspdebug-0.22-new/util/output_util.h
--- mspdebug-0.22/util/output_util.h	2013-07-17 20:23:16.000000000 -0400
+++ mspdebug-0.22-new/util/output_util.h	2014-02-22 18:13:42.000000000 -0500
@@ -49,4 +49,6 @@
  */
 void namelist_print(struct vector *v);
 
+address_t next_instr_addr(address_t offset, const uint8_t *data, int length);
+
 #endif
